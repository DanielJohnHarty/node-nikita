// Generated by CoffeeScript 2.4.1
var metadata, path, propertiesToAction;

path = require('path');

module.exports = function(action_global, action_parent, options_action) {
  var action, base, base1, base2, base3, base4, base5, base6, cascade, headers, k, match, push_headers, ref, ref1, ref2, ref3, ref4, v;
  // Merge cascade action options with default session options
  cascade = {...action_global.cascade, ...((action_parent != null ? action_parent.cascade : void 0) || {}), ...options_action.cascade};
  action = {
    action: options_action.action,
    args: null,
    callback: options_action.callback,
    cascade: cascade,
    error: null,
    error_in_callback: null,
    handler: options_action.handler,
    metadata: {},
    options: {},
    original: (function() { // Create original and filter with cascade
      var k, options, ref, v;
      options = options_action;
      ref = action_parent != null ? action_parent.metadata : void 0;
      for (k in ref) {
        v = ref[k];
        if (options[k] === void 0 && action_global.cascade[k] === true) {
          options[k] = v;
        }
      }
      return options;
    })(),
    output: null,
    parent: action_parent,
    session: null
  };
// Copy initial options
  for (k in options_action) {
    v = options_action[k];
    if (k === 'action') {
      continue;
    }
    if (k === 'cascade') {
      continue;
    }
    if (k === 'handler') {
      continue;
    }
    if (k === 'callback') {
      continue;
    }
    if (metadata[k] !== void 0) {
      action.metadata[k] = v;
    } else {
      if (action.cascade[k] === false) {
        continue;
      }
      action.options[k] = v;
    }
  }
  ref = action_parent != null ? action_parent.metadata : void 0;
  // Merge parent cascaded options
  for (k in ref) {
    v = ref[k];
    if (action.cascade[k] !== true) {
      continue;
    }
    if (action.metadata[k] === void 0) {
      action.metadata[k] = v;
    }
  }
  ref1 = action_parent != null ? action_parent.options : void 0;
  for (k in ref1) {
    v = ref1[k];
    if (action.cascade[k] !== true) {
      continue;
    }
    if (action.options[k] === void 0) {
      action.options[k] = v;
    }
  }
  ref2 = action_global.options;
  // Merge action options with default session options
  // All options are merge
  for (k in ref2) {
    v = ref2[k];
    if (k === 'cascade') {
      continue;
    }
    if (action.options[k] === void 0) {
      action.options[k] = v;
    }
  }
  // Build headers option
  headers = [];
  push_headers = function(action) {
    if (action.metadata.header) {
      headers.push(action.metadata.header);
    }
    if (action.parent) {
      return push_headers(action.parent);
    }
  };
  push_headers(action);
  action.metadata.headers = headers.reverse();
  // Default values
  if ((base = action.metadata).debug == null) {
    base.debug = false;
  }
  if ((base1 = action.metadata).deprecate == null) {
    base1.deprecate = false;
  }
  if ((base2 = action.metadata).sleep == null) {
    base2.sleep = 3000; // Wait 3s between retry
  }
  if ((base3 = action.metadata).retry == null) {
    base3.retry = 0;
  }
  if ((base4 = action.metadata).disabled == null) {
    base4.disabled = false;
  }
  if ((base5 = action.metadata).status == null) {
    base5.status = true;
  }
  action.metadata.depth = action.metadata.depth != null ? action.metadata.depth : (((ref3 = action.parent) != null ? (ref4 = ref3.metadata) != null ? ref4.depth : void 0 : void 0) || 0) + 1;
  action.metadata.attempt = -1; // Clone and filter cascaded options
  if ((base6 = action.metadata).shy == null) {
    base6.shy = false;
  }
  // Goodies
  if (action.options.source && (match = /~($|\/.*)/.exec(action.options.source))) {
    if (!action_global.store['nikita:ssh:connection']) {
      action.options.source = path.join(process.env.HOME, match[1]);
    } else {
      action.options.source = path.posix.join('.', match[1]);
    }
  }
  if (action.options.target && (match = /~($|\/.*)/.exec(action.options.target))) {
    if (!action_global.store['nikita:ssh:connection']) {
      action.options.target = path.join(process.env.HOME, match[1]);
    } else {
      action.options.target = path.posix.join('.', match[1]);
    }
  }
  return action;
};

propertiesToAction = function(userAction) {
  var action, k, v;
  action = {
    metadata: {},
    options: {}
  };
  for (k in userAction) {
    v = userAction[k];
    switch (k) {
      case 'action':
      case 'callback':
      case 'cascade':
      case 'handler':
        action[k] = v;
        break;
      default:
        if (metadata[k] !== void 0) {
          action.metadata[k] = v;
        } else {
          action.options[k] = v;
        }
    }
  }
  return action;
};

metadata = module.exports.metadata = {
  after: null,
  argument: null,
  attempt: -1,
  before: null,
  cascade: {},
  debug: false,
  deprecate: false,
  depth: 0,
  disabled: false,
  get: false,
  header: [],
  log: null,
  once: false,
  relax: false,
  retry: 0,
  schema: null,
  shy: false,
  sleep: 3000,
  status: true,
  tolerant: false
};
