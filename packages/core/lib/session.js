// Generated by CoffeeScript 2.3.2
// # Nikita Session
var EventEmitter, array, conditions, each, merge, path, promise, registry, state_create_level, state_reset_level, string, util, wrap;

module.exports = function() {
  var call_callback, enrich_options, handle_get, handle_multiple_call, jump_to_error, normalize_options, obj, options_filter_cascade, proxy, reg, run, run_next, state;
  if (arguments.length === 2) {
    obj = arguments[0];
    obj.options = arguments[1];
  } else if (arguments.length === 1) {
    obj = new EventEmitter;
    obj.options = arguments[0];
  } else {
    obj = new EventEmitter;
    obj.options = {};
  }
  if (obj.registry == null) {
    obj.registry = {};
  }
  if (obj.store == null) {
    obj.store = {};
  }
  // Internal state
  state = {};
  state.properties = {};
  state.parent_levels = [];
  state.current_level = state_create_level();
  state.befores = [];
  state.afters = [];
  state.once = {};
  state.killed = false;
  state.index_counter = 0;
  // Proxify
  proxy = new Proxy(obj, {
    has: function(target, name) {
      return console.warns('proxy has is being called', name);
    },
    apply: function(target, thisArg, argumentsList) {
      return console.warn('apply');
    },
    get: function(target, name) {
      var get_proxy_builder;
      if (obj[name] != null) {
        return target[name];
      }
      if (name === '_events' || name === '_maxListeners' || name === 'internal') {
        return target[name];
      }
      proxy.action = [];
      proxy.action.push(name);
      if (!obj.registry.registered(proxy.action, {
        parent: true
      }) && !registry.registered(proxy.action, {
        parent: true
      })) {
        proxy.action = [];
        return void 0;
      }
      get_proxy_builder = function() {
        var builder;
        builder = function() {
          var args, get, l, len, options, opts, values;
          args = [].slice.call(arguments);
          options = normalize_options(args, proxy.action);
          proxy.action = [];
          ({get, values} = handle_get(proxy, options));
          if (get) {
            return values;
          }
          for (l = 0, len = options.length; l < len; l++) {
            opts = options[l];
            state.current_level.todos.push(opts);
          }
          if (state.current_level.todos.length === options.length) { // Activate the pump
            setImmediate(run_next);
          }
          return proxy;
        };
        return new Proxy(builder, {
          get: function(target, name) {
            if (target[name] != null) {
              return target[name];
            }
            proxy.action.push(name);
            if (!obj.registry.registered(proxy.action, {
              parent: true
            }) && !registry.registered(proxy.action, {
              parent: true
            })) {
              proxy.action = [];
              return void 0;
            }
            return get_proxy_builder();
          }
        });
      };
      return get_proxy_builder();
    }
  });
  obj.internal = {};
  obj.internal.options = function(_arguments, action_name, params = {}) {
    var __argument, __arguments, action, actions, args, i, j, k, l, len, len1, len2, len3, m, middleware, n, newaction, newactions, o, opt, option, v;
    if (params.enrich == null) {
      params.enrich = true;
    }
    // Does the actions require a handler
    if (params.handler == null) {
      params.handler = false;
    }
    if (_arguments.length === 0) {
      _arguments = [{}];
    }
// Convert every argument to an array
    for (i = l = 0, len = _arguments.length; l < len; i = ++l) {
      args = _arguments[i];
      if (!Array.isArray(args)) {
        _arguments[i] = [args];
      }
    }
    if (Array.isArray(action_name)) {
      // Get middleware
      middleware = obj.registry.get(action_name) || registry.get(action_name);
    }
    // Multiply arguments
    actions = null;
    for (i = m = 0, len1 = _arguments.length; m < len1; i = ++m) {
      __arguments = _arguments[i];
      newactions = (function() {
        var len2, n, results;
        results = [];
        for (j = n = 0, len2 = __arguments.length; n < len2; j = ++n) {
          __argument = __arguments[j];
          if (i === 0) {
            results.push([[middleware, __argument]]);
          } else {
            results.push((function() {
              var len3, o, results1;
              results1 = [];
              for (i = o = 0, len3 = actions.length; o < len3; i = ++o) {
                action = actions[i];
                results1.push([...action, __argument]);
              }
              return results1;
            })());
          }
        }
        return results;
      })();
      actions = array.flatten(newactions, 0);
    }
    // Load module
    if (!middleware) {
      for (n = 0, len2 = actions.length; n < len2; n++) {
        action = actions[n];
        middleware = null;
        for (o = 0, len3 = action.length; o < len3; o++) {
          option = action[o];
          if (typeof option === 'string') {
            middleware = option;
            if (option.substr(0, 1) === '.') {
              middleware = path.resolve(process.cwd(), option);
            }
            middleware = require.main.require(middleware);
          }
        }
        if (middleware) {
          action.unshift(middleware);
        }
      }
    }
    // Build actions
    actions = (function() {
      var len4, len5, p, q, results;
      results = [];
      for (p = 0, len4 = actions.length; p < len4; p++) {
        action = actions[p];
        newaction = {};
        for (q = 0, len5 = action.length; q < len5; q++) {
          opt = action[q];
          if (action == null) {
            continue;
          }
          if (typeof opt === 'string') {
            if (!newaction.argument) {
              opt = {
                argument: opt
              };
            } else {
              throw Error('Invalid option: encountered a string while argument is already defined');
            }
          }
          if (typeof opt === 'function') {
            // todo: handler could be registed later by an external module,
            // in such case, the user provided function should be interpreted
            // as a callback
            if (!newaction.handler) {
              opt = {
                handler: opt
              };
            } else if (!newaction.callback) {
              opt = {
                callback: opt
              };
            } else {
              throw Error('Invalid option: encountered a function while both handler and callback options are defined.');
            }
          }
          if (typeof opt !== 'object') {
            opt = {
              argument: opt
            };
          }
          for (k in opt) {
            v = opt[k];
            if (newaction[k] !== void 0 && v === void 0) {
              continue;
            }
            newaction[k] = v;
          }
        }
        results.push(newaction);
      }
      return results;
    })();
    // Normalize
    actions = (function() {
      var len4, p, ref, results;
      results = [];
      for (p = 0, len4 = actions.length; p < len4; p++) {
        action = actions[p];
        if (action_name) {
          // Enrich
          action.action = action_name;
        }
        if (!Array.isArray(action.action)) {
          action.action = [action.action];
        }
        if (params.enrich && ((ref = action.callback) != null ? ref.length : void 0) > 2) { // Doesnt seem to be used anywhere
          action.user_args = true;
        }
        if (action.once === true) {
          action.once = ['handler'];
        }
        if (action.once === false) {
          delete action.once;
        }
        if (Array.isArray(action.once)) {
          action.once = action.once.sort();
        }
        if (Array.isArray(action.once)) {
          action.once = action.once.sort();
        }
        // Validation
        if (params.handler) {
          if (!action.handler) {
            throw Error('Missing handler option');
          }
          if (typeof action.handler !== 'function') {
            throw Error(`Invalid Handler: expect a function, got '${action.handler}'`);
          }
        }
        results.push(action);
      }
      return results;
    })();
    return actions;
  };
  normalize_options = obj.internal.options;
  enrich_options = function(options_action) {
    var headers, k, match, options, options_parent, options_session, push_headers, ref, v;
    options_session = obj.options;
    if (options_session.cascade == null) {
      options_session.cascade = {};
    }
    options_parent = state.current_level.options;
    options = {};
    options.parent = options_parent;
    // Merge cascade action options with default session options
    options.cascade = {...module.exports.cascade, ...options_session.cascade, ...options_action.cascade};
// Copy initial options
    for (k in options_action) {
      v = options_action[k];
      if (k === 'cascade') {
        continue;
      }
      options[k] = options_action[k];
    }
// Merge parent cascaded options
    for (k in options_parent) {
      v = options_parent[k];
      if (options.cascade[k] !== true) {
        continue;
      }
      if (options[k] === void 0) {
        options[k] = v;
      }
    }
// Merge action options with default session options 
    for (k in options_session) {
      v = options_session[k];
      if (k === 'cascade') {
        continue;
      }
      if (options[k] === void 0) {
        options[k] = v;
      }
    }
    // Build headers option
    headers = [];
    push_headers = function(options) {
      if (options.header) {
        headers.push(options.header);
      }
      if (options.parent) {
        return push_headers(options.parent);
      }
    };
    push_headers(options);
    options.headers = headers.reverse();
    // Default values
    if (options.sleep == null) {
      options.sleep = 3000; // Wait 3s between retry
    }
    if (options.retry == null) {
      options.retry = 0;
    }
    if (options.disabled == null) {
      options.disabled = false;
    }
    if (options.status == null) {
      options.status = true;
    }
    options.depth = options.depth != null ? options.depth : (((ref = options.parent) != null ? ref.depth : void 0) || 0) + 1;
    // throw Error 'Incompatible Options: status "false" implies shy "true"' if options.status is false and options.shy is false # Room for argument, leave it strict for now until we come accross a usecase justifying it.
    // options.shy ?= true if options.status is false
    if (options.shy == null) {
      options.shy = false;
    }
    // Goodies
    if (options.source && (match = /~($|\/.*)/.exec(options.source))) {
      if (!obj.store['nikita:ssh:connection']) {
        options.source = path.join(process.env.HOME, match[1]);
      } else {
        options.source = path.posix.join('.', match[1]);
      }
    }
    if (options.target && (match = /~($|\/.*)/.exec(options.target))) {
      if (!obj.store['nikita:ssh:connection']) {
        options.target = path.join(process.env.HOME, match[1]);
      } else {
        options.target = path.posix.join('.', match[1]);
      }
    }
    return options;
  };
  handle_get = function(proxy, options) {
    var opts, values;
    if (options.length !== 1) {
      return {
        get: false
      };
    }
    options = options[0];
    if (options.get !== true) {
      return {
        get: false
      };
    }
    options = enrich_options(options);
    opts = options_filter_cascade(options);
    values = options.handler.call(proxy, {
      options: opts
    }, options.callback);
    return {
      get: true,
      values: values
    };
  };
  options_filter_cascade = function(options) {
    var k, opts, v;
    opts = {};
    for (k in options) {
      v = options[k];
      if (options.cascade[k] === false) {
        continue;
      }
      opts[k] = v;
    }
    return opts;
  };
  call_callback = function(fn, callbackargs) {
    var current_level, error;
    state.parent_levels.unshift(state.current_level);
    state.current_level = state_create_level();
    try {
      fn.call(proxy, callbackargs.error, callbackargs.output, ...(callbackargs.args || []));
    } catch (error1) {
      error = error1;
      state.current_level = state.parent_levels.shift();
      state.current_level.error = error;
      jump_to_error();
      callbackargs.error = error;
      return run_next();
    }
    current_level = state.current_level;
    state.current_level = state.parent_levels.shift();
    if (current_level.todos.length) {
      return state.current_level.todos.unshift(...current_level.todos);
    }
  };
  handle_multiple_call = function(error) {
    state.killed = true;
    while (state.parent_levels.length) {
      state.current_level = state.parent_levels.shift();
    }
    state.current_level.error = error;
    jump_to_error();
    return run_next();
  };
  jump_to_error = function() {
    var ref, results;
    results = [];
    while (state.current_level.todos[0] && ((ref = state.current_level.todos[0].action) !== 'catch' && ref !== 'next' && ref !== 'promise')) {
      results.push(state.current_level.todos.shift());
    }
    return results;
  };
  run_next = function(callback) {
    var options;
    options = state.current_level.todos.shift();
    // Nothing more to do in current queue
    if (!options) {
      if (!state.killed && state.parent_levels.length === 0 && state.current_level.error && state.current_level.throw_if_error) {
        obj.emit('error', state.current_level.error);
        if (obj.listenerCount() !== 0) {
          throw state.current_level.error;
        }
      }
      if (state.parent_levels.length === 0) {
        if (!state.current_level.error) {
          obj.emit('end', {
            level: 'INFO'
          });
        }
      }
      return;
    }
    return run(options);
  };
  run = function(options, callback) {
    var error, errors, history, index, k, options_original, options_parent, ref, ref1, status, v;
    // options = state.current_level.todos.shift() unless options
    options_original = options;
    options_parent = state.current_level.options;
    obj.cascade = {...obj.options.cascade, ...module.exports.cascade};
    for (k in options_parent) {
      v = options_parent[k];
      if (options_original[k] === void 0 && obj.cascade[k] === true) {
        options_original[k] = v;
      }
    }
    options.original = options_original;
    if (options.action === 'next') {
      ({error, history} = state.current_level);
      if (!error) {
        errors = history.some(function(action) {
          return !action.options.tolerant && error;
        });
        error = errors[errors.length - 1];
      }
      status = history.some(function(action) {
        return !action.options.shy && action.status;
      });
      if ((ref = options.handler) != null) {
        ref.call(proxy, error, {
          status: status
        });
      }
      state_reset_level(state.current_level);
      run_next();
      return;
    }
    if (options.action === 'promise') {
      ({error, history} = state.current_level);
      if (!error) {
        errors = history.some(function(action) {
          return !action.options.tolerant && error;
        });
        error = errors[errors.length - 1];
      }
      status = history.some(function(action) {
        return !action.options.shy && action.status;
      });
      if ((ref1 = options.handler) != null) {
        ref1.call(proxy, error, status);
      }
      if (!error) {
        options.deferred.resolve(status);
      } else {
        options.deferred.reject(error);
      }
      state_reset_level(state.current_level);
      return;
    }
    if (state.killed) {
      return;
    }
    if (array.compare(options.action, ['end'])) {
      return conditions.all(proxy, {
        options: options
      }, function() {
        var ref2;
        while (state.current_level.todos[0] && ((ref2 = state.current_level.todos[0].action) !== 'next' && ref2 !== 'promise')) {
          state.current_level.todos.shift();
        }
        if (callback) {
          callback(error, {});
        }
        return run_next();
      }, function(error) {
        if (callback) {
          callback(error, {});
        }
        return run_next();
      });
    }
    options = enrich_options(options);
    index = state.index_counter++;
    state.current_level.history.unshift({
      status: void 0,
      options: {
        shy: options.shy
      }
    });
    state.parent_levels.unshift(state.current_level);
    state.current_level = state_create_level();
    state.current_level.options = options;
    if (options.header) {
      proxy.log({
        message: options.header,
        type: 'header',
        index: index,
        headers: options.headers
      });
    }
    return (function() {
      var do_callback, do_conditions, do_disabled, do_handler, do_intercept_after, do_intercept_before, do_once, do_options, do_options_after, do_options_before;
      do_options = function() {
        try {
          if (!(typeof options.sleep === 'number' && options.sleep >= 0)) {
            // Validation
            throw Error(`Invalid options sleep, got ${JSON.stringify(options.sleep)}`);
          }
        } catch (error1) {
          error = error1;
          do_callback({
            error: error,
            output: {
              status: false
            }
          });
          return;
        }
        return wrap.options(options, function(error) {
          return do_disabled();
        });
      };
      do_disabled = function() {
        if (!options.disabled) {
          proxy.log({
            type: 'lifecycle',
            message: 'disabled_false',
            level: 'DEBUG',
            index: index,
            error: null,
            status: false
          });
          return do_once();
        } else {
          proxy.log({
            type: 'lifecycle',
            message: 'disabled_true',
            level: 'INFO',
            index: index,
            error: null,
            status: false
          });
          return do_callback({
            error: void 0,
            output: {
              status: false
            }
          });
        }
      };
      do_once = function() {
        var hash, hashme;
        hashme = function(value) {
          if (typeof value === 'string') {
            value = `string:${string.hash(value)}`;
          } else if (typeof value === 'boolean') {
            value = `boolean:${value}`;
          } else if (typeof value === 'function') {
            value = `function:${string.hash(value.toString())}`;
          } else if (value === void 0 || value === null) {
            value = 'null';
          } else if (Array.isArray(value)) {
            value = 'array:' + value.sort().map(function(value) {
              return hashme(value);
            }).join(':');
          } else if (typeof value === 'object') {
            value = 'object';
          } else {
            throw Error(`Invalid data type: ${JSON.stringify(value)}`);
          }
          return value;
        };
        if (options.once) {
          if (typeof options.once === 'string') {
            hash = string.hash(options.once);
          } else if (Array.isArray(options.once)) {
            hash = string.hash(options.once.map(function(k) {
              return hashme(options[k]);
            }).join('|'));
          } else {
            throw Error(`Invalid Option 'once': ${JSON.stringify(options.once)} must be a string or an array of string`);
          }
          if (state.once[hash]) {
            return do_callback({
              error: void 0,
              output: {
                status: false
              }
            });
          }
          state.once[hash] = true;
        }
        return do_options_before();
      };
      do_options_before = function() {
        if (options.options_before) {
          return do_intercept_before();
        }
        if (options.before == null) {
          options.before = [];
        }
        if (!Array.isArray(options.before)) {
          options.before = [options.before];
        }
        return each(options.before).call(function(before, next) {
          var opts;
          before = normalize_options([before], 'call', {
            enrich: false
          });
          before = before[0];
          opts = {
            options_before: true
          };
          for (k in before) {
            v = before[k];
            opts[k] = v;
          }
          for (k in options) {
            v = options[k];
            if (k === 'handler' || k === 'callback') {
              continue;
            }
            if (opts[k] == null) {
              opts[k] = v;
            }
          }
          return run(opts, next);
        }).error(function(error) {
          return do_callback({
            error: error,
            output: {
              status: false
            }
          });
        }).next(do_intercept_before);
      };
      do_intercept_before = function() {
        if (options.intercepting) {
          return do_conditions();
        }
        return each(state.befores).call(function(before, next) {
          var opts;
          for (k in before) {
            v = before[k];
            switch (k) {
              case 'handler':
                continue;
              case 'action':
                if (!array.compare(v, options[k])) {
                  return next();
                }
                break;
              default:
                if (v !== options[k]) {
                  return next();
                }
            }
          }
          opts = {
            intercepting: true
          };
          for (k in before) {
            v = before[k];
            opts[k] = v;
          }
          for (k in options) {
            v = options[k];
            if (k === 'handler' || k === 'callback') {
              continue;
            }
            if (opts[k] == null) {
              opts[k] = v;
            }
          }
          return run(opts, next);
        }).error(function(error) {
          return do_callback({
            error: error,
            output: {
              status: false
            }
          });
        }).next(do_conditions);
      };
      do_conditions = function() {
        return conditions.all(proxy, {
          options: options
        }, function() {
// Remove conditions from options
          for (k in options) {
            v = options[k];
            if (/^if.*/.test(k) || /^unless.*/.test(k)) {
              delete options[k];
            }
          }
          proxy.log({
            type: 'lifecycle',
            message: 'conditions_passed',
            index: index,
            error: null,
            status: false
          });
          return do_handler();
        }, function(error) {
          proxy.log({
            type: 'lifecycle',
            message: 'conditions_failed',
            index: index,
            error: error,
            status: false
          });
          return do_callback({
            error: error,
            output: {
              status: false
            }
          });
        });
      };
      options.attempt = -1;
      do_handler = function() {
        var called, context, do_next, handle_async_and_promise, options_callback, options_handler, options_handler_length, opts, promise_returned, ref2, ref3, result, status_sync, wait_children;
        options.attempt++;
        do_next = function({error, output, args}) {
          var base, base1, callbackargs;
          callbackargs = {
            error: error,
            output: output,
            args: args
          };
          options.handler = options_handler;
          options.callback = options_callback;
          if (error && !(error instanceof Error)) {
            error = Error('First argument not a valid error');
            callbackargs.error = error;
            if (callbackargs.output == null) {
              callbackargs.output = {};
            }
            if ((base = callbackargs.output).status == null) {
              base.status = false;
            }
          } else {
            if (typeof output === 'boolean') {
              callbackargs.output = {
                status: output
              };
            } else if (!output) {
              callbackargs.output = {
                status: false
              };
            } else if (typeof output !== 'object') {
              callbackargs.error = Error(`Invalid Argument: expect an object or a boolean, got ${JSON.stringify(output)}`);
            } else {
              if ((base1 = callbackargs.output).status == null) {
                base1.status = false;
              }
            }
          }
          if (error) {
            proxy.log({
              message: error.message,
              level: 'ERROR',
              index: index,
              module: 'nikita'
            });
          }
          if (error && (options.retry === true || options.attempt < options.retry - 1)) {
            proxy.log({
              message: `Retry on error, attempt ${options.attempt + 1}`,
              level: 'WARN',
              index: index,
              module: 'nikita'
            });
            return setTimeout(do_handler, options.sleep);
          }
          return do_intercept_after(callbackargs);
        };
        if (options.handler == null) {
          options.handler = ((ref2 = obj.registry.get(options.action)) != null ? ref2.handler : void 0) || ((ref3 = registry.get(options.action)) != null ? ref3.handler : void 0);
        }
        if (!options.handler) {
          return handle_multiple_call(Error(`Unregistered Middleware: ${options.action.join('.')}`));
        }
        options_handler = options.handler;
        options_handler_length = options.handler.length;
        options.handler = void 0;
        options_callback = options.callback;
        options.callback = void 0;
        called = false;
        try {
          // Clone and filter cascaded options
          opts = options_filter_cascade(options);
          if (options.deprecate) {
            // Handle deprecation
            options_handler = (function(options_handler) {
              return util.deprecate(function() {
                return options_handler.apply(this, arguments);
              }, options.deprecate === true ? `${options.action.join('/')} is deprecated` : `${options.action.join('/')} is deprecated, use ${options.deprecate}`);
            })(options_handler);
          }
          handle_async_and_promise = function() {
            var args, output;
            [error, output, ...args] = arguments;
            if (state.killed) {
              return;
            }
            if (called) {
              return handle_multiple_call(Error('Multiple call detected'));
            }
            called = true;
            return setImmediate(function() {
              return do_next({
                error: error,
                output: output,
                args: args
              });
            });
          };
          // Prepare the Context
          context = {
            options: opts,
            session: proxy
          };
          // Call the action
          if (options_handler_length === 2) { // Async style
            promise_returned = false;
            result = options_handler.call(proxy, context, function() {
              if (promise_returned) {
                return;
              }
              return handle_async_and_promise.apply(null, arguments);
            });
            if (promise.is(result)) {
              promise_returned = true;
              return handle_async_and_promise(Error('Invalid Promise: returning promise is not supported in asynchronuous mode')); // Sync style
            }
          } else {
            result = options_handler.call(proxy, context);
            if (promise.is(result)) { // result is a promisee
              return result.then(function(value) {
                var args, output;
                if (Array.isArray(value)) {
                  [output, ...args] = value;
                } else {
                  output = value;
                  args = [];
                }
                // value = [value] unless Array.isArray value
                // handle_async_and_promise error: null, output: output, args: args
                return handle_async_and_promise(void 0, output, ...args);
              }, function(reason) {
                if (reason == null) {
                  reason = Error('Rejected Promise: reject called without any arguments');
                }
                // handle_async_and_promise error: reason
                return handle_async_and_promise(reason);
              });
            } else {
              if (state.killed) {
                return;
              }
              if (called) {
                return handle_multiple_call(Error('Multiple call detected'));
              }
              called = true;
              status_sync = false;
              wait_children = function() {
                var loptions;
                if (!state.current_level.todos.length) {
                  return setImmediate(function() {
                    return do_next({
                      output: {
                        status: status_sync
                      }
                    });
                  });
                }
                loptions = state.current_level.todos.shift();
                return run(loptions, function(error, {status}) {
                  if (error) {
                    return do_next({
                      error: error
                    });
                  }
                  if (status && !loptions.shy) {
                    // Discover status of all unshy children
                    status_sync = true;
                  }
                  return wait_children();
                });
              };
              return wait_children();
            }
          }
        } catch (error1) {
          error = error1;
          state.current_level = state_create_level();
          return do_next({
            error: error
          });
        }
      };
      do_intercept_after = function(callbackargs, callback) {
        if (options.intercepting) {
          return do_options_after(callbackargs);
        }
        return each(state.afters).call(function(after, next) {
          var opts;
          for (k in after) {
            v = after[k];
            switch (k) {
              case 'handler':
                continue;
              case 'action':
                if (!array.compare(v, options[k])) {
                  return next();
                }
                break;
              default:
                if (v !== options[k]) {
                  return next();
                }
            }
          }
          opts = {
            intercepting: true
          };
          for (k in after) {
            v = after[k];
            opts[k] = v;
          }
          for (k in options) {
            v = options[k];
            if (k === 'handler' || k === 'callback') {
              continue;
            }
            if (opts[k] == null) {
              opts[k] = v;
            }
          }
          opts.callback_arguments = callbackargs;
          return run(opts, next);
        }).error(function(error) {
          return do_callback({
            error: error,
            output: {
              status: false
            }
          });
        }).next(function() {
          return do_options_after(callbackargs);
        });
      };
      do_options_after = function(callbackargs) {
        if (options.options_after) {
          return do_callback(callbackargs);
        }
        if (options.after == null) {
          options.after = [];
        }
        if (!Array.isArray(options.after)) {
          options.after = [options.after];
        }
        return each(options.after).call(function(after, next) {
          var opts;
          after = normalize_options([after], 'call', {
            enrich: false
          });
          after = after[0];
          opts = {
            options_after: true
          };
          for (k in after) {
            v = after[k];
            opts[k] = v;
          }
          for (k in options) {
            v = options[k];
            if (k === 'handler' || k === 'callback') {
              continue;
            }
            if (opts[k] == null) {
              opts[k] = v;
            }
          }
          return run(opts, next);
        }).error(function(error) {
          return do_callback({
            error: error,
            output: {
              status: false
            }
          });
        }).next(function() {
          return do_callback(callbackargs);
        });
      };
      do_callback = function(callbackargs) {
        var base;
        proxy.log({
          type: 'handled',
          index: index,
          error: callbackargs.error,
          status: callbackargs.output.status
        });
        if (state.killed) {
          return;
        }
        if (!callbackargs.error) { // Error is undefined and not null or false
          callbackargs.error = void 0;
        }
        state.current_level = state.parent_levels.shift(); // Exit action state and move back to parent state
        if (callbackargs.error && options.callback) {
          state.current_level.throw_if_error = false;
        }
        state.current_level.history[0].status = options.status ? callbackargs.output.status : false;
        state.current_level.history[0].error = callbackargs.error;
        state.current_level.history[0].output = callbackargs.output;
        if (callbackargs.error && !options.relax) {
          state.current_level.error = callbackargs.error;
          jump_to_error();
        }
        if (options.callback) {
          call_callback(options.callback, callbackargs);
        }
        if (options.relax) {
          callbackargs.error = null;
        }
        if (callbackargs.output == null) {
          callbackargs.output = {};
        }
        if ((base = callbackargs.output).status == null) {
          base.status = false;
        }
        callbackargs.output = merge({}, callbackargs.output);
        if (callback) {
          callback(callbackargs.error, callbackargs.output);
        }
        return run_next();
      };
      return do_options();
    })();
  };
  state.properties.child = {
    get: function() {
      return function() {
        return module.exports(obj.options);
      };
    }
  };
  state.properties.next = {
    get: function() {
      return function() {
        state.current_level.todos.push({
          action: 'next',
          handler: arguments[0]
        });
        if (state.current_level.todos.length === 1) { // Activate the pump
          setImmediate(run_next);
        }
        return proxy;
      };
    }
  };
  state.properties.promise = {
    get: function() {
      return function() {
        var deferred, promise;
        deferred = {};
        promise = new Promise(function(resolve, reject) {
          deferred.resolve = resolve;
          return deferred.reject = reject;
        });
        state.current_level.todos.push({
          action: 'promise',
          deferred: deferred // handler: arguments[0],
        });
        if (state.current_level.todos.length === 1) { // Activate the pump
          setImmediate(run_next);
        }
        return promise;
      };
    }
  };
  state.properties.end = {
    get: function() {
      return function() {
        var args, l, len, options, opts;
        args = [].slice.call(arguments);
        options = normalize_options(args, 'end');
        for (l = 0, len = options.length; l < len; l++) {
          opts = options[l];
          state.current_level.todos.push(opts);
        }
        if (state.current_level.todos.length === options.length) { // Activate the pump
          setImmediate(run_next);
        }
        return proxy;
      };
    }
  };
  state.properties.call = {
    get: function() {
      return function() {
        var args, get, l, len, options, opts, values;
        args = [].slice.call(arguments);
        options = normalize_options(args, 'call');
        ({get, values} = handle_get(proxy, options));
        if (get) {
          return values;
        }
        for (l = 0, len = options.length; l < len; l++) {
          opts = options[l];
          state.current_level.todos.push(opts);
        }
        if (state.current_level.todos.length === options.length) { // Activate the pump
          setImmediate(run_next);
        }
        return proxy;
      };
    }
  };
  state.properties.each = {
    get: function() {
      return function() {
        var arg, args, key, l, len, len1, m, options, opts, value;
        args = [].slice.call(arguments);
        arg = args.shift();
        if ((arg == null) || typeof arg !== 'object') {
          state.current_level.error = Error(`Invalid Argument: first argument must be an array or an object to iterate, got ${JSON.stringify(arg)}`);
          jump_to_error();
          return proxy;
        }
        options = normalize_options(args, 'call');
        for (l = 0, len = options.length; l < len; l++) {
          opts = options[l];
          if (Array.isArray(arg)) {
            for (m = 0, len1 = arg.length; m < len1; m++) {
              key = arg[m];
              opts.key = key;
              this.call(opts);
            }
          } else {
            for (key in arg) {
              value = arg[key];
              opts.key = key;
              opts.value = value;
              this.call(opts);
            }
          }
        }
        return proxy;
      };
    }
  };
  state.properties.before = {
    get: function() {
      return function() {
        var l, len, options, opts;
        if (typeof arguments[0] === 'string' || Array.isArray(arguments[0])) {
          arguments[0] = {
            action: arguments[0]
          };
        }
        options = normalize_options(arguments, null, {
          enrich: false
        });
        for (l = 0, len = options.length; l < len; l++) {
          opts = options[l];
          if (typeof opts.handler !== 'function') {
            throw Error(`Invalid handler ${JSON.stringify(opts.handler)}`);
          }
          state.befores.push(opts);
        }
        return proxy;
      };
    }
  };
  state.properties.after = {
    get: function() {
      return function() {
        var l, len, options, opts;
        if (typeof arguments[0] === 'string' || Array.isArray(arguments[0])) {
          arguments[0] = {
            action: arguments[0]
          };
        }
        options = normalize_options(arguments, null, {
          enrich: false
        });
        for (l = 0, len = options.length; l < len; l++) {
          opts = options[l];
          if (typeof opts.handler !== 'function') {
            throw Error(`Invalid handler ${JSON.stringify(opts.handler)}`);
          }
          state.afters.push(opts);
        }
        return proxy;
      };
    }
  };
  state.properties.status = {
    get: function() {
      return function(index) {
        var action, l, len, len1, m, ref, ref1, ref2, status;
        if (arguments.length === 0) {
          return state.parent_levels[0].history.some(function(action) {
            return !action.options.shy && action.status;
          });
        } else if (index === false) {
          status = state.parent_levels[0].history.some(function(action) {
            return !action.options.shy && action.status;
          });
          ref = state.parent_levels[0].history;
          for (l = 0, len = ref.length; l < len; l++) {
            action = ref[l];
            action.status = false;
          }
          return status;
        } else if (index === true) {
          status = state.parent_levels[0].history.some(function(action) {
            return !action.options.shy && action.status;
          });
          ref1 = state.parent_levels[0].history;
          for (m = 0, len1 = ref1.length; m < len1; m++) {
            action = ref1[m];
            action.status = true;
          }
          return status;
        } else {
          return (ref2 = state.parent_levels[0].history[Math.abs(index)]) != null ? ref2.status : void 0;
        }
      };
    }
  };
  Object.defineProperties(obj, state.properties);
  reg = registry.registry({});
  Object.defineProperty(obj.registry, 'get', {
    get: function() {
      return function(name, handler) {
        return reg.get(...arguments);
      };
    }
  });
  Object.defineProperty(obj.registry, 'register', {
    get: function() {
      return function(name, handler) {
        reg.register(...arguments);
        return proxy;
      };
    }
  });
  Object.defineProperty(obj.registry, 'registered', {
    get: function() {
      return function(name, handler) {
        return reg.registered(...arguments);
      };
    }
  });
  Object.defineProperty(obj.registry, 'unregister', {
    get: function() {
      return function(name, handler) {
        reg.unregister(...arguments);
        return proxy;
      };
    }
  });
  // Todo: remove
  if (obj.options.ssh) {
    if (obj.options.ssh.config) {
      obj.store['nikita:ssh:connection'] = obj.options.ssh;
      delete obj.options.ssh;
    } else {
      if (!obj.options.no_ssh) {
        proxy.ssh.open(obj.options.ssh);
      }
    }
  }
  return proxy;
};

module.exports.cascade = {
  cwd: true,
  ssh: true,
  log: true,
  stdout: true,
  stderr: true,
  debug: true,
  after: false,
  before: false,
  cascade: true,
  depth: null,
  disabled: false,
  handler: false,
  header: null,
  once: false,
  relax: false,
  shy: false,
  sleep: false,
  sudo: true
};

// ## Helper functions
state_create_level = function() {
  var level;
  return level = {
    error: null,
    history: [],
    todos: [],
    throw_if_error: true
  };
};

// Called after next and promise
state_reset_level = function(level) {
  level.error = null;
  // History elements contains the following keys:
  // options, status, output, args
  level.history = [];
  return level.throw_if_error = true;
};

// ## Dependencies
registry = require('./registry');

each = require('each');

path = require('path');

util = require('util');

array = require('./misc/array');

promise = require('./misc/promise');

conditions = require('./misc/conditions');

wrap = require('./misc/wrap');

string = require('./misc/string');

({merge} = require('./misc'));

({EventEmitter} = require('events'));
