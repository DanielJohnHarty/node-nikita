// Generated by CoffeeScript 2.5.1
// # `nikita.connection.wait`

// Check if one or multiple hosts listen one or multiple ports periodically and
// continue once all the connections succeed. Status will be set to "false" if the
// user connections succeed right away, considering that no change had occured.
// Otherwise it will be set to "true".   

// ## Options

// * `host`, `hosts` (array|string)  
//   One or multiple hosts, used to build or enrich the 'servers' option.
// * `interval` (number)  
//   Time in millisecond between each connection attempt.
// * `quorum` (number|boolean)  
//   Number of minimal successful connection, 50%+1 if "true".    
// * `port`, `ports` (array|string)  
//   One or multiple ports, used to build or enrich the 'servers' option.
// * `randdir`   
//   Directory where to write temporary file used internally to triger a 
// * `server`, `servers` (array|object|string)  
//   One or multiple servers, string must be in the form of "{host}:{port}",
//   object must have the properties "host" and "port".
// * `timeout` (number)   
//   Maximum time in millisecond to wait until this function is considered to have failed.

// Status is set to "true" if the first connection attempt was a failure and the 
// connection finaly succeeded.

// ## TODO

// The `server` and `servers` options shall be renamed `address` and `addresses`.

// ## Examples

// Wait for two domains on the same port.

// ```js
// require('nikita')
// .wait_connect({
//   hosts: [ '1.domain.com', '2.domain.com' ],
//   port: 80
// }, function(err, {status}){
//   // Servers listening on port 80
// })
// ```

// Wait for one domain on two diffents ports.

// ```js
// require('nikita')
// .wait_connect({
//   host: 'my.domain.com',
//   ports: [80, 443]
// }, function(err, {status}){
//   // Server listening on ports 80 and 443
// })
// ```

// Wait for two domains on diffents ports.

// ```js
// require('nikita')
// .wait_connect({
//   servers: [
//     {host: '1.domain.com', port: 80},
//     {host: '2.domain.com', port: 443}
//   ]
// }, function(err, {status}){
//   // Servers listening
// })
// ```

// ## Source Code
var array;

module.exports = function({options}) {
  var extract_servers, host, i, j, k, len, len1, port, quorum_target, ref, ref1, ref2, server, servers;
  this.log({
    message: "Entering wait for connection",
    level: 'DEBUG',
    module: 'nikita/connection/wait'
  });
  extract_servers = function(options) {
    var host, hosts, i, j, k, l, len, len1, len2, len3, m, port, ports, ref, ref1, ref2, ref3, servers;
    if ((options.port || options.ports) && !options.host) {
      throw Error(`Invalid host: ${options.host}`);
    }
    if ((options.host || options.hosts) && !options.port) {
      throw Error(`Invalid port: ${options.port}`);
    }
    ref = ['host', 'hosts'];
    for (i = 0, len = ref.length; i < len; i++) {
      k = ref[i];
      if (options[k] == null) {
        options[k] = [];
      }
      if ((ref1 = typeof options[k]) !== 'string' && ref1 !== 'object') {
        throw Error(`Invalid option '${options[k]}'`);
      }
      if (!Array.isArray(options[k])) {
        options[k] = [options[k]];
      }
    }
    hosts = [...options.host, ...options.hosts];
    ref2 = ['port', 'ports'];
    for (j = 0, len1 = ref2.length; j < len1; j++) {
      k = ref2[j];
      if (options[k] == null) {
        options[k] = [];
      }
      if ((ref3 = typeof options[k]) !== 'string' && ref3 !== 'number' && ref3 !== 'object') {
        throw Error(`Invalid option '${options[k]}'`);
      }
      if (!Array.isArray(options[k])) {
        options[k] = [options[k]];
      }
    }
    ports = [...options.port, ...options.ports];
    servers = [];
    for (l = 0, len2 = hosts.length; l < len2; l++) {
      host = hosts[l];
      for (m = 0, len3 = ports.length; m < len3; m++) {
        port = ports[m];
        servers.push({
          host: host,
          port: port
        });
      }
    }
    return servers;
  };
  servers = extract_servers(options);
  ref = ['server', 'servers'];
  for (i = 0, len = ref.length; i < len; i++) {
    k = ref[i];
    if (options[k] == null) {
      options[k] = [];
    }
    if ((ref1 = typeof options[k]) !== 'string' && ref1 !== 'object') {
      throw Error(`Invalid option '${options[k]}'`);
    }
    if (typeof options[k] === 'string') {
      [host, port] = options[k].split(':');
      options[k] = {
        host: host,
        port: port
      };
    }
    if (!Array.isArray(options[k])) {
      options[k] = [options[k]];
    }
    options[k] = array.flatten(options[k]);
    ref2 = options[k];
    for (j = 0, len1 = ref2.length; j < len1; j++) {
      server = ref2[j];
      servers.push(...extract_servers(server));
    }
  }
  if (!servers.length) {
    this.log({
      message: "No connection to wait for",
      level: 'WARN',
      module: 'nikita/connection/wait'
    });
    return;
  }
  // Validate servers
  if (options.interval == null) {
    options.interval = 2000; // 2s
  }
  options.interval = Math.round(options.interval / 1000);
  quorum_target = options.quorum;
  if (quorum_target && quorum_target === true) {
    quorum_target = Math.ceil(servers.length / 2);
  } else if (quorum_target == null) {
    quorum_target = servers.length;
  }
  if (!(options.timeout > 0)) {
    // Note, the option is not tested and doesnt seem to work from a manual test
    options.timeout = 0;
  }
  options.timeout = Math.round(options.timeout / 1000);
  return this.system.execute({
    bash: true,
    cmd: `function compute_md5 {
  echo $1 | openssl md5 | sed 's/^.* \\([a-z0-9]*\\)$/\\1/g'
}
addresses=( ${servers.map(function(server) {
      return "'" + server.host + "':'" + server.port + "'";
    }).join(' ')} )
timeout=${options.timeout || ''}
md5=\`compute_md5 \${addresses[@]}\`
randdir="${options.randdir || ''}"
if [ -z $randir ]; then
  if [ -w /dev/shm ]; then
    randdir="/dev/shm/$md5"
  else
    randdir="/tmp/$md5"
  fi
fi
quorum_target=${quorum_target}
echo "[INFO] randdir is: $randdir"
mkdir -p $randdir
echo 3 > $randdir/signal
echo '' > $randdir/quorum
function remove_randdir {
  for address in "\${addresses[@]}" ; do
    host="\${address%%:*}"
    port="\${address##*:}"
    rm -f $randdir/\`compute_md5 $host:$port\`
  done
}
function check_quorum {
  quorum_current=\`wc -l < $randdir/quorum\`
  echo $quorum_current gt? $quorum_target
  if [ $quorum_current -ge $quorum_target ]; then
    echo '[INFO] Quorum is reached'
    remove_randdir
  fi
}
function check_timeout {
  local timeout=$1
  local randfile4conn=$2
  sleep $timeout
  echo "[WARN] Reach timeout"
  rm -f $randfile4conn
}
function wait_connection {
  local host=$1
  local port=$2
  local randfile4conn=$3
  local count=0
  echo "[DEBUG] Start wait for $host:$port"
  isopen="echo > '/dev/tcp/$host/$port'"
  touch "$randfile4conn"
  while [[ -f "$randfile4conn" ]] && ! \`bash -c "$isopen" 2>/dev/null\`; do
    ((count++))
    echo "[DEBUG] Connection failed to $host:$port on attempt $count" >&2
    sleep ${options.interval}
  done
  if [[ -f "$randfile4conn" ]]; then
    echo "[DEBUG] Connection ready to $host:$port"
  fi
  echo $host:$port >> $randdir/quorum
  check_quorum
  if [ "$count" -gt "0" ]; then
    echo "[WARN] Status is now active, count is $count"
    echo 0 > $randdir/signal
  fi
}
if [ ! -z "$timeout" ]; then
  host="\${address%%:*}"
  port="\${address##*:}"
  check_timeout $timeout \`compute_md5 $host:$port\` &
fi
for address in "\${addresses[@]}" ; do
  host="\${address%%:*}"
  port="\${address##*:}"
  randfile4conn=$randdir/\`compute_md5 $host:$port\`
  wait_connection $host $port $randfile4conn &
done
wait
# Clean up
signal=\`cat $randdir/signal\`
remove_randdir
echo "[INFO] Exit code is $signal"
exit $signal`,
    code_skipped: 3,
    stdin_log: false
  });
};

// ## Dependencies
array = require('../misc/array');
