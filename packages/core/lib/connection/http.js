// Generated by CoffeeScript 2.3.2
// # `nikita.connection.http`

// Perform an HTTP request. It uses internaly the curl command.

// ## Options

// * `cookies` (array)   
//   Extra cookies to include in the request when sending HTTP to a server.
// * `data` (string|any, ?optional)   
//   The request HTTP body associated with "POST" and "PUT" requests. The
//   `Accept: application/json` request header will be automatically inserted if
//   not yet present and if `data` is not a string.
// * `fail` (boolean, optional)   
//   Fail silently (no output at all) on HTTP errors.
// * `gid` (number|string, ?optional)   
//   Group name or id who owns the target file; only apply if `target` is provided.
// * `http_headers` (array)   
//   Extra  header  to include in the request when sending HTTP to a server.
// * `insecure` (boolean, optional)   
//   Allow insecure server connections when using SSL; disabled if `cacert` is provided.
// * `location` (boolean)   
//   If the server reports that the requested page has moved to a different
//   location (indicated with a Location: header and a 3XX response code), this
//   option will make curl redo the request on the new place.
// * `method` (string, optional, "GET")   
//   Specify request command (HTTP method) to use.
// * `mode` (octal mode)   
//   Permissions of the target. If specified, nikita will chmod after download.
// * `negotiate` (boolean, optional)   
//   Use HTTP Negotiate (SPNEGO) authentication.
// * `password` (string, ?optional)   
//   Password associated with the Kerberos principal, required if `principal` is provided.
// * `principal` (string, optional)   
//   Kerberos principal name if a ticket must be generated along the `negociate` option.
// * `proxy` (string)   
//   Use the specified HTTP proxy. If the port number is not specified, it is
//   assumed at port 1080. See curl(1) man page.
// * `request` (string, optional, "GET")   
//   Alias for `method` respecting the curl naming.
// * `target` (path)   
//   Write to file instead of stdout; mapped to the curl `output` argument.
// * `uid` (number|string, ?optional)   
//   User name or id who owns the target file; only apply if `target` is provided.
// * `url` (string, required)   
//   HTTP URL endpoint, must be a valid URL.

// ## Callback parameters

// * `err` (Error)   
//   Error object if any.
// * `output.data` (string)   
//   The decoded data is type is provided or detected.
// * `output.body` (string)   
//   The HTTP response body.
// * `output.headers` ([string])   
//   The HTTP response headers.
// * `output.http_version` ([string])   
//   The HTTP response http_version, eg 'HTTP/1.1'.
// * `output.status_code` (string)   
//   The HTTP response status code.
// * `output.status_message` (string)   
//   The HTTP response status message.
// * `output.type` (string)   
//   The format type if provided or detected, possible values is only "json" for now.
var string, url;

module.exports = function({options}, callback) {
  var base, cookie, err, header, output, ref, url_info, value;
  if (options.method == null) {
    options.method = options.request;
  }
  if (options.method == null) {
    options.method = 'GET';
  }
  if (!options.url) {
    throw Error(`Required Option: \`url\` is required, got ${options.url}`);
  }
  if (options.principal && !options.password) {
    throw Error("Required Option: `password` is required is principal is provided");
  }
  if (((ref = options.method) === 'POST' || ref === 'PUT') && !options.data) {
    throw Error("Required Option: `data` is required with POST and PUT requests");
  }
  if ((options.data != null) && typeof options.data !== 'string') {
    if ((base = options.http_headers)['Accept'] == null) {
      base['Accept'] = 'application/json';
    }
    options.data = JSON.stringify(options.data);
  }
  url_info = url.parse(options.url);
  if (options.http_headers == null) {
    options.http_headers = [];
  }
  if (options.cookies == null) {
    options.cookies = [];
  }
  err = null;
  output = {
    body: [],
    data: void 0,
    http_version: void 0,
    headers: {},
    status_code: void 0,
    status_message: void 0,
    type: void 0
  };
  this.system.execute({
    cmd: `${(!options.principal ? '' : ['echo', options.password, '|', 'kinit', options.principal, '>/dev/null'].join(' '))}\ncommand -v curl >/dev/null || exit 3\n${[
      'curl',
      '--include', // Include protocol headers in the output (H/F)
      '--silent', // Dont print progression to stderr
      options.fail ? '--fail' : void 0,
      !options.cacert && url_info.protocol === 'https:' ? '--insecure' : void 0,
      options.cacert ? '--cacert #{options.cacert}' : void 0,
      options.negotiate ? '--negotiate -u:' : void 0,
      options.location ? '--location' : void 0,
      ...((function() {
        var ref1,
      results;
        ref1 = options.http_headers;
        results = [];
        for (header in ref1) {
          value = ref1[header];
          results.push(`--header '${header.replace('\'',
      '\\\'')}:${value.replace('\'',
      '\\\'')}'`);
        }
        return results;
      })()),
      ...((function() {
        var j,
      len,
      ref1,
      results;
        ref1 = options.cookies;
        results = [];
        for (j = 0, len = ref1.length; j < len; j++) {
          cookie = ref1[j];
          results.push(`--cookie '${cookie.replace('\'',
      '\\\'')}'`);
        }
        return results;
      })()),
      options.target ? `-o ${options.target}` : void 0,
      options.proxy ? `-x ${options.proxy}` : void 0,
      options.method !== 'GET' ? `-X ${options.method}` : void 0,
      options.data ? `--data '${options.data.replace('\'',
      '\\\'')}'` : void 0,
      `${options.url}`
    ].join(' ')}`,
    trap: true
  }, function(_err, {code, stdout}) {
    var done_with_header, http_version, i, j, just_finished_header, len, line, name, ref1, results, status_code, status_message;
    if (_err && code === 3) {
      return err = Error("Required Dependencies: curl is required to perform HTTP requests");
    }
    if (_err) {
      return err = _err;
    }
    output.raw = stdout;
    done_with_header = false;
    ref1 = string.lines(stdout);
    results = [];
    for (i = j = 0, len = ref1.length; j < len; i = ++j) {
      line = ref1[i];
      if (output.body.length === 0 && /^HTTP\/[\d.]+ \d+/.test(line)) {
        done_with_header = false;
        output.headers = {};
        [http_version, status_code, ...status_message] = line.split(' ');
        output.http_version = http_version.substr(5);
        output.status_code = parseInt(status_code, 10);
        output.status_message = status_message.join(' ');
        just_finished_header = false;
        continue;
      } else if (line === '') {
        done_with_header = true;
        continue;
      }
      if (!done_with_header) {
        [name, ...value] = line.split(':');
        results.push(output.headers[name.trim()] = value.join(':').trim());
      } else {
        results.push(output.body.push(line));
      }
    }
    return results;
  });
  this.call({
    unless: function() {
      return !!err;
    }
  }, function() {
    this.system.chmod({
      if: options.target && options.mode,
      mode: options.mode
    });
    return this.system.chown({
      if: options.target && (options.uid != null) || (options.gid != null),
      target: options.target,
      uid: options.uid,
      gid: options.gid
    });
  });
  return this.call(function() {
    if (err) {
      return callback(err);
    }
    if (/^application\/json(;|$)/.test(output.headers['Content-Type'])) {
      output.type = 'json';
    }
    output.body = output.body.join('');
    switch (output.type) {
      case 'json':
        output.data = JSON.parse(output.body);
    }
    return callback(null, output);
  });
};

// ## Dependencies
url = require('url');

string = require('../misc/string');
