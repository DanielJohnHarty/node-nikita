// Generated by CoffeeScript 2.4.1
// # `nikita.log.cli`

// Write log to the host filesystem in a user provided format.

// ## Options

// * `depth_max` (number|boolean)    
// * `divider` (string)    
// * `end` (boolean)    
// * `enabled` (boolean)    
// * `host` (string)    
// * `pad` (string)    
// * `time` (boolean)    
//   Print time.   
// * `separator` (string|object)    
// * `stream` (stream.Writable)  

// Global options can be alternatively set with the "log_cli" property.

// ## Exemple with the depth_max option

// ```js
// require('nikita')(
//   log: { cli: { colors: true } }
// )
// .log.cli({ depth_max: 2 })
// .call({
//   header: 'Print my header'
// }, function(){
//   @call({
//     header: 'Print sub header'
//   }, function(){
//     @call({
//       header: 'Header not printed'
//     }, function(){
//       // do sth
//     });
//   });
// });
// ```

// ## Exemple with global options

// ```js
// require('nikita')(
//   log_cli: { colors: true }
// )
// .log.cli()
// .call({
//   header: 'Print my header'
// }, function(){
//   // do sth
// });
// ```

// ## Source Code
var colors, pad, stream, string;

module.exports = {
  ssh: false,
  handler: function({metadata, options}) {
    var base, base1, base2, format_line, ids, ssh;
    this.log({
      message: "Entering log.cli",
      level: 'DEBUG',
      module: 'nikita/lib/log/cli'
    });
    // SSH connection
    ssh = this.ssh(options.ssh);
    if (options.log_cli) {
      // Obtains options from "log_cli" namespace
      options = {...options.log_cli, ...options};
    }
    if (metadata.argument != null) {
      // Normalize
      if (options.enabled == null) {
        options.enabled = metadata.argument;
      }
    }
    if (options.enabled == null) {
      options.enabled = true;
    }
    if (options.stream == null) {
      options.stream = process.stderr;
    }
    if (options.end == null) {
      options.end = false;
    }
    if (options.divider == null) {
      options.divider = ' : ';
    }
    if (options.depth_max == null) {
      options.depth_max = false;
    }
    if (options.pad == null) {
      options.pad = {};
    }
    if (options.time == null) {
      options.time = true;
    }
    if (typeof options.separator === 'string') {
      options.separator = {
        host: options.separator,
        header: options.separator
      };
    }
    if (options.separator == null) {
      options.separator = {};
    }
    if ((base = options.separator).host == null) {
      base.host = options.pad.host == null ? '   ' : ' ';
    }
    if ((base1 = options.separator).header == null) {
      base1.header = options.pad.header == null ? '   ' : ' ';
    }
    if ((base2 = options.separator).time == null) {
      base2.time = options.pad.time == null ? '  ' : ' ';
    }
    if (options.host == null) {
      options.host = ssh ? ssh.config.host : 'localhost';
    }
    if (options.colors == null) {
      options.colors = process.stdout.isTTY;
    }
    if (options.colors === true) {
      options.colors = {
        status_true: colors.green,
        status_false: colors.cyan.dim,
        status_error: colors.red
      };
    }
    // Events
    ids = {};
    format_line = function({host, header, status, time}) {
      if (options.pad.host) {
        host = pad(host, options.pad.host);
      }
      if (options.pad.header) {
        header = pad(header, options.pad.header);
      }
      if (options.pad.time) {
        time = pad(time, options.pad.time);
      }
      return [host, options.separator.host, header, options.separator.header, status, options.time ? options.separator.time : '', time].join('');
    };
    return this.call(options, stream, {
      serializer: {
        'diff': null,
        'end': function() {
          var color, line;
          color = options.colors ? options.colors.status_true : false;
          line = format_line({
            host: options.host,
            header: '',
            status: '♥',
            time: ''
          });
          if (color) {
            line = color(line);
          }
          return line + '\n';
        },
        'error': function(err) {
          var color, line;
          color = options.colors ? options.colors.status_error : false;
          line = format_line({
            host: options.host,
            header: err.message,
            status: '✘',
            time: ''
          });
          if (color) {
            line = color(line);
          }
          return line + '\n';
        },
        'header': function(log) {
          if (!options.enabled) {
            return;
          }
          if (options.depth_max && options.depth_max < log.metadata.headers.length) {
            return;
          }
          ids[log.index] = log;
          return null;
        },
        'lifecycle': function(log) {
          var ref;
          if (!ids[log.index]) {
            return;
          }
          if ((ref = log.message) === 'conditions_failed' || ref === 'disabled_true') {
            ids[log.index].disabled = true;
          }
          return null;
        },
        'handled': function(log) {
          var color, line, ref, ref1, ref2, status, time;
          status = ((ref = log.parent) != null ? ref.error : void 0) ? '✘' : log.metadata.status && !((ref1 = log.parent) != null ? ref1.metadata.shy : void 0) ? '✔' : '-';
          color = false;
          if (options.colors) {
            color = ((ref2 = log.parent) != null ? ref2.error : void 0) ? options.colors.status_error : log.metadata.status ? options.colors.status_true : options.colors.status_false;
          }
          log = ids[log.index];
          if (!log) {
            return null;
          }
          if (log.disabled) {
            return null;
          }
          delete ids[log.index];
          time = options.time ? string.print_time(Date.now() - log.time) : '';
          line = format_line({
            host: options.host,
            header: log.metadata.headers.join(options.divider),
            status: status,
            time: time
          });
          if (color) {
            line = color(line);
          }
          return line + '\n';
        },
        'stdin': null,
        'stderr': null,
        'stdout': null,
        'text': null
      }
    });
  }
};

// ## Dependencies
colors = require('colors/safe');

pad = require('pad');

stream = require('./stream');

string = require('../misc/string');
