// Generated by CoffeeScript 2.5.1
// # `nikita.log`

// Send a log message.

// ## Options

// * `level` (string)   
//   Set the message log level, recommended values are 'DEBUG', 'INFO', 'WARN' and
//   'ERROR'.
// * `module` (string)   
//   The module name from where the message was issued.
// * `time` (integer)   
//   The timestamp associated with the message, default to the current timestamp
//   when the log action is called.

// ## Source Code
var path, stackTrace;

module.exports = {
  ssh: false,
  get: true,
  cascade: {
    action: false,
    cascade: false,
    get: false,
    retry: false,
    ssh: false,
    shy: true
  },
  handler: function({options, metadata, parent}) {
    var file, frame, line, log, msg, ref, ref1, ref2, ref3, ref4;
    // Options
    log = {};
    log.message = metadata.argument || options.message; //or parent?.metadata.argument
    log.level = options.level || 'INFO';
    if (log.time == null) {
      log.time = Date.now();
    }
    if (log.index == null) {
      log.index = options.index;
    }
    log.module = options.module;
    log.type = options.type || 'text';
    log.depth = metadata.depth - 1;
    log.metadata = metadata;
    log.options = options;
    log.parent = parent;
    frame = stackTrace.get()[1];
    file = path.basename(frame.getFileName());
    line = frame.getLineNumber();
    log.file = file;
    log.line = line;
    if (parent != null ? parent.metadata.debug : void 0) {
      if ((ref = log.type) === 'text' || ref === 'stdin' || ref === 'stdout_stream' || ref === 'stderr_stream') {
        if (!(((ref1 = log.type) === 'stdout_stream' || ref1 === 'stderr_stream') && log.message === null)) {
          msg = typeof log.message === 'string' ? log.message.trim() : typeof log.message === 'number' ? log.message : ((ref2 = log.message) != null ? ref2.toString : void 0) != null ? log.message.toString().trim() : JSON.stringify(log.message);
          msg = `[${log.depth}.${log.level} ${log.module}] ${msg}`;
          msg = (function() {
            switch (log.type) {
              case 'stdin':
                return `\x1b[33m${msg}\x1b[39m`;
              case 'stdout_stream':
                return `\x1b[36m${msg}\x1b[39m`;
              case 'stderr_stream':
                return `\x1b[35m${msg}\x1b[39m`;
              default:
                return `\x1b[32m${msg}\x1b[39m`;
            }
          })();
          if ((parent != null ? parent.metadata.debug : void 0) === 'stdout') {
            process.stdout.write(`${msg}\n`);
          } else {
            process.stderr.write(`${msg}\n`);
          }
        }
      }
    }
    if (typeof metadata.log === 'function') {
      if (parent != null) {
        if ((ref3 = parent.metadata) != null) {
          ref3.log(log);
        }
      }
    } else {
      if ((parent != null ? (ref4 = parent.metadata) != null ? ref4.log : void 0 : void 0) === false) {
        return;
      }
    }
    return this.emit(log.type, log); //unless log_disabled
  }
};


// ## Dependencies
path = require('path');

stackTrace = require('stack-trace'); // dec 2019, was required at runtime, dont know why
