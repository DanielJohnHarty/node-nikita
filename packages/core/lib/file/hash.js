// Generated by CoffeeScript 2.4.1
// # `nikita.file.hash`

// Retrieve the hash of a file or a directory in hexadecimal 
// form.

// If the target is a directory, the returned hash 
// is the sum of all the hashs of the files it recursively 
// contains. The default algorithm to compute the hash is md5.

// If the target is a link, the returned hash is of the linked file.

// It is possible to use to action to assert the target file by passing a `hash`
// used for comparaison.

// ## Options

// * `algo` (string)   
//   Any algorythm supported by `openssl`; default to "md5".
// * `hash` (string)   
//   Expected hash to validate.
// * `target` (string)   
//   The file or directory to compute the hash from.

// ## Callback information

// * `hash`   
//   The hash of the file or directory identified by the "target" option.
var crypto, misc, string;

module.exports = {
  shy: true,
  handler: function({metadata, options}, callback) {
    var info;
    this.log({
      message: "Entering file.hash",
      level: 'DEBUG',
      module: 'nikita/lib/file/hash'
    });
    if (options.algo == null) {
      options.algo = 'md5';
    }
    if (metadata.argument != null) {
      options.target = metadata.argument;
    }
    if (!options.target) {
      throw Error(`Required Option: target, got ${JSON.stringify(options.target)}`);
    }
    info = {};
    this.fs.stat({
      unless: options.stats,
      target: options.target
    }, function(err, {stats}) {
      if (err) {
        throw err;
      }
      options.stats = stats;
      if (!(misc.stats.isFile(stats.mode) || misc.stats.isDirectory(stats.mode))) {
        throw Error(`Unsupported File Type: expect "File" or "Directory", got ${misc.stats.type(stats.mode)} for mode ${stats.mode.toString(8)}`);
      }
    });
    // Target is a directory
    this.file.glob({
      if: function() {
        return misc.stats.isDirectory(options.stats.mode);
      },
      target: `${options.target}/**`,
      dot: true
    }, function(err, {status, files}) {
      if (!status) {
        return;
      }
      if (err) {
        throw err;
      }
      return this.system.execute({
        cmd: [
          'command -v openssl >/dev/null || exit 2',
          ...files.map(function(file) {
            return `[ -f ${file} ] && openssl dgst -${options.algo} ${file} | sed 's/^.* \\([a-z0-9]*\\)$/\\1/g'`;
          }),
          'exit 0'
        ].join('\n'),
        trim: true
      }, function(err, {stdout}) {
        var hashs;
        if ((err != null ? err.code : void 0) === 2) {
          throw Error("Command does not exist: openssl");
        }
        if (err) {
          throw err;
        }
        hashs = string.lines(stdout).filter(function(line) {
          return /\w+/.test(line);
        }).sort();
        return info.hash = hashs.length === 0 ? crypto.createHash(options.algo).update('').digest('hex') : hashs.length === 1 ? hashs[0] : crypto.createHash(options.algo).update(hashs.join('')).digest('hex');
      });
    });
    // Target is a file
    this.system.execute({
      if: function() {
        return misc.stats.isFile(options.stats.mode);
      },
      cmd: `command -v openssl >/dev/null || exit 2\nopenssl dgst -${options.algo} ${options.target} | sed 's/^.* \\([a-z0-9]*\\)$/\\1/g'`,
      trim: true
    }, function(err, {status, stdout}) {
      if ((err != null ? err.code : void 0) === 2) {
        throw Error("Command does not exist: openssl");
      }
      if (err) {
        throw err;
      }
      if (!status) {
        return;
      }
      return info.hash = stdout;
    });
    this.call({
      if: options.hash
    }, function() {
      if (options.hash !== stdout) {
        throw Error(`Unexpected Hash, got ${JSON.stringify(stdout)} but exepected ${JSON.stringify(options.hash)}`);
      }
    });
    return this.next(function(err) {
      if (!err) {
        info.status = true;
      }
      return callback(err, info);
    });
  }
};

// ## Dependencies
crypto = require('crypto');

misc = require('../misc');

string = require('../misc/string');
