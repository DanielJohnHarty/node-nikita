// Generated by CoffeeScript 2.4.1
// # `nikita.file.glob`

// Search for files in a directory hierarchy.

// ## Implementation

// The action use the POXIX `find` command to fetch all files and filter the
// paths locally using the Minimatch package.

// ## Options

// * `dot` (string)   
//   Minimatch option to handle files starting with a ".".
// * `target` (string)   
//   The file or directory to compute the hash from.
// * `minimatch` (object)   
//   Pass any options to Minimatch.

// ## Callback information

// * `hash`   
//   The hash of the file or directory identified by the "target" option.
var Minimatch, getprefix, path, string;

module.exports = {
  shy: true,
  handler: function({options}, callback) {
    var base, info, minimatch, s;
    this.log({
      message: "Entering file.glob",
      level: 'DEBUG',
      module: 'nikita/lib/file/hash'
    });
    if (options.argument != null) {
      options.target = options.argument;
    }
    if (!options.target) {
      throw Error(`Required Option: target, got ${JSON.stringify(options.target)}`);
    }
    if (options.minimatch == null) {
      options.minimatch = {};
    }
    if (options.dot != null) {
      if ((base = options.minimatch).dot == null) {
        base.dot = options.dot;
      }
    }
    info = {};
    options.target = path.normalize(options.target);
    minimatch = new Minimatch(options.target, options.minimatch);
    this.system.execute({
      cmd: [
        'find',
        ...((function() {
          var i,
        len,
        ref,
        results;
          ref = minimatch.set;
          results = [];
          for (i = 0, len = ref.length; i < len; i++) {
            s = ref[i];
            results.push(getprefix(s));
          }
          return results;
        })())
      ].join(' '),
      trim: true,
      relax: true
    }, function(err, {stdout}) {
      var files, i, len, n, prefix, ref;
      // `find` return exit code 1 when no match is found,
      // we treat this scenario as an empty output
      files = string.lines(stdout).filter(function(file) {
        return minimatch.match(file);
      });
      ref = minimatch.set;
      for (i = 0, len = ref.length; i < len; i++) {
        s = ref[i];
        n = 0;
        while (typeof s[n] === "string") {
          n++;
        }
        if (s[n] === Minimatch.GLOBSTAR) {
          prefix = getprefix(s);
          if (prefix) {
            files.unshift(prefix);
          }
        }
      }
      info.status = true;
      return info.files = files;
    });
    return this.next(function(err) {
      return callback(err, info);
    });
  }
};

// ## Dependencies
path = require('path');

({Minimatch} = require('minimatch'));

string = require('../misc/string');

// ## Utility
getprefix = function(pattern) {
  var n, prefix;
  prefix = null;
  n = 0;
  while (typeof pattern[n] === "string") {
    n++;
  }
  // now n is the index of the first one that is *not* a string.
  // see if there's anything else
  switch (n) {
    // if not, then this is rather simple
    case pattern.length:
      prefix = pattern.join('/');
      return prefix;
    case 0:
      // pattern *starts* with some non-trivial item.
      // going to readdir(cwd), but not include the prefix in matches.
      return null;
    default:
      // pattern has some string bits in the front.
      // whatever it starts with, whether that's "absolute" like /foo/bar,
      // or "relative" like "../baz"
      prefix = pattern.slice(0, n);
      prefix = prefix.join('/');
      return prefix;
  }
};
