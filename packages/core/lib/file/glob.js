// Generated by CoffeeScript 2.3.2
// # `nikita.file.glob`

// Search for files in a directory hierarchy.

// ## Implementation

// The action use the POXIX `find` command to fetch all files and filter the
// paths locally using the Minimatch package.

// ## Options

// * `dot` (string)   
//   Minimatch option to handle files starting with a ".".
// * `target` (string)   
//   The file or directory to compute the hash from.
// * `minimatch` (object)   
//   Pass any options to Minimatch.

// ## Callback information

// * `hash`   
//   The hash of the file or directory identified by the "target" option.
var Minimatch, getprefix, path, string;

module.exports = {
  shy: true,
  handler: function({options}, callback) {
    var base, cmd, i, info, len, minimatch, prefix, ref, s;
    this.log({
      message: "Entering file.glob",
      level: 'DEBUG',
      module: 'nikita/lib/file/hash'
    });
    if (options.argument != null) {
      options.target = options.argument;
    }
    if (!options.target) {
      throw Error(`Required Option: target, got ${JSON.stringify(options.target)}`);
    }
    if (options.minimatch == null) {
      options.minimatch = {};
    }
    if (options.dot != null) {
      if ((base = options.minimatch).dot == null) {
        base.dot = options.dot;
      }
    }
    info = {};
    options.target = path.normalize(options.target);
    minimatch = new Minimatch(options.target, options.minimatch);
    cmd = "find";
    ref = minimatch.set;
    for (i = 0, len = ref.length; i < len; i++) {
      s = ref[i];
      prefix = getprefix(s);
      cmd += ` ${prefix}`;
    }
    this.system.execute({
      cmd: cmd,
      trim: true,
      relax: true
    }, function(err, {stdout}) {
      var files, j, len1, n, ref1;
      // `find` return exit code 1 when no match is found,
      // we treat this scenario as an empty output
      files = string.lines(stdout);
      files = files.filter(function(file) {
        return minimatch.match(file);
      });
      ref1 = minimatch.set;
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        s = ref1[j];
        n = 0;
        while (typeof s[n] === "string") {
          n++;
        }
        if (s[n] === Minimatch.GLOBSTAR) {
          prefix = getprefix(s);
          if (prefix) {
            files.unshift(prefix);
          }
        }
      }
      info.status = true;
      return info.files = files;
    });
    return this.next(function(err) {
      return callback(err, info);
    });
  }
};

// ## Dependencies
path = require('path');

({Minimatch} = require('minimatch'));

string = require('../misc/string');

// ## Utility
getprefix = function(pattern) {
  var n, prefix;
  prefix = null;
  n = 0;
  while (typeof pattern[n] === "string") {
    n++;
  }
  // now n is the index of the first one that is *not* a string.
  // see if there's anything else
  switch (n) {
    // if not, then this is rather simple
    case pattern.length:
      prefix = pattern.join('/');
      return prefix;
    case 0:
      // pattern *starts* with some non-trivial item.
      // going to readdir(cwd), but not include the prefix in matches.
      return null;
    default:
      // pattern has some string bits in the front.
      // whatever it starts with, whether that's "absolute" like /foo/bar,
      // or "relative" like "../baz"
      prefix = pattern.slice(0, n);
      prefix = prefix.join('/');
      return prefix;
  }
};
