// Generated by CoffeeScript 2.5.1
// # `nikita.lxd.cluster`

// Attach an existing network to a container.

// ## Options

// * `networks` (required, object)   
//   Create or update network configurations.
// * `containers` (required, object)   
//   Initialize a Linux Container with given image name, container name and options.

// # Cluster

// ## Exemple

// ```yaml
// networks:
//   lxdbr0public:
//     ipv4.address: 172.16.0.1/24
//     ipv4.nat: true
//     ipv6.address: none
//   lxdbr1private:
//     ipv4.address: 10.10.10.1/24
//     ipv4.nat: true
//     ipv6.address: none
//     dns.domain: nikita
// containers:
//   nikita
//     image: images:centos/7
//     config:
//       environment:
//         MY_VAR: 'my value'
//     disk:
//       nikitadir:
//         source: /nikita
//         path: /nikita
//     nic:
//       eth0:
//         config:
//           container: eth0
//           nictype: bridged
//           parent: lxdbr0public
//       eth1:
//         config:
//           container: eth1
//           nictype: bridged
//           parent: lxdbr1private
//           ip: '10.10.10.10'
//           netmask: '255.255.255.192'
//     proxy:
//       ssh:
//         listen: tcp:0.0.0.0:2200
//         connect: tcp:127.0.0.1:22
//     ssh:
//       enabled: true
//       #id_rsa: assets/id_rsa
//     user:
//       nikita:
//         sudo: true
//         authorized_keys: assets/id_rsa.pub
//     prevision: path/to/action
//     provision: path/to/action
//     provision_container: path/to/action
// ```
var validate_container_name;

module.exports = function({options}) {
  var config, container, network, ref, ref1, ref2, results;
  if (options.networks == null) {
    options.networks = {};
  }
  if (options.proxy == null) {
    options.proxy = {};
  }
  if (options.user == null) {
    options.user = {};
  }
  this.call({
    if: !!options.prevision
  }, options, options.prevision);
  ref = options.networks;
  for (network in ref) {
    config = ref[network];
    this.lxd.network({
      header: 'Bridge',
      network: network,
      config: config
    });
  }
  ref1 = options.containers;
  for (container in ref1) {
    config = ref1[container];
    this.call({
      header: `Container ${container}`,
      container: container,
      config: config
    }, function({
        options: {container, config}
      }) {
      var configdisk, confignic, configproxy, configuser, device, ref2, ref3, ref4, ref5, results, ssh, user;
      validate_container_name(container);
      if (config.config == null) {
        config.config = {};
      }
      ssh = config.ssh || {};
      if (ssh.enabled == null) {
        ssh.enabled = false;
      }
      this.lxd.init({
        header: 'Init',
        container: container,
        image: config.image
      });
      this.lxd.config.set({
        header: 'Config',
        container: container,
        // image: config.image
        config: config.config
      });
      ref2 = config.disk;
      for (device in ref2) {
        configdisk = ref2[device];
        this.lxd.config.device({
          header: `Device ${device} disk`,
          container: container,
          device: device,
          type: 'disk',
          config: configdisk
        });
      }
      ref3 = config.nic;
      for (device in ref3) {
        confignic = ref3[device];
        if (confignic.name == null) {
          confignic.name = device;
        }
        if (confignic.netmask == null) {
          confignic.netmask = '255.255.255.0';
        }
        if (!confignic.config.parent) {
          throw Error(`Required Property: nic.${device}.parent`);
        }
        this.lxd.config.device({
          header: `Device ${device} nic`,
          container: container,
          device: device,
          type: 'nic',
          config: confignic.config
        });
        this.lxd.file.push({
          header: `ifcfg ${confignic.name}`,
          if: !!confignic.ip,
          container: container,
          target: `/etc/sysconfig/network-scripts/ifcfg-${confignic.name}`,
          content: `NM_CONTROLLED=yes
BOOTPROTO=none
ONBOOT=yes
IPADDR=${confignic.ip}
NETMASK=${confignic.netmask}
DEVICE=${confignic.name}
PEERDNS=no`
        });
      }
      ref4 = config.proxy;
      for (device in ref4) {
        configproxy = ref4[device];
        // todo: add host detection and port forwarding to VirtualBox
        // VBoxManage controlvm 'lxd' natpf1 'ipa_ui,tcp,0.0.0.0,2443,,2443'
        this.lxd.config.device({
          header: `Device ${device} proxy`,
          container: container,
          device: device,
          type: 'proxy',
          config: configproxy
        });
      }
      this.lxd.start({
        header: 'Start',
        container: container
      });
      this.wait.execute({
        cmd: `lxc info ${container} | grep 'Status: Running'`
      });
      this.connection.wait({
        host: 'linuxfoundation.org',
        port: 80
      });
      // timeout: 5000
      // Not sure why openssl is required
      this.lxd.exec({
        header: 'OpenSSL',
        container: container,
        cmd: `#yum update -y
yum install -y openssl
command -v openssl`,
        retry: 10,
        sleep: 5000,
        trap: true
      });
      this.lxd.exec({
        header: 'SSH',
        if: ssh.enabled,
        container: container,
        cmd: `# systemctl status sshd
# yum install -y openssh-server
# systemctl start sshd
# systemctl enable sshd
systemctl status sshd && exit 42
if command -v yum >/dev/null 2>&1; then
  yum -y install openssh-server
elif command -v apt-get >/dev/null 2>&1; then
  apt-get -y install openssh-server
else
  echo "Unsupported Package Manager" >&2 && exit 2
fi
systemctl status sshd && exit 42
systemctl start sshd
systemctl enable sshd`,
        trap: true,
        code_skipped: 42
      });
      ref5 = config.user;
      results = [];
      for (user in ref5) {
        configuser = ref5[user];
        results.push(this.call({
          header: `User ${user}`,
          user: user,
          configuser: configuser
        }, function({options = {user, configuser}}) {
          this.lxd.exec({
            header: 'Create',
            container: container,
            cmd: `id ${user} && exit 42
useradd --create-home --system ${user}
mkdir -p /home/${user}/.ssh
chown ${user}.${user} /home/${user}/.ssh
chmod 700 /home/${user}/.ssh`,
            trap: true,
            code_skipped: 42
          });
          this.lxd.exec({
            header: 'Sudo',
            if: configuser.sudo,
            container: container,
            cmd: `yum install -y sudo
command -v sudo
cat /etc/sudoers | grep "${user}" && exit 42
echo "${user} ALL=(ALL) NOPASSWD: ALL" >> /etc/sudoers`,
            trap: true,
            code_skipped: 42
          });
          return this.lxd.file.push({
            header: 'Authorize',
            if: configuser.authorized_keys,
            container: container,
            gid: `${user}`,
            uid: `${user}`,
            mode: 600,
            source: `${configuser.authorized_keys}`,
            target: `/home/${user}/.ssh/authorized_keys`
          });
        }));
      }
      return results;
    });
  }
  this.call({
    if: !!options.provision
  }, options, options.provision);
  ref2 = options.containers;
  results = [];
  for (container in ref2) {
    config = ref2[container];
    results.push(this.call({
      if: !!options.provision_container
    }, {
      container: container,
      config: config
    }, options.provision_container));
  }
  return results;
};

// ## Dependencies
validate_container_name = require('../misc/validate_container_name');
