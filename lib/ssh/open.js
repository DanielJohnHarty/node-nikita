// Generated by CoffeeScript 2.3.0
// # `nikita.ssh.open(options, [callback])`

// Initialize an SSH connection.

// ## Options

// Takes the same options as the ssh2 module in an underscore form.

// * `cmd` (string)   
//   Command used to become the root user on the remote server, default to "su -".   
// * `private_key` (string)   
//   Private key for Ryba, optional, default to the value defined by
//   "bootstrap.private_key_location".   
// * `private_key_path` (string)   
//   Path where to read the private key for Ryba, default to "~/.ssh/id_rsa".   
// * `public_key` (string)   
//   Public key associated with the private key.   
// * `password` (string)   
//   Password of the user with super user permissions, required if current user 
//   running masson doesnt yet have remote access as root.   
// * `username` (string)   
//   Username of the user with super user permissions, required if current user 
//   running masson doesnt yet have remote access as root.  
// * `host` (string)   
//   Hostname or IP address of the remove server.   
// * `ip` (string)   
//   IP address of the remove server, used if "host" option isn't defined.   
// * `host` (string)   
//   Port of the remove server, default to 22.   
// * `root` (object)    
//   Options passed to `nikita.ssh.root` to enable password-less root login.   

// ## Source code
var connect, fs, misc;

module.exports = {
  handler: function(options) {
    var base, base1, k, ref, ref1, v;
    options.log({
      message: "Entering ssh.open",
      level: 'DEBUG',
      module: 'nikita/lib/ssh/open'
    });
    ref = options.ssh || {};
    for (k in ref) {
      v = ref[k];
      // SSH options namespace
      // options.ssh ?= {}
      if (options[k] == null) {
        options[k] = v;
      }
    }
    if (options.username == null) {
      options.username = 'root';
    }
    if (options.host == null) {
      options.host = options.ip;
    }
    if (options.port == null) {
      options.port = 22;
    }
    if (options.private_key == null) {
      options.private_key = null;
    }
    if (options.private_key_path == null) {
      options.private_key_path = '~/.ssh/id_rsa';
    }
    // options.public_key ?= []
    // options.public_key = [options.public_key] if typeof options.public_key is 'string'
    if (options.root == null) {
      options.root = {};
    }
    if ((base = options.root).host == null) {
      base.host = options.ip || options.host;
    }
    if ((base1 = options.root).port == null) {
      base1.port = options.port;
    }
    // Check status
    if (((ref1 = this.store['nikita:ssh:connection']) != null ? ref1.config : void 0) && this.store['nikita:ssh:connection'].config.host === options.host && this.store['nikita:ssh:connection'].config.port === options.port && this.store['nikita:ssh:connection'].config.username === options.username) {
      return;
    }
    // Read private key if option is a path
    this.call({
      unless: options.private_key
    }, function(_, callback) {
      options.log({
        message: `Read Private Key from: ${options.private_key_path}`,
        level: 'DEBUG',
        module: 'nikita/lib/ssh/open'
      });
      return misc.path.normalize(options.private_key_path, (location) => {
        return fs.readFile(location, 'ascii', (err, content) => {
          if (err && err.code === 'ENOENT') {
            return callback(Error(`Private key doesnt exists: ${JSON.stringify(location)}`));
          }
          if (err) {
            return callback(err);
          }
          options.private_key = content;
          return callback();
        });
      });
    });
    // Establish connection
    this.call({
      relax: true
    }, function(_, callback) {
      options.log({
        message: `Read Private Key: ${JSON.stringify(options.private_key_path)}`,
        level: 'DEBUG',
        module: 'nikita/lib/ssh/open'
      });
      return connect(options, (err, ssh) => {
        options.log(!err ? {
          message: "Connection is established",
          level: 'INFO',
          module: 'nikita/lib/ssh/open'
        } : {
          message: "Connection failed",
          level: 'WARN',
          module: 'nikita/lib/ssh/open'
        });
        if (!err) {
          this.store['nikita:ssh:connection'] = ssh;
        }
        return callback(err, !!ssh);
      });
    }, function(err, status) {
      if (!err) {
        return this.end();
      }
    });
    // Enable root access
    this.call({
      if: options.root.username
    }, function() {
      options.log({
        message: "Bootstrap Root Access",
        level: 'INFO',
        module: 'nikita/lib/ssh/open'
      });
      if (options.public_key) {
        console.log('Deprecated Options: public_key');
      }
      // @ssh.root public_key: options.public_key, options.root
      return this.ssh.root(options.root);
    });
    return this.call({
      retry: 3
    }, function(_, callback) {
      options.log({
        message: "Establish Connection: attempt after enabling root access",
        level: 'DEBUG',
        module: 'nikita/lib/ssh/open'
      });
      return connect(options, (err, ssh) => {
        if (!err) {
          this.store['nikita:ssh:connection'] = ssh;
        }
        return callback(err);
      });
    });
  }
};

// ## Dependencies
fs = require('fs');

misc = require('../misc');

connect = require('ssh2-connect');
