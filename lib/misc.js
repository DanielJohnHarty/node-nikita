// Generated by CoffeeScript 1.4.0
var crypto, each, fs, misc, path, _ref;

crypto = require('crypto');

fs = require('fs');

path = require('path');

if ((_ref = fs.exists) == null) {
  fs.exists = path.exists;
}

each = require('each');

module.exports = misc = {
  file: {
    /*
        `hash(file, callback)`
        ----------------------
        Output the message digest of a supplied file or files in hexadecimal
        form. For now, the message digests is limited to md5 digest. 
        Throw an error if file does not exist or is a directory.
    */

    hash: function(file, digest, callback) {
      var shasum;
      if (arguments.length === 2) {
        callback = digest;
        digest = 'md5';
      }
      shasum = crypto.createHash('md5');
      return fs.ReadStream(file).on('data', function(data) {
        return shasum.update(data);
      }).on('error', function(err) {
        if (err.code === 'ENOENT') {
          err.message = "Does not exist: " + file;
        }
        if (err.code === 'EISDIR') {
          err.message = "Is a directory: " + file;
        }
        return callback(err);
      }).on('end', function() {
        return callback(null, shasum.digest('hex'));
      });
    },
    /*
        `compare(files, callback)`
        --------------------------
        Compare the hash of multiple file. Return the file md5 
        if the file are the same or false otherwise.
    */

    compare: function(files, callback) {
      var result;
      if (files.length < 2) {
        return callback(new Error('Minimum of 2 files'));
      }
      result = null;
      return each(files).parallel(true).on('item', function(file, next) {
        return misc.file.hash(file, function(err, md5) {
          if (err) {
            return next(err);
          }
          if (result === null) {
            result = md5;
          } else if (result !== md5) {
            result = false;
          }
          return next();
        });
      }).on('error', function(err) {
        return callback(err);
      }).on('end', function() {
        return callback(null, result);
      });
    }
  },
  /*
    `isPortOpen(port, host, callback)`: Check if a port is already open
  */

  isPortOpen: function(port, host, callback) {
    if (arguments.length === 2) {
      callback = host;
      host = '127.0.0.1';
    }
    return exec("nc " + host + " " + port + " < /dev/null", function(err, stdout, stderr) {
      if (!err) {
        return callback(null, true);
      }
      if (err.code === 1) {
        return callback(null, false);
      }
      return callback(err);
    });
  },
  /*
    `merge([inverse], obj1, obj2, ...]`: Recursively merge objects
    --------------------------------------------------------------
    On matching keys, the last object take precedence over previous ones 
    unless the inverse arguments is provided as true. Only objects are 
    merge, arrays are overwritten.
  
    Enrich an existing object with a second one:
      obj1 = { a_key: 'a value', b_key: 'b value'}
      obj2 = { b_key: 'new b value'}
      result = misc.merge obj1, obj2
      assert.eql result, obj1
      assert.eql obj1.b_key, 'new b value'
  
    Create a new object from two objects:
      obj1 = { a_key: 'a value', b_key: 'b value'}
      obj2 = { b_key: 'new b value'}
      result = misc.merge {}, obj1, obj2
      assert.eql result.b_key, 'new b value'
  
    Using inverse:
      obj1 = { b_key: 'b value'}
      obj2 = { a_key: 'a value', b_key: 'new b value'}
      misc.merge true, obj1, obj2
      assert.eql obj1.a_key, 'a value'
      assert.eql obj1.b_key, 'b value'
  */

  merge: function() {
    var clone, copy, from, i, inverse, name, options, src, target, to, _i;
    target = arguments[0];
    from = 1;
    to = arguments.length;
    if (typeof target === 'boolean') {
      inverse = !!target;
      target = arguments[1];
      from = 2;
    }
    if (typeof target !== "object" && typeof target !== 'function') {
      target = {};
    }
    for (i = _i = from; from <= to ? _i < to : _i > to; i = from <= to ? ++_i : --_i) {
      if ((options = arguments[i]) !== null) {
        for (name in options) {
          src = target[name];
          copy = options[name];
          if (target === copy) {
            continue;
          }
          if ((copy != null) && typeof copy === 'object' && !Array.isArray(copy)) {
            clone = src && (src && typeof src === 'object' ? src : {});
            target[name] = this.merge(false, clone, copy);
          } else if (copy !== void 0) {
            if (!(inverse && typeof target[name] !== 'undefined')) {
              target[name] = copy;
            }
          }
        }
      }
    }
    return target;
  },
  /*
    `options(options)` Normalize options
  */

  options: function(options) {
    var option, _i, _len;
    if (!Array.isArray(options)) {
      options = [options];
    }
    for (_i = 0, _len = options.length; _i < _len; _i++) {
      option = options[_i];
      if ((option["if"] != null) && !Array.isArray(option["if"])) {
        option["if"] = [option["if"]];
      }
      if ((option.if_exists != null) && !Array.isArray(option.if_exists)) {
        option.if_exists = [option.if_exists];
      }
      if ((option.not_if_exists != null) && !Array.isArray(option.not_if_exists)) {
        option.not_if_exists = [option.not_if_exists];
      }
    }
    return options;
  }
};
