// Generated by CoffeeScript 1.4.0

module.exports = {
  /*
    `isPortOpen(port, host, callback)`: Check if a port is already open
  */

  isPortOpen: function(port, host, callback) {
    if (arguments.length === 2) {
      callback = host;
      host = '127.0.0.1';
    }
    return exec("nc " + host + " " + port + " < /dev/null", function(err, stdout, stderr) {
      if (!err) {
        return callback(null, true);
      }
      if (err.code === 1) {
        return callback(null, false);
      }
      return callback(err);
    });
  },
  /*
    `merge([inverse], obj1, obj2, ...]`: Recursively merge objects
    --------------------------------------------------------------
    On matching keys, the last object take precedence over previous ones 
    unless the inverse arguments is provided as true. Only objects are 
    merge, arrays are overwritten.
  
    Enrich an existing object with a second one:
      obj1 = { a_key: 'a value', b_key: 'b value'}
      obj2 = { b_key: 'new b value'}
      result = misc.merge obj1, obj2
      assert.eql result, obj1
      assert.eql obj1.b_key, 'new b value'
  
    Create a new object from two objects:
      obj1 = { a_key: 'a value', b_key: 'b value'}
      obj2 = { b_key: 'new b value'}
      result = misc.merge {}, obj1, obj2
      assert.eql result.b_key, 'new b value'
  
    Using inverse:
      obj1 = { b_key: 'b value'}
      obj2 = { a_key: 'a value', b_key: 'new b value'}
      misc.merge true, obj1, obj2
      assert.eql obj1.a_key, 'a value'
      assert.eql obj1.b_key, 'b value'
  */

  merge: function() {
    var clone, copy, from, i, inverse, name, options, src, target, to, _i;
    target = arguments[0];
    from = 1;
    to = arguments.length;
    if (typeof target === 'boolean') {
      inverse = !!target;
      target = arguments[1];
      from = 2;
    }
    if (typeof target !== "object" && typeof target !== 'function') {
      target = {};
    }
    for (i = _i = from; from <= to ? _i < to : _i > to; i = from <= to ? ++_i : --_i) {
      if ((options = arguments[i]) !== null) {
        for (name in options) {
          src = target[name];
          copy = options[name];
          if (target === copy) {
            continue;
          }
          if ((copy != null) && typeof copy === 'object' && !Array.isArray(copy)) {
            clone = src && (src && typeof src === 'object' ? src : {});
            target[name] = this.merge(false, clone, copy);
          } else if (copy !== void 0) {
            if (!(inverse && typeof target[name] !== 'undefined')) {
              target[name] = copy;
            }
          }
        }
      }
    }
    return target;
  },
  /*
    `options(options)` Normalize options
  */

  options: function(options) {
    var option, _i, _len;
    if (!Array.isArray(options)) {
      options = [options];
    }
    for (_i = 0, _len = options.length; _i < _len; _i++) {
      option = options[_i];
      if ((option["if"] != null) && !Array.isArray(option["if"])) {
        option["if"] = [option["if"]];
      }
      if ((option.if_exists != null) && !Array.isArray(option.if_exists)) {
        option.if_exists = [option.if_exists];
      }
      if ((option.not_if_exists != null) && !Array.isArray(option.not_if_exists)) {
        option.not_if_exists = [option.not_if_exists];
      }
    }
    return options;
  }
};
