// Generated by CoffeeScript 1.4.0
var ProxyStream, Stream, crypto, each, fs, misc, path, util, _ref;

crypto = require('crypto');

fs = require('fs');

path = require('path');

if ((_ref = fs.exists) == null) {
  fs.exists = path.exists;
}

each = require('each');

util = require('util');

Stream = require('stream');

ProxyStream = function() {};

util.inherits(ProxyStream, Stream);

module.exports = misc = {
  string: {
    /*
        `string.hash(file, [algorithm], callback)`
        ------------------------------------------
        Output the hash of a supplied string in hexadecimal 
        form. The default algorithm to compute the hash is md5.
    */

    hash: function(data, algorithm) {
      if (arguments.length === 1) {
        algorithm = 'md5';
      }
      return crypto.createHash(algorithm).update(data).digest('hex');
    }
  },
  file: {
    /*
        `files.hash(file, [algorithm], callback)`
        -----------------------------------------
        Output the hash of a supplied file in hexadecimal 
        form. If the provided file is a directory, the returned hash 
        is the sum of all the hashs of the files it recursively 
        contains. The default algorithm to compute the hash is md5.
    
        Throw an error if file does not exist unless it is a directory.
    */

    hash: function(file, algorithm, callback) {
      var hashs;
      if (arguments.length === 2) {
        callback = algorithm;
        algorithm = 'md5';
      }
      hashs = [];
      return fs.stat(file, function(err, stat) {
        if ((err != null ? err.code : void 0) === 'ENOENT') {
          return callback(new Error("Does not exist: " + file));
        }
        if (err) {
          return callback(err);
        }
        if (stat.isDirectory()) {
          file += '/**';
        }
        return each().files(file).on('item', function(item, next) {
          var shasum;
          shasum = crypto.createHash(algorithm);
          return fs.ReadStream(item).on('data', function(data) {
            return shasum.update(data);
          }).on('error', function(err) {
            if (err.code === 'EISDIR') {
              return next();
            }
            return next(err);
          }).on('end', function() {
            hashs.push(shasum.digest('hex'));
            return next();
          });
        }).on('error', function(err) {
          return callback(err);
        }).on('end', function() {
          switch (hashs.length) {
            case 0:
              if (stat.isFile()) {
                return callback(new Error("Does not exist: " + file));
              } else {
                return callback(null, crypto.createHash(algorithm).update('').digest('hex'));
              }
              break;
            case 1:
              return callback(null, hashs[0]);
            default:
              hashs = crypto.createHash(algorithm).update(hashs.join('')).digest('hex');
              return callback(null, hashs);
          }
        });
      });
    },
    /*
        `files.compare(files, callback)`
        --------------------------------
        Compare the hash of multiple file. Return the file md5 
        if the file are the same or false otherwise.
    */

    compare: function(files, callback) {
      var result;
      if (files.length < 2) {
        return callback(new Error('Minimum of 2 files'));
      }
      result = null;
      return each(files).parallel(true).on('item', function(file, next) {
        return misc.file.hash(file, function(err, md5) {
          if (err) {
            return next(err);
          }
          if (result === null) {
            result = md5;
          } else if (result !== md5) {
            result = false;
          }
          return next();
        });
      }).on('error', function(err) {
        return callback(err);
      }).on('end', function() {
        return callback(null, result);
      });
    }
  },
  /*
    `isPortOpen(port, host, callback)`: Check if a port is already open
  */

  isPortOpen: function(port, host, callback) {
    if (arguments.length === 2) {
      callback = host;
      host = '127.0.0.1';
    }
    return exec("nc " + host + " " + port + " < /dev/null", function(err, stdout, stderr) {
      if (!err) {
        return callback(null, true);
      }
      if (err.code === 1) {
        return callback(null, false);
      }
      return callback(err);
    });
  },
  /*
    `merge([inverse], obj1, obj2, ...]`: Recursively merge objects
    --------------------------------------------------------------
    On matching keys, the last object take precedence over previous ones 
    unless the inverse arguments is provided as true. Only objects are 
    merge, arrays are overwritten.
  
    Enrich an existing object with a second one:
      obj1 = { a_key: 'a value', b_key: 'b value'}
      obj2 = { b_key: 'new b value'}
      result = misc.merge obj1, obj2
      assert.eql result, obj1
      assert.eql obj1.b_key, 'new b value'
  
    Create a new object from two objects:
      obj1 = { a_key: 'a value', b_key: 'b value'}
      obj2 = { b_key: 'new b value'}
      result = misc.merge {}, obj1, obj2
      assert.eql result.b_key, 'new b value'
  
    Using inverse:
      obj1 = { b_key: 'b value'}
      obj2 = { a_key: 'a value', b_key: 'new b value'}
      misc.merge true, obj1, obj2
      assert.eql obj1.a_key, 'a value'
      assert.eql obj1.b_key, 'b value'
  */

  merge: function() {
    var clone, copy, from, i, inverse, name, options, src, target, to, _i;
    target = arguments[0];
    from = 1;
    to = arguments.length;
    if (typeof target === 'boolean') {
      inverse = !!target;
      target = arguments[1];
      from = 2;
    }
    if (typeof target !== "object" && typeof target !== 'function') {
      target = {};
    }
    for (i = _i = from; from <= to ? _i < to : _i > to; i = from <= to ? ++_i : --_i) {
      if ((options = arguments[i]) !== null) {
        for (name in options) {
          src = target[name];
          copy = options[name];
          if (target === copy) {
            continue;
          }
          if ((copy != null) && typeof copy === 'object' && !Array.isArray(copy)) {
            clone = src && (src && typeof src === 'object' ? src : {});
            target[name] = misc.merge(false, clone, copy);
          } else if (copy !== void 0) {
            if (!(inverse && typeof target[name] !== 'undefined')) {
              target[name] = copy;
            }
          }
        }
      }
    }
    return target;
  },
  /*
    `options(options)` Normalize options
  */

  options: function(options) {
    var option, _i, _len;
    if (!Array.isArray(options)) {
      options = [options];
    }
    for (_i = 0, _len = options.length; _i < _len; _i++) {
      option = options[_i];
      if ((option["if"] != null) && !Array.isArray(option["if"])) {
        option["if"] = [option["if"]];
      }
      if ((option.if_exists != null) && !Array.isArray(option.if_exists)) {
        option.if_exists = [option.if_exists];
      }
      if ((option.not_if_exists != null) && !Array.isArray(option.not_if_exists)) {
        option.not_if_exists = [option.not_if_exists];
      }
    }
    return options;
  }
};
