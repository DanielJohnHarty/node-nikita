// Generated by CoffeeScript 1.5.0
var ProxyStream, ST_MODE, Stat, Stream, buffer, connect, crypto, each, fs, misc, path, util, _ref;

crypto = require('crypto');

fs = require('fs');

path = require('path');

if ((_ref = fs.exists) == null) {
  fs.exists = path.exists;
}

each = require('each');

util = require('util');

Stream = require('stream');

connect = require('superexec/lib/connect');

buffer = require('buffer');

ProxyStream = function() {};

util.inherits(ProxyStream, Stream);

ST_MODE = {
  S_IFIFO: parseInt('0010000', 8),
  S_IFCHR: parseInt('0020000', 8),
  S_IFDIR: parseInt('0040000', 8),
  S_IFBLK: parseInt('0060000', 8),
  S_IFREG: parseInt('0100000', 8),
  S_IFLNK: parseInt('0120000', 8),
  S_IFSOCK: parseInt('0140000', 8),
  S_IFWHT: parseInt('0160000', 8)
};

Stat = (function() {

  function Stat(stat) {
    var k, v;
    for (k in stat) {
      v = stat[k];
      this[k] = v;
    }
    this;
  }

  Stat.prototype.isFile = function() {
    if (this.permissions & ST_MODE.S_IFREG) {
      return true;
    } else {
      return false;
    }
  };

  Stat.prototype.isDirectory = function() {
    if (this.permissions & ST_MODE.S_IFDIR) {
      return true;
    } else {
      return false;
    }
  };

  Stat.prototype.isBlockDevice = function() {
    if (this.permissions & ST_MODE.S_IFBLK) {
      return true;
    } else {
      return false;
    }
  };

  Stat.prototype.isCharacterDevice = function() {
    if (this.permissions & ST_MODE.S_IFCHR) {
      return true;
    } else {
      return false;
    }
  };

  Stat.prototype.isSymbolicLink = function() {
    if (this.permissions & ST_MODE.S_IFLNK) {
      return true;
    } else {
      return false;
    }
  };

  Stat.prototype.isFIFO = function() {
    if (this.permissions & ST_MODE.S_IFIFO) {
      return true;
    } else {
      return false;
    }
  };

  Stat.prototype.isSocket = function() {
    if (this.permissions & ST_MODE.S_IFSOCK) {
      return true;
    } else {
      return false;
    }
  };

  return Stat;

})();

module.exports = misc = {
  string: {
    /*
    `string.hash(file, [algorithm], callback)`
    ------------------------------------------
    Output the hash of a supplied string in hexadecimal 
    form. The default algorithm to compute the hash is md5.
    */

    hash: function(data, algorithm) {
      if (arguments.length === 1) {
        algorithm = 'md5';
      }
      return crypto.createHash(algorithm).update(data).digest('hex');
    }
  },
  file: {
    stat: function(ssh, path, callback) {
      if (!ssh) {
        return fs.stat(path, function(err, stat) {
          return callback(err, stat);
        });
      } else {
        return ssh.sftp(function(err, sftp) {
          if (err) {
            return callback(err);
          }
          return sftp.stat(path, function(err, attr) {
            if (err && err.type === 'NO_SUCH_FILE') {
              err.code = 'ENOENT';
              return callback(err);
            }
            return callback(err, new Stat(attr));
          });
        });
      }
    },
    /*
    `readFile(ssh, path, [options], callback)`
    -----------------------------------------
    */

    readFile: function(ssh, path, options, callback) {
      var _ref1;
      if (arguments.length === 3) {
        callback = options;
        options = {};
      }
      if ((_ref1 = options.encoding) == null) {
        options.encoding = 'utf8';
      }
      if (!ssh) {
        return fs.readFile(path, options.encoding, function(err, content) {
          return callback(err, content);
        });
      } else {
        return ssh.sftp(function(err, sftp) {
          var data, s;
          if (err) {
            return callback(err);
          }
          s = sftp.createReadStream(path, options);
          data = '';
          s.on('data', function(d) {
            return data += d.toString();
          });
          s.on('error', function(err) {
            return callback(err);
          });
          return s.on('end', function() {
            return callback(null, data);
          });
        });
      }
    },
    /*
    `writeFile(ssh, path, content, [options], callback)`
    -----------------------------------------
    */

    writeFile: function(ssh, path, content, options, callback) {
      if (arguments.length === 4) {
        callback = options;
        options = {};
      }
      if (!ssh) {
        return fs.writeFile(path, content, function(err, content) {
          return callback(err, content);
        });
      } else {
        return ssh.sftp(function(err, sftp) {
          var s;
          s = sftp.createWriteStream(path, options);
          if (typeof content === 'string' || buffer.Buffer.isBuffer(content)) {
            if (content) {
              s.write(content);
            }
            s.end();
          } else {
            content.pipe(s);
          }
          s.on('error', function(err) {
            return callback(err);
          });
          s.on('end', function() {
            return s.destroy();
          });
          return s.on('close', function() {
            return callback();
          });
        });
      }
    },
    /*
    `mkdir(ssh, path, [chmod], callback)`
    -------------------------------------
    */

    mkdir: function(ssh, path, chmod, callback) {
      if (arguments.length === 3) {
        callback = chmod;
        chmod = 0x1ed;
      }
      if (!ssh) {
        return fs.mkdir(path, chmod, function(err) {
          return callback(err);
        });
      } else {
        return ssh.sftp(function(err, sftp) {
          if (err) {
            return callback(err);
          }
          return sftp.mkdir(path, {
            permissions: chmod
          }, function(err, attr) {
            return callback(null, err ? false : true);
          });
        });
      }
    },
    /*
    `exists(ssh, path, callback)`
    */

    exists: function(ssh, path, callback) {
      if (!ssh) {
        return fs.exists(path, function(exists) {
          return callback(null, exists);
        });
      } else {
        return ssh.sftp(function(err, sftp) {
          if (err) {
            return callback(err);
          }
          return sftp.stat(path, function(err, attr) {
            return callback(null, err ? false : true);
          });
        });
      }
    },
    /*
    `files.hash(file, [algorithm], callback)`
    -----------------------------------------
    Output the hash of a supplied file in hexadecimal 
    form. If the provided file is a directory, the returned hash 
    is the sum of all the hashs of the files it recursively 
    contains. The default algorithm to compute the hash is md5.
    
    Throw an error if file does not exist unless it is a directory.
    */

    hash: function(file, algorithm, callback) {
      var hashs;
      if (arguments.length === 2) {
        callback = algorithm;
        algorithm = 'md5';
      }
      hashs = [];
      return fs.stat(file, function(err, stat) {
        if ((err != null ? err.code : void 0) === 'ENOENT') {
          return callback(new Error("Does not exist: " + file));
        }
        if (err) {
          return callback(err);
        }
        if (stat.isDirectory()) {
          file += '/**';
        }
        return each().files(file).on('item', function(item, next) {
          var shasum;
          shasum = crypto.createHash(algorithm);
          return fs.ReadStream(item).on('data', function(data) {
            return shasum.update(data);
          }).on('error', function(err) {
            if (err.code === 'EISDIR') {
              return next();
            }
            return next(err);
          }).on('end', function() {
            hashs.push(shasum.digest('hex'));
            return next();
          });
        }).on('error', function(err) {
          return callback(err);
        }).on('end', function() {
          switch (hashs.length) {
            case 0:
              if (stat.isFile()) {
                return callback(new Error("Does not exist: " + file));
              } else {
                return callback(null, crypto.createHash(algorithm).update('').digest('hex'));
              }
              break;
            case 1:
              return callback(null, hashs[0]);
            default:
              hashs = crypto.createHash(algorithm).update(hashs.join('')).digest('hex');
              return callback(null, hashs);
          }
        });
      });
    },
    /*
    `files.compare(files, callback)`
    --------------------------------
    Compare the hash of multiple file. Return the file md5 
    if the file are the same or false otherwise.
    */

    compare: function(files, callback) {
      var result;
      if (files.length < 2) {
        return callback(new Error('Minimum of 2 files'));
      }
      result = null;
      return each(files).parallel(true).on('item', function(file, next) {
        return misc.file.hash(file, function(err, md5) {
          if (err) {
            return next(err);
          }
          if (result === null) {
            result = md5;
          } else if (result !== md5) {
            result = false;
          }
          return next();
        });
      }).on('error', function(err) {
        return callback(err);
      }).on('end', function() {
        return callback(null, result);
      });
    }
  },
  /*
  `isPortOpen(port, host, callback)`: Check if a port is already open
  */

  isPortOpen: function(port, host, callback) {
    if (arguments.length === 2) {
      callback = host;
      host = '127.0.0.1';
    }
    return exec("nc " + host + " " + port + " < /dev/null", function(err, stdout, stderr) {
      if (!err) {
        return callback(null, true);
      }
      if (err.code === 1) {
        return callback(null, false);
      }
      return callback(err);
    });
  },
  /*
  `merge([inverse], obj1, obj2, ...]`: Recursively merge objects
  --------------------------------------------------------------
  On matching keys, the last object take precedence over previous ones 
  unless the inverse arguments is provided as true. Only objects are 
  merge, arrays are overwritten.
  
  Enrich an existing object with a second one:
    obj1 = { a_key: 'a value', b_key: 'b value'}
    obj2 = { b_key: 'new b value'}
    result = misc.merge obj1, obj2
    assert.eql result, obj1
    assert.eql obj1.b_key, 'new b value'
  
  Create a new object from two objects:
    obj1 = { a_key: 'a value', b_key: 'b value'}
    obj2 = { b_key: 'new b value'}
    result = misc.merge {}, obj1, obj2
    assert.eql result.b_key, 'new b value'
  
  Using inverse:
    obj1 = { b_key: 'b value'}
    obj2 = { a_key: 'a value', b_key: 'new b value'}
    misc.merge true, obj1, obj2
    assert.eql obj1.a_key, 'a value'
    assert.eql obj1.b_key, 'b value'
  */

  merge: function() {
    var clone, copy, from, i, inverse, name, options, src, target, to, _i;
    target = arguments[0];
    from = 1;
    to = arguments.length;
    if (typeof target === 'boolean') {
      inverse = !!target;
      target = arguments[1];
      from = 2;
    }
    if (typeof target !== "object" && typeof target !== 'function') {
      target = {};
    }
    for (i = _i = from; from <= to ? _i < to : _i > to; i = from <= to ? ++_i : --_i) {
      if ((options = arguments[i]) !== null) {
        for (name in options) {
          src = target[name];
          copy = options[name];
          if (target === copy) {
            continue;
          }
          if ((copy != null) && typeof copy === 'object' && !Array.isArray(copy)) {
            clone = src && (src && typeof src === 'object' ? src : {});
            target[name] = misc.merge(false, clone, copy);
          } else if (copy !== void 0) {
            if (!(inverse && typeof target[name] !== 'undefined')) {
              target[name] = copy;
            }
          }
        }
      }
    }
    return target;
  },
  /*
  `options(options, callback)`
  ----------------------------
  Normalize options and create an ssh connection if needed
  */

  options: function(options, callback) {
    if (!Array.isArray(options)) {
      options = [options];
    }
    return each(options).on('item', function(option, next) {
      if ((option["if"] != null) && !Array.isArray(option["if"])) {
        option["if"] = [option["if"]];
      }
      if ((option.if_exists != null) && !Array.isArray(option.if_exists)) {
        option.if_exists = [option.if_exists];
      }
      if ((option.not_if_exists != null) && !Array.isArray(option.not_if_exists)) {
        option.not_if_exists = [option.not_if_exists];
      }
      if (!option.ssh) {
        return next();
      }
      return connect(option.ssh, function(err, ssh) {
        if (err) {
          return next(err);
        }
        option.ssh = ssh;
        return next();
      });
    }).on('both', function(err) {
      return callback(err, options);
    });
  }
};
