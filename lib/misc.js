// Generated by CoffeeScript 1.7.1
var Stream, buffer, connect, crypto, each, exec, fs, ini, misc, path, rimraf, tilde, util,
  __slice = [].slice;

crypto = require('crypto');

fs = require('fs');

path = require('path');

if (fs.exists == null) {
  fs.exists = path.exists;
}

each = require('each');

util = require('util');

Stream = require('stream');

exec = require('ssh2-exec');

connect = require('ssh2-exec/lib/connect');

buffer = require('buffer');

rimraf = require('rimraf');

ini = require('ini');

tilde = require('tilde-expansion');

misc = module.exports = {
  regexp: {
    escape: function(str) {
      return str.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    }
  },
  string: {

    /*
    `string.hash(file, [algorithm], callback)`
    ------------------------------------------
    Output the hash of a supplied string in hexadecimal 
    form. The default algorithm to compute the hash is md5.
     */
    hash: function(data, algorithm) {
      if (arguments.length === 1) {
        algorithm = 'md5';
      }
      return crypto.createHash(algorithm).update(data).digest('hex');
    },
    repeat: function(str, l) {
      return Array(l + 1).join(str);
    }
  },
  path: {
    normalize: function(location, callback) {
      return tilde(location, function(location) {
        return callback(path.normalize(location));
      });
    },
    resolve: function() {
      var callback, locations, normalized, _i;
      locations = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), callback = arguments[_i++];
      normalized = [];
      return each(locations).on('item', function(location, next) {
        return misc.path.normalize(location, function(location) {
          normalized.push(location);
          return next();
        });
      }).on('end', function() {
        return callback(path.resolve.apply(path, normalized));
      });
    }
  },
  file: {
    readdir: function(ssh, path, callback) {
      if (!ssh) {
        return fs.readdir(path, callback);
      } else {
        return ssh.sftp(function(err, sftp) {
          if (err) {
            return callback(err);
          }
          return sftp.opendir(path, function(err, handle) {
            if (err) {
              return callback(err);
            }
            return sftp.readdir(handle, function(err, files) {
              return sftp.close(handle, function(err) {
                var file;
                if (err) {
                  return callback(err);
                }
                sftp.end();
                files = (function() {
                  var _i, _len, _results;
                  _results = [];
                  for (_i = 0, _len = files.length; _i < _len; _i++) {
                    file = files[_i];
                    _results.push(file.filename);
                  }
                  return _results;
                })();
                return callback(err, files);
              });
            });
          });
        });
      }
    },

    /*
    `chown(ssh, path, options, callback)`
    -------------------------------------
     */
    chown: function(ssh, path, uid, gid, callback) {
      if (!(uid || gid)) {
        return callback(new Error('Either option "uid" or "gid" is required'));
      }
      if (!ssh) {
        return fs.chown(path, uid, gid, function(err) {
          return callback(err);
        });
      } else {
        return ssh.sftp(function(err, sftp) {
          if (err) {
            return callback(err);
          }
          return sftp.chown(path, uid, gid, function(err) {
            sftp.end();
            return callback(err);
          });
        });
      }
    },

    /*
    `chmod(ssh, path, options, callback)`
    -------------------------------------
     */
    chmod: function(ssh, path, mode, callback) {
      if (!ssh) {
        return fs.chmod(path, mode, function(err) {
          return callback(err);
        });
      } else {
        return ssh.sftp(function(err, sftp) {
          if (err) {
            return callback(err);
          }
          return sftp.chmod(path, mode, function(err) {
            sftp.end();
            return callback(err);
          });
        });
      }
    },

    /*
    Compare modes
    -------------
     */
    cmpmod: function() {
      var i, l, mode, modes, ref, _i, _ref;
      modes = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      ref = modes[0];
      if (typeof ref === 'number') {
        ref = ref.toString(8);
      }
      for (i = _i = 1, _ref = modes.length; 1 <= _ref ? _i < _ref : _i > _ref; i = 1 <= _ref ? ++_i : --_i) {
        mode = modes[i];
        if (typeof mode === 'number') {
          mode = mode.toString(8);
        }
        l = Math.min(ref.length, mode.length);
        if (mode.substr(-l) !== ref.substr(-l)) {
          return false;
        }
      }
      return true;
    },

    /*
    `createReadStream(ssh, path, [options], callback)`
    --------------------------------------------------
    
        misc.file.createReadStream sshOrNull, 'test.out', (err, stream) ->
          stream.pipe fs.createWriteStream 'test.in'
     */
    createReadStream: function(ssh, source, options, callback) {
      if (arguments.length === 3) {
        callback = options;
        options = {};
      }
      if (!ssh) {
        return callback(null, fs.createReadStream(source, options));
      } else {
        return ssh.sftp(function(err, sftp) {
          var s;
          if (err) {
            return callback(err);
          }
          s = sftp.createReadStream(source, options);
          s.emit = (function(emit) {
            return function(key, val) {
              if (key === 'error' && val === void 0) {
                val = new Error("EISDIR, read");
                val.errno = 28;
                val.code = 'EISDIR';
                return emit.call(this, 'error', val);
              }
              if (key === 'error' && val.message === 'No such file') {
                val = new Error("ENOENT, open '" + source + "'");
                val.errno = 34;
                val.code = 'ENOENT';
                val.path = source;
                return emit.call(this, 'error', val);
              }
              return emit.apply(this, arguments);
            };
          })(s.emit);
          s.on('close', function() {
            return sftp.end();
          });
          return callback(null, s);
        });
      }
    },

    /*
    createWriteStream(ssh, path, [options], callback)
    -------------------------------------------------
    
        misc.file.createWriteStream sshOrNull, 'test.out', (err, stream) ->
          fs.createReadStream('test.in').pipe stream
     */
    createWriteStream: function(ssh, path, options, callback) {
      if (arguments.length === 3) {
        callback = options;
        options = {};
      }
      if (!ssh) {
        return callback(null, fs.createWriteStream(path, options));
      } else {
        return ssh.sftp(function(err, sftp) {
          var ws;
          if (err) {
            return callback(err);
          }
          ws = sftp.createWriteStream(path, options);
          ws.on('close', function() {
            return sftp.end();
          });
          return callback(null, ws);
        });
      }
    },

    /*
    `unlink(ssh, source, callback)`
     */
    unlink: function(ssh, source, callback) {
      if (!ssh) {
        return fs.unlink(source, function(err) {
          return callback(err);
        });
      } else {
        return ssh.sftp(function(err, sftp) {
          return sftp.unlink(source, function(err) {
            sftp.end();
            return callback(err);
          });
        });
      }
    },
    copy: function(ssh, source, destination, callback) {
      if (!ssh) {
        source = fs.createReadStream(u.pathname);
        source.pipe(destination);
        destination.on('close', callback);
        return destination.on('error', callback);
      } else {
        return callback(new Error('Copy over SSH not yet implemented'));
      }
    },
    rename: function(ssh, source, destination, callback) {
      if (!ssh) {
        return fs.rename(source, destination, function(err) {
          return callback(err);
        });
      } else {
        return ssh.sftp(function(err, sftp) {
          return sftp.rename(source, destination, function(err) {
            sftp.end();
            return callback(err);
          });
        });
      }
    },
    readlink: function(ssh, path, callback) {
      if (!ssh) {
        return fs.readlink(path, function(err, target) {
          return callback(err, target);
        });
      } else {
        return ssh.sftp(function(err, sftp) {
          if (err) {
            return callback(err);
          }
          return sftp.readlink(path, function(err, target) {
            sftp.end();
            return callback(err, target);
          });
        });
      }
    },
    unlink: function(ssh, path, callback) {
      if (!ssh) {
        return fs.unlink(path, function(err) {
          return callback(err);
        });
      } else {
        return ssh.sftp(function(err, sftp) {
          if (err) {
            return callback(err);
          }
          return sftp.unlink(path, function(err) {
            sftp.end();
            return callback(err);
          });
        });
      }
    },
    symlink: function(ssh, targetPath, linkPath, callback) {
      if (!ssh) {
        return fs.symlink(targetPath, linkPath, function(err) {
          return callback(err);
        });
      } else {
        return ssh.sftp(function(err, sftp) {
          if (err) {
            return callback(err);
          }
          return sftp.symlink(targetPath, linkPath, function(err) {
            sftp.end();
            return callback(err);
          });
        });
      }
    },
    lstat: function(ssh, path, callback) {
      if (!ssh) {
        return fs.lstat(path, function(err, stat) {
          return callback(err, stat);
        });
      } else {
        return ssh.sftp(function(err, sftp) {
          if (err) {
            return callback(err);
          }
          return sftp.lstat(path, function(err, attr) {
            sftp.end();
            if (err && err.type === 'NO_SUCH_FILE') {
              err.code = 'ENOENT';
              return callback(err);
            }
            return callback(err, attr);
          });
        });
      }
    },
    stat: function(ssh, path, callback) {
      if (!ssh) {
        return fs.stat(path, function(err, stat) {
          return callback(err, stat);
        });
      } else {
        return ssh.sftp(function(err, sftp) {
          if (err) {
            return callback(err);
          }
          return sftp.stat(path, function(err, attr) {
            sftp.end();
            if (err && err.type === 'NO_SUCH_FILE') {
              err.code = 'ENOENT';
              return callback(err);
            }
            return callback(err, attr);
          });
        });
      }
    },

    /*
    `readFile(ssh, path, [options], callback)`
    -----------------------------------------
     */
    readFile: function(ssh, source, options, callback) {
      if (arguments.length === 3) {
        callback = options;
        options = {};
      } else {
        if (typeof options === 'string') {
          options = {
            encoding: options
          };
        }
      }
      if (!source) {
        return callback(new Error("Invalid path '" + source + "'"));
      }
      if (!ssh) {
        return fs.readFile(source, options.encoding, function(err, content) {
          return callback(err, content);
        });
      } else {
        return ssh.sftp(function(err, sftp) {
          var data, finish, s;
          if (err) {
            return callback(err);
          }
          s = sftp.createReadStream(source, options);
          data = [];
          s.on('data', function(d) {
            return data.push(d.toString());
          });
          s.on('error', function(err) {
            err = new Error("ENOENT, open '" + source + "'");
            err.errno = 34;
            err.code = 'ENOENT';
            err.path = source;
            return finish(err);
          });
          s.on('close', function() {
            return finish(null, data.join(''));
          });
          return finish = function(err, data) {
            sftp.end();
            return callback(err, data);
          };
        });
      }
    },

    /*
    `writeFile(ssh, path, content, [options], callback)`
    -----------------------------------------
     */
    writeFile: function(ssh, source, content, options, callback) {
      var chmod, chown, finish, write;
      if (arguments.length === 4) {
        callback = options;
        options = {};
      } else {
        if (typeof options === 'string') {
          options = {
            encoding: options
          };
        }
      }
      if (!ssh) {
        write = function() {
          var stream;
          stream = fs.createWriteStream(source, options);
          if (typeof content === 'string' || buffer.Buffer.isBuffer(content)) {
            if (content) {
              stream.write(content);
            }
            stream.end();
          } else {
            content.pipe(stream);
          }
          stream.on('error', function(err) {
            return callback(err);
          });
          stream.on('end', function() {
            return s.destroy();
          });
          return stream.on('close', function() {
            return chown();
          });
        };
        chown = function() {
          if (!(options.uid || options.gid)) {
            return chmod();
          }
          return fs.chown(source, options.uid, options.gid, function(err) {
            if (err) {
              return callback(err);
            }
            return chmod();
          });
        };
        chmod = function() {
          if (!options.mode) {
            return finish();
          }
          return fs.chmod(source, options.mode, function(err) {
            return finish(err);
          });
        };
        finish = function(err) {
          return callback(err);
        };
        return write();
      } else {
        return ssh.sftp(function(err, sftp) {
          if (err) {
            return callback(err);
          }
          write = function() {
            var s;
            s = sftp.createWriteStream(source, options);
            if (typeof content === 'string' || buffer.Buffer.isBuffer(content)) {
              if (content) {
                s.write(content);
              }
              s.end();
            } else {
              content.pipe(s);
            }
            s.on('error', function(err) {
              return finish(err);
            });
            s.on('end', function() {
              return s.destroy();
            });
            return s.on('close', function() {
              return chown();
            });
          };
          chown = function() {
            if (!(options.uid || options.gid)) {
              return chmod();
            }
            return sftp.chown(source, options.uid, options.gid, function(err) {
              if (err) {
                return finish(err);
              }
              return chmod();
            });
          };
          chmod = function() {
            if (!options.mode) {
              return finish();
            }
            return sftp.chmod(source, options.mode, function(err) {
              return finish(err);
            });
          };
          finish = function(err) {
            sftp.end();
            return callback(err);
          };
          return write();
        });
      }
    },

    /*
    `mkdir(ssh, path, [options], callback)`
    -------------------------------------
    Note, if option is not a string, it is considered to be the permission mode.
     */
    mkdir: function(ssh, path, options, callback) {
      if (arguments.length === 3) {
        callback = options;
        options = 0x1ed;
      }
      if (typeof options !== 'object') {
        options = {
          mode: options
        };
      }
      if (options.permissions) {
        process.stderr.write('Deprecated, use mode instead of permissions');
        options.mode = options.permissions;
      }
      if (!ssh) {
        return fs.mkdir(path, options.mode, function(err) {
          return callback(err);
        });
      } else {
        return ssh.sftp(function(err, sftp) {
          var chmod, chown, finish, mkdir;
          if (err) {
            return callback(err);
          }
          mkdir = function() {
            return sftp.mkdir(path, options, function(err, attr) {
              if ((err != null ? err.message : void 0) === 'Failure') {
                err = new Error("EEXIST, mkdir '" + path + "'");
                err.errno = 47;
                err.code = 'EEXIST';
                err.path = path;
              }
              if (err) {
                return finish(err);
              }
              return chown();
            });
          };
          chown = function() {
            if (!(options.uid || options.gid)) {
              return chmod();
            }
            return sftp.chown(path, options.uid, options.gid, function(err) {
              if (err) {
                return finish(err);
              }
              return chmod();
            });
          };
          chmod = function() {
            if (!options.mode) {
              return finish();
            }
            return sftp.chmod(path, options.mode, function(err) {
              return finish(err);
            });
          };
          finish = function(err) {
            sftp.end();
            return callback(err);
          };
          return mkdir();
        });
      }
    },

    /*
    `exists(ssh, path, callback)`
    -----------------------------
    
    `options`         Command options include:   
    
    *   `ssh`         SSH connection in case of a remote file path.  
    *   `path`        Path to test.   
    *   `callback`    Callback to return the result.   
    
    `callback`        Received parameters are:   
    
    *   `err`         Error object if any.   
    *   `exists`      True if the file exists.
     */
    exists: function(ssh, path, callback) {
      if (!ssh) {
        return fs.exists(path, function(exists) {
          return callback(null, exists);
        });
      } else {
        return ssh.sftp(function(err, sftp) {
          if (err) {
            return callback(err);
          }
          return sftp.stat(path, function(err, attr) {
            sftp.end();
            return callback(null, err ? false : true);
          });
        });
      }
    },

    /*
    `files.hash(file, [algorithm], callback)`
    -----------------------------------------
    Retrieve the hash of a supplied file in hexadecimal 
    form. If the provided file is a directory, the returned hash 
    is the sum of all the hashs of the files it recursively 
    contains. The default algorithm to compute the hash is md5.
    
    Throw an error if file does not exist unless it is a directory.
    
        misc.file.hash ssh, '/path/to/file', (err, md5) ->
          md5.should.eql '287621a8df3c3f6c99c7b7645bd09ffd'
     */
    hash: function(ssh, file, algorithm, callback) {
      var hasher, hashs;
      if (arguments.length === 3) {
        callback = algorithm;
        algorithm = 'md5';
      }
      hasher = function(ssh, path, callback) {
        var shasum;
        shasum = crypto.createHash(algorithm);
        return misc.file.createReadStream(ssh, path, function(err, stream) {
          if (err) {
            return callback(err);
          }
          return stream.on('data', function(data) {
            return shasum.update(data);
          }).on('error', function(err) {
            if (err.code === 'EISDIR') {
              return callback();
            }
            return callback(err);
          }).on('end', function() {
            return callback(err, shasum.digest('hex'));
          });
        });
      };
      hashs = [];
      return misc.file.stat(ssh, file, function(err, stat) {
        if ((err != null ? err.code : void 0) === 'ENOENT') {
          return callback(new Error("Does not exist: " + file));
        }
        if (err) {
          return callback(err);
        }
        if (stat.isDirectory()) {
          file += '/**';
        }
        if (ssh && stat.isFile()) {
          return hasher(ssh, file, callback);
        }
        return each().files(file).on('item', function(item, next) {
          return hasher(ssh, item, function(err, h) {
            if (err) {
              return next(err);
            }
            if (h != null) {
              hashs.push(h);
            }
            return next();
          });
        }).on('error', function(err) {
          return callback(err);
        }).on('end', function() {
          switch (hashs.length) {
            case 0:
              if (stat.isFile()) {
                return callback(new Error("Does not exist: " + file));
              } else {
                return callback(null, crypto.createHash(algorithm).update('').digest('hex'));
              }
              break;
            case 1:
              return callback(null, hashs[0]);
            default:
              hashs = crypto.createHash(algorithm).update(hashs.join('')).digest('hex');
              return callback(null, hashs);
          }
        });
      });
    },

    /*
    `files.compare(files, callback)`
    --------------------------------
    Compare the hash of multiple file. Return the file md5 
    if the file are the same or false otherwise.
     */
    compare: function(ssh, files, callback) {
      var result;
      if (files.length < 2) {
        return callback(new Error('Minimum of 2 files'));
      }
      result = null;
      return each(files).parallel(true).on('item', function(file, next) {
        return misc.file.hash(ssh, file, function(err, md5) {
          if (err) {
            return next(err);
          }
          if (result === null) {
            result = md5;
          } else if (result !== md5) {
            result = false;
          }
          return next();
        });
      }).on('error', function(err) {
        return callback(err);
      }).on('end', function() {
        return callback(null, result);
      });
    },

    /*
    remove(ssh, path, callback)
    ---------------------------
    Remove a file or directory
     */
    remove: function(ssh, path, callback) {
      var child;
      if (!ssh) {
        return rimraf(path, callback);
      } else {
        child = exec("rm -rdf " + path, {
          ssh: ssh
        });
        return child.on('exit', function(code) {
          return callback(null, code);
        });
      }
    }
  },
  ssh: {

    /*
    passwd(sftp, [user], callback)
    ----------------------
    Return information present in '/etc/passwd' and cache the 
    result in the provided ssh instance as "passwd".
    
    Result look like: 
        { root: {
            uid: '0',
            gid: '0',
            comment: 'root',
            home: '/root',
            shell: '/bin/bash' }, ... }
     */
    passwd: function(ssh, username, callback) {
      if (arguments.length === 3) {
        if (!username) {
          return callback(null, null);
        }
        if (ssh.passwd && ssh.passwd[username]) {
          return callback(null, ssh.passwd[username]);
        }
        ssh.passwd = null;
        return misc.ssh.passwd(ssh, function(err, users) {
          var user;
          if (err) {
            return callback(err);
          }
          user = users[username];
          if (!user) {
            return callback(new Error("User " + username + " does not exists"));
          }
          return callback(null, user);
        });
      }
      callback = username;
      username = null;
      if (ssh.passwd) {
        return callback(null, ssh.passwd);
      }
      return misc.file.readFile(ssh, '/etc/passwd', 'ascii', function(err, lines) {
        var info, line, passwd, _i, _len, _ref;
        if (err) {
          return callback(err);
        }
        passwd = [];
        _ref = lines.split('\n');
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          line = _ref[_i];
          info = /(.*)\:\w\:(.*)\:(.*)\:(.*)\:(.*)\:(.*)/.exec(line);
          if (!info) {
            continue;
          }
          passwd[info[1]] = {
            uid: parseInt(info[2]),
            gid: parseInt(info[3]),
            comment: info[4],
            home: info[5],
            shell: info[6]
          };
        }
        ssh.passwd = passwd;
        return callback(null, passwd);
      });
    },

    /*
    group(sftp, [group], callback)
    ----------------------
    Return information present in '/etc/group' and cache the 
    result in the provided ssh instance as "group".
    
    Result look like: 
        { root: {
            password: 'x'
            gid: 0,
            user_list: [] },
          bin: {
            password: 'x',
            gid: 1,
            user_list: ['bin','daemon'] } }
     */
    group: function(ssh, group, callback) {
      if (arguments.length === 3) {
        if (!group) {
          return callback(null, null);
        }
        if (ssh.cache_group && ssh.cache_group[group]) {
          return callback(null, ssh.cache_group[group]);
        }
        ssh.cache_group = null;
        return misc.ssh.group(ssh, function(err, groups) {
          var gid;
          if (err) {
            return err;
          }
          gid = groups[group];
          if (!gid) {
            return callback(new Error("Group does not exists: " + group));
          }
          return callback(null, gid);
        });
      }
      callback = group;
      group = null;
      if (ssh.cache_group) {
        return callback(null, ssh.cache_group);
      }
      return misc.file.readFile(ssh, '/etc/group', 'ascii', function(err, lines) {
        var info, line, _i, _len, _ref;
        if (err) {
          return callback(err);
        }
        group = [];
        _ref = lines.split('\n');
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          line = _ref[_i];
          info = /(.*)\:(.*)\:(.*)\:(.*)/.exec(line);
          if (!info) {
            continue;
          }
          group[info[1]] = {
            password: info[2],
            gid: parseInt(info[3]),
            user_list: info[4] ? info[4].split(',') : []
          };
        }
        ssh.cache_group = group;
        return callback(null, group);
      });
    }
  },

  /*
  `pidfileStatus(ssh, pidfile, [options], callback)`
  ---------------------------------------
  
  Return a status code after reading a status file. Any existing 
  pidfile referencing a dead process will be removed.
  
  The callback is called with an error and a status code. Values 
  expected as status code are:
  
  *   0 if pidfile math a running process
  *   1 if pidfile does not exists
  *   2 if pidfile exists but match no process
   */
  pidfileStatus: function(ssh, pidfile, options, callback) {
    if (arguments.length === 3) {
      callback = options;
      options = {};
    }
    return misc.file.readFile(ssh, pidfile, 'ascii', function(err, pid) {
      var run, stdout;
      if (err && err.code === 'ENOENT') {
        return callback(null, 1);
      }
      if (err) {
        return callback(err);
      }
      stdout = [];
      run = exec({
        cmd: "ps aux | grep " + (pid.trim()) + " | grep -v grep | awk '{print $2}'",
        ssh: ssh
      });
      run.stdout.on('data', function(data) {
        return stdout.push(data);
      });
      if (options.stdout) {
        run.stdout.pipe(options.stdout);
      }
      if (options.stderr) {
        run.stderr.pipe(options.stderr);
      }
      return run.on("exit", function(code) {
        stdout = stdout.join('');
        if (stdout !== '') {
          return callback(null, 0);
        }
        return misc.file.remove(ssh, pidfile, function(err, removed) {
          if (err) {
            return callback(err);
          }
          return callback(null, 2);
        });
      });
    });
  },

  /*
  `isPortOpen(port, host, callback)`: Check if a port is already open
   */
  isPortOpen: function(port, host, callback) {
    if (arguments.length === 2) {
      callback = host;
      host = '127.0.0.1';
    }
    return exec("nc " + host + " " + port + " < /dev/null", function(err, stdout, stderr) {
      if (!err) {
        return callback(null, true);
      }
      if (err.code === 1) {
        return callback(null, false);
      }
      return callback(err);
    });
  },

  /*
  `merge([inverse], obj1, obj2, ...]`: Recursively merge objects
  --------------------------------------------------------------
  On matching keys, the last object take precedence over previous ones 
  unless the inverse arguments is provided as true. Only objects are 
  merge, arrays are overwritten.
  
  Enrich an existing object with a second one:
    obj1 = { a_key: 'a value', b_key: 'b value'}
    obj2 = { b_key: 'new b value'}
    result = misc.merge obj1, obj2
    assert.eql result, obj1
    assert.eql obj1.b_key, 'new b value'
  
  Create a new object from two objects:
    obj1 = { a_key: 'a value', b_key: 'b value'}
    obj2 = { b_key: 'new b value'}
    result = misc.merge {}, obj1, obj2
    assert.eql result.b_key, 'new b value'
  
  Using inverse:
    obj1 = { b_key: 'b value'}
    obj2 = { a_key: 'a value', b_key: 'new b value'}
    misc.merge true, obj1, obj2
    assert.eql obj1.a_key, 'a value'
    assert.eql obj1.b_key, 'b value'
   */
  merge: function() {
    var clone, copy, from, i, inverse, name, options, src, target, to, _i;
    target = arguments[0];
    from = 1;
    to = arguments.length;
    if (typeof target === 'boolean') {
      inverse = !!target;
      target = arguments[1];
      from = 2;
    }
    if (typeof target !== "object" && typeof target !== 'function') {
      target = {};
    }
    for (i = _i = from; from <= to ? _i < to : _i > to; i = from <= to ? ++_i : --_i) {
      if ((options = arguments[i]) !== null) {
        for (name in options) {
          src = target[name];
          copy = options[name];
          if (target === copy) {
            continue;
          }
          if ((copy != null) && typeof copy === 'object' && !Array.isArray(copy) && !(copy instanceof RegExp)) {
            clone = src && (src && typeof src === 'object' ? src : {});
            target[name] = misc.merge(false, clone, copy);
          } else if (copy !== void 0) {
            if (!(inverse && typeof target[name] !== 'undefined')) {
              target[name] = copy;
            }
          }
        }
      }
    }
    return target;
  },
  kadmin: function(options, cmd) {
    var realm;
    realm = options.realm ? "-r " + options.realm : '';
    if (options.kadmin_principal) {
      return "kadmin " + realm + " -p " + options.kadmin_principal + " -s " + options.kadmin_server + " -w " + options.kadmin_password + " -q '" + cmd + "'";
    } else {
      return "kadmin.local " + realm + " -q '" + cmd + "'";
    }
  },
  ini: {
    safe: function(val) {
      if (typeof val !== "string" || val.match(/[\r\n]/) || val.match(/^\[/) || (val.length > 1 && val.charAt(0) === "\"" && val.slice(-1) === "\"") || val !== val.trim()) {
        return JSON.stringify(val);
      } else {
        return val.replace(/;/g, '\\;');
      }
    },
    dotSplit: function (str) {
      return str.replace(/\1/g, '\2LITERAL\\1LITERAL\2')
             .replace(/\\\./g, '\1')
             .split(/\./).map(function (part) {
               return part.replace(/\1/g, '\\.')
                      .replace(/\2LITERAL\\1LITERAL\2/g, '\1')
             })
    },
    parse: function(content, options) {
      return ini.parse(content);
    },

    /*
    
    Each category is surrounded by one or several square brackets. The number of brackets indicates
    the depth of the category.
    Options are   
    
    *   `comment`   Default to ";"
     */
    parse_multi_brackets: function(str, options) {
      var comment, current, data, lines, stack;
      if (options == null) {
        options = {};
      }
      lines = str.split(/[\r\n]+/g);
      current = data = {};
      stack = [current];
      comment = options.comment || ';';
      lines.forEach(function(line, _, __) {
        var depth, match, parent;
        if (!line || line.match(/^\s*$/)) {
          return;
        }
        if (match = line.match(/^\s*(\[+)(.+?)(\]+)\s*$/)) {
          depth = match[1].length;
          if (depth === stack.length) {
            parent = stack[depth - 1];
            parent[match[2]] = current = {};
            stack.push(current);
          }
          if (depth > stack.length) {
            throw new Error("Invalid child " + match[2]);
          }
          if (depth < stack.length) {
            stack.splice(depth, stack.length - depth);
            parent = stack[depth - 1];
            parent[match[2]] = current = {};
            return stack.push(current);
          }
        } else if (comment && (match = line.match(RegExp("^\\s*(" + comment + ".*)$")))) {
          return current[match[1]] = null;
        } else if (match = line.match(/^\s*(.+?)\s*=\s*(.+)\s*$/)) {
          return current[match[1]] = match[2];
        } else if (match = line.match(/^\s*(.+?)\s*$/)) {
          return current[match[1]] = null;
        }
      });
      return data;
    },
    stringify: function(obj, section, options) {
      var children, dotSplit, eol, out, safe;
      if (arguments.length === 2) {
        options = section;
        section = void 0;
      }
      if (options.separator == null) {
        options.separator = ' = ';
      }
      eol = process.platform === "win32" ? "\r\n" : "\n";
      safe = misc.ini.safe;
      dotSplit = misc.ini.dotSplit;
      children = [];
      out = "";
      Object.keys(obj).forEach(function(k, _, __) {
        var val;
        val = obj[k];
        if (val && Array.isArray(val)) {
          return val.forEach(function(item) {
            return out += safe("" + k + "[]") + options.separator + safe(item) + "\n";
          });
        } else if (val && typeof val === "object") {
          return children.push(k);
        } else {
          return out += safe(k) + options.separator + safe(val) + eol;
        }
      });
      if (section && out.length) {
        out = "[" + safe(section) + "]" + eol + out;
      }
      children.forEach(function(k, _, __) {
        var child, nk;
        nk = dotSplit(k).join('\\.');
        child = misc.ini.stringify(obj[k], (section ? section + "." : "") + nk, options);
        if (out.length && child.length) {
          out += eol;
        }
        return out += child;
      });
      return out;
    },
    stringify_square_then_curly: function(content, depth, options) {
      var i, indent, isBoolean, isNull, isObj, isUndefined, k, out, prefix, v, _i;
      if (depth == null) {
        depth = 0;
      }
      if (options == null) {
        options = {};
      }
      if (arguments.length === 2) {
        options = depth;
        depth = 0;
      }
      if (options.separator == null) {
        options.separator = ' = ';
      }
      out = '';
      indent = ' ';
      prefix = '';
      for (i = _i = 0; 0 <= depth ? _i < depth : _i > depth; i = 0 <= depth ? ++_i : --_i) {
        prefix += indent;
      }
      for (k in content) {
        v = content[k];
        isUndefined = typeof v === 'undefined';
        isBoolean = typeof v === 'boolean';
        isNull = v === null;
        isObj = typeof v === 'object' && !isNull;
        if (isObj) {
          if (depth === 0) {
            out += "" + prefix + "[" + k + "]\n";
            out += misc.ini.stringify_square_then_curly(v, depth + 1, options);
            out += "\n";
          } else {
            out += "" + prefix + k + options.separator + "{\n";
            out += misc.ini.stringify_square_then_curly(v, depth + 1, options);
            out += "" + prefix + "}\n";
          }
        } else {
          if (isNull) {
            out += "" + prefix + k + options.separator + "null";
          } else if (isBoolean) {
            out += "" + prefix + k + options.separator + (v ? 'true' : 'false');
          } else {
            out += "" + prefix + k + options.separator + v;
          }
          out += '\n';
        }
      }
      return out;
    },

    /*
    Each category is surrounded by one or several square brackets. The number of brackets indicates
    the depth of the category.
     */
    stringify_multi_brackets: function(content, depth, options) {
      var i, indent, isBoolean, isNull, isObj, isUndefined, k, out, prefix, v, _i;
      if (depth == null) {
        depth = 0;
      }
      if (options == null) {
        options = {};
      }
      if (arguments.length === 2) {
        options = depth;
        depth = 0;
      }
      if (options.separator == null) {
        options.separator = ' = ';
      }
      out = '';
      indent = '  ';
      prefix = '';
      for (i = _i = 0; 0 <= depth ? _i < depth : _i > depth; i = 0 <= depth ? ++_i : --_i) {
        prefix += indent;
      }
      for (k in content) {
        v = content[k];
        isUndefined = typeof v === 'undefined';
        isBoolean = typeof v === 'boolean';
        isNull = v === null;
        isObj = typeof v === 'object' && !isNull;
        if (isObj) {
          continue;
        }
        if (isNull) {
          out += "" + prefix + k;
        } else if (isBoolean) {
          out += "" + prefix + k + options.separator + (v ? 'true' : 'false');
        } else {
          out += "" + prefix + k + options.separator + v;
        }
        out += '\n';
      }
      for (k in content) {
        v = content[k];
        isNull = v === null;
        isObj = typeof v === 'object' && !isNull;
        if (!isObj) {
          continue;
        }
        out += "" + prefix + (misc.string.repeat('[', depth + 1)) + k + (misc.string.repeat(']', depth + 1)) + "\n";
        out += misc.ini.stringify_multi_brackets(v, depth + 1, options);
      }
      return out;
    }
  },
  args: function(args, overwrite_goptions) {
    if (overwrite_goptions == null) {
      overwrite_goptions = {};
    }
    if (args.length === 2 && typeof args[1] === 'function') {
      args[2] = args[1];
      args[1] = args[0];
      args[0] = null;
    } else if (args.length === 1) {
      args[1] = args[0];
      args[0] = null;
    }
    if (args[0] == null) {
      args[0] = misc.merge({
        parallel: true
      }, overwrite_goptions);
    }
    return args;
  },

  /*
  
  `options(options, callback)`
  ----------------------------
  Normalize options. An ssh connection is needed if the key "ssh" 
  hold a configuration object. The 'uid' and 'gid' fields will 
  be converted to integer if they match a username or a group.   
  
  `callback`          Received parameters are:   
  
  *   `err`           Error object if any.   
  *   `options`       Sanitized options.
   */
  options: function(options, callback) {
    if (!Array.isArray(options)) {
      options = [options];
    }
    return each(options).on('item', function(options, next) {
      var connection, destination, el, gid, i, mode, source, uid, v, _i, _j, _len, _len1, _ref, _ref1;
      if ((options["if"] != null) && !Array.isArray(options["if"])) {
        options["if"] = [options["if"]];
      }
      if ((options.if_exists != null) && !Array.isArray(options.if_exists)) {
        options.if_exists = [options.if_exists];
      }
      if ((options.not_if_exists != null) && !Array.isArray(options.not_if_exists)) {
        options.not_if_exists = [options.not_if_exists];
      }
      if (options.if_exists) {
        _ref = options.if_exists;
        for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
          el = _ref[i];
          if (el === true && options.destination) {
            options.if_exists[i] = options.destination;
          }
        }
      }
      if (options.not_if_exists) {
        _ref1 = options.not_if_exists;
        for (i = _j = 0, _len1 = _ref1.length; _j < _len1; i = ++_j) {
          v = _ref1[i];
          if (v === true && options.destination) {
            options.not_if_exists[i] = options.destination;
          }
        }
      }
      if (options.chmod) {
        if (options.mode == null) {
          options.mode = options.chmod;
        }
      }
      connection = function() {
        if (!options.ssh) {
          return next();
        }
        return connect(options.ssh, function(err, ssh) {
          if (err) {
            return next(err);
          }
          options.ssh = ssh;
          return source();
        });
      };
      source = function() {
        if (options.source == null) {
          return destination();
        }
        if (/^\w+:/.test(options.source)) {
          return destination();
        }
        return tilde(options.source, function(source) {
          options.source = source;
          return destination();
        });
      };
      destination = function() {
        if (options.destination == null) {
          return mode();
        }
        if (/^\w+:/.test(options.source)) {
          return mode();
        }
        return tilde(options.destination, function(destination) {
          options.destination = destination;
          return mode();
        });
      };
      mode = function() {
        if (typeof options.mode === 'string') {
          options.mode = parseInt(options.mode, 8);
        }
        return uid();
      };
      uid = function() {
        if (!options.uid) {
          return gid();
        }
        if (typeof options.uid === 'number' || /\d+/.test(options.uid)) {
          return gid();
        }
        return misc.ssh.passwd(options.ssh, options.uid, function(err, user) {
          if (err) {
            return next(err);
          }
          options.uid = user.uid;
          if (options.gid == null) {
            options.gid = user.gid;
          }
          return gid();
        });
      };
      gid = function() {
        if (!options.gid) {
          return next();
        }
        if (typeof options.gid === 'number' || /\d+/.test(options.gid)) {
          return next();
        }
        return misc.ssh.group(options.ssh, options.gid, function(err, group) {
          if (err) {
            return next(err);
          }
          if (group) {
            options.gid = group.gid;
          }
          return next();
        });
      };
      return connection();
    }).on('both', function(err) {
      return callback(err, options);
    });
  }
};
