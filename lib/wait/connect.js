// Generated by CoffeeScript 1.9.3
var each, inc,
  slice = [].slice;

inc = 0;

module.exports = function(options, callback) {
  var host, hosts, i, j, k, l, len, len1, len2, len3, len4, m, modified, n, port, ports, quorum_current, quorum_target, randfiles, ref, ref1, ref2, ref3, ref4, ref5, ref6, servers;
  ref = ['host', 'hosts'];
  for (i = 0, len = ref.length; i < len; i++) {
    k = ref[i];
    if (options[k] == null) {
      options[k] = [];
    }
    if ((ref1 = typeof options[k]) !== 'string' && ref1 !== 'object') {
      throw error("Invalid option '" + options[k] + "'");
    }
    if (!Array.isArray(options[k])) {
      options[k] = [options[k]];
    }
  }
  hosts = slice.call(options.host).concat(slice.call(options.hosts));
  ref2 = ['port', 'ports'];
  for (j = 0, len1 = ref2.length; j < len1; j++) {
    k = ref2[j];
    if (options[k] == null) {
      options[k] = [];
    }
    if ((ref3 = typeof options[k]) !== 'string' && ref3 !== 'number' && ref3 !== 'object') {
      throw error("Invalid option '" + options[k] + "'");
    }
    if (!Array.isArray(options[k])) {
      options[k] = [options[k]];
    }
  }
  ports = slice.call(options.port).concat(slice.call(options.ports));
  ref4 = ['server', 'servers'];
  for (l = 0, len2 = ref4.length; l < len2; l++) {
    k = ref4[l];
    if (options[k] == null) {
      options[k] = [];
    }
    if ((ref5 = typeof options[k]) !== 'string' && ref5 !== 'object') {
      throw error("Invalid option '" + options[k] + "'");
    }
    if (typeof options[k] === 'string') {
      ref6 = options[k].split(':'), host = ref6[0], port = ref6[1];
      options[k] = {
        host: host,
        port: port
      };
    }
    if (!Array.isArray(options[k])) {
      options[k] = [options[k]];
    }
  }
  servers = [];
  for (m = 0, len3 = hosts.length; m < len3; m++) {
    host = hosts[m];
    for (n = 0, len4 = ports.length; n < len4; n++) {
      port = ports[n];
      servers.push({
        host: host,
        port: port
      });
    }
  }
  servers.push.apply(servers, slice.call(options.server).concat(slice.call(options.servers)));
  if (!servers.length) {
    return callback();
  }
  if (options.randdir == null) {
    options.randdir = '/tmp';
  }
  if (options.interval == null) {
    options.interval = 2000;
  }
  options.interval = Math.round(options.interval / 1000);
  quorum_target = options.quorum;
  if (quorum_target && quorum_target === true) {
    quorum_target = Math.ceil(servers.length / 2);
  } else if (quorum_target == null) {
    quorum_target = servers.length;
  }
  quorum_current = 0;
  randfiles = [];
  modified = false;
  return each(servers).parallel(true).run((function(_this) {
    return function(server, next) {
      var child, clear, count, rand, randfile, ref7, timedout;
      count = 0;
      rand = Date.now() + inc++;
      randfiles.push(randfile = options.randdir + "/" + rand);
      if (options.timeout) {
        timedout = false;
        clear = setTimeout(function() {
          timedout = true;
          return this.child().remove({
            destination: randfile
          });
        }, options.timeout);
      }
      if (typeof options.log === "function") {
        options.log("Start wait for " + server.host + ":" + server.port);
      }
      if ((ref7 = options.wait) != null) {
        ref7.call(_this, server);
      }
      child = _this.child();
      return child.execute({
        cmd: "count=0\nrandfile=\"" + randfile + "\"\nisopen=\"echo > /dev/tcp/" + server.host + "/" + server.port + "\"\ntouch \"$randfile\"\nwhile [[ -f \"$randfile\" ]] && ! `bash -c \"$isopen\"`; do\n  ((count++))\n  echo " + server.host + ":" + server.port + " attempt $count > /dev/fd/2 \n  sleep " + options.interval + "\ndone\nif [[ count -eq 0 ]]; then exit 3; fi",
        shy: true,
        code_skipped: 3
      }, function(err, executed) {
        var cmd, ref8;
        if (clear) {
          clearTimeout(clear);
        }
        if (!err && timedout) {
          err = new Error("Reached timeout " + options.timeout);
        }
        if (!err) {
          if ((ref8 = options.ready) != null) {
            ref8.call(_this, server, executed);
          }
        }
        if (executed) {
          modified = true;
        }
        if (typeof options.log === "function") {
          options.log("Finish wait for " + server.host + " " + server.port);
        }
        if (!err) {
          quorum_current++;
        }
        cmd = (function() {
          var len5, o, results;
          results = [];
          for (o = 0, len5 = randfiles.length; o < len5; o++) {
            randfile = randfiles[o];
            results.push("rm " + randfile + ";");
          }
          return results;
        })();
        return child.execute({
          cmd: cmd.join('\n'),
          shy: true,
          "if": quorum_current >= quorum_target
        }, function() {
          return next(err);
        });
      });
    };
  })(this)).then(function(err) {
    return callback(err, modified);
  });
};

each = require('each');
