// Generated by CoffeeScript 1.9.3
var each, inc, misc,
  slice = [].slice;

inc = 0;

module.exports = function(options, callback) {
  var extract_servers, host, i, j, k, len, len1, modified, port, quorum_current, quorum_target, randfiles, ref, ref1, ref2, ref3, server, servers;
  extract_servers = function(options) {
    var host, hosts, i, j, k, l, len, len1, len2, len3, m, port, ports, ref, ref1, ref2, ref3, servers;
    ref = ['host', 'hosts'];
    for (i = 0, len = ref.length; i < len; i++) {
      k = ref[i];
      if (options[k] == null) {
        options[k] = [];
      }
      if ((ref1 = typeof options[k]) !== 'string' && ref1 !== 'object') {
        throw error("Invalid option '" + options[k] + "'");
      }
      if (!Array.isArray(options[k])) {
        options[k] = [options[k]];
      }
    }
    hosts = slice.call(options.host).concat(slice.call(options.hosts));
    ref2 = ['port', 'ports'];
    for (j = 0, len1 = ref2.length; j < len1; j++) {
      k = ref2[j];
      if (options[k] == null) {
        options[k] = [];
      }
      if ((ref3 = typeof options[k]) !== 'string' && ref3 !== 'number' && ref3 !== 'object') {
        throw error("Invalid option '" + options[k] + "'");
      }
      if (!Array.isArray(options[k])) {
        options[k] = [options[k]];
      }
    }
    ports = slice.call(options.port).concat(slice.call(options.ports));
    servers = [];
    for (l = 0, len2 = hosts.length; l < len2; l++) {
      host = hosts[l];
      for (m = 0, len3 = ports.length; m < len3; m++) {
        port = ports[m];
        servers.push({
          host: host,
          port: port
        });
      }
    }
    return servers;
  };
  servers = extract_servers(options);
  ref = ['server', 'servers'];
  for (i = 0, len = ref.length; i < len; i++) {
    k = ref[i];
    if (options[k] == null) {
      options[k] = [];
    }
    if ((ref1 = typeof options[k]) !== 'string' && ref1 !== 'object') {
      throw error("Invalid option '" + options[k] + "'");
    }
    if (typeof options[k] === 'string') {
      ref2 = options[k].split(':'), host = ref2[0], port = ref2[1];
      options[k] = {
        host: host,
        port: port
      };
    }
    if (!Array.isArray(options[k])) {
      options[k] = [options[k]];
    }
    options[k] = misc.array.flatten(options[k]);
    ref3 = options[k];
    for (j = 0, len1 = ref3.length; j < len1; j++) {
      server = ref3[j];
      servers.push.apply(servers, extract_servers(server));
    }
  }
  if (!servers.length) {
    return callback();
  }
  if (options.randdir == null) {
    options.randdir = '/tmp';
  }
  if (options.interval == null) {
    options.interval = 2000;
  }
  options.interval = Math.round(options.interval / 1000);
  quorum_target = options.quorum;
  if (quorum_target && quorum_target === true) {
    quorum_target = Math.ceil(servers.length / 2);
  } else if (quorum_target == null) {
    quorum_target = servers.length;
  }
  quorum_current = 0;
  randfiles = [];
  modified = false;
  return each(servers).parallel(true).run((function(_this) {
    return function(server, next) {
      var child, clear, count, rand, randfile, ref4, timedout;
      count = 0;
      rand = Date.now() + inc++;
      randfiles.push(randfile = options.randdir + "/" + rand);
      if (options.timeout) {
        timedout = false;
        clear = setTimeout(function() {
          timedout = true;
          return this.child().remove({
            destination: randfile
          });
        }, options.timeout);
      }
      if (typeof options.log === "function") {
        options.log("Start wait for " + server.host + ":" + server.port);
      }
      if ((ref4 = options.wait) != null) {
        ref4.call(_this, server);
      }
      child = _this.child();
      return child.execute({
        cmd: "count=0\nrandfile=\"" + randfile + "\"\nisopen=\"echo > /dev/tcp/" + server.host + "/" + server.port + "\"\ntouch \"$randfile\"\nwhile [[ -f \"$randfile\" ]] && ! `bash -c \"$isopen\"`; do\n  ((count++))\n  echo " + server.host + ":" + server.port + " attempt $count > /dev/fd/2 \n  sleep " + options.interval + "\ndone\nif [[ count -eq 0 ]]; then exit 3; fi",
        shy: true,
        code_skipped: 3
      }, function(err, executed) {
        var cmd, ref5;
        if (clear) {
          clearTimeout(clear);
        }
        if (!err && timedout) {
          err = new Error("Reached timeout " + options.timeout);
        }
        if (!err) {
          if ((ref5 = options.ready) != null) {
            ref5.call(_this, server, executed);
          }
        }
        if (executed) {
          modified = true;
        }
        if (typeof options.log === "function") {
          options.log("Finish wait for " + server.host + " " + server.port);
        }
        if (!err) {
          quorum_current++;
        }
        cmd = (function() {
          var l, len2, results;
          results = [];
          for (l = 0, len2 = randfiles.length; l < len2; l++) {
            randfile = randfiles[l];
            results.push("rm " + randfile + ";");
          }
          return results;
        })();
        return child.execute({
          cmd: cmd.join('\n'),
          shy: true,
          "if": quorum_current >= quorum_target
        }, function() {
          return next(err);
        });
      });
    };
  })(this)).then(function(err) {
    return callback(err, modified);
  });
};

each = require('each');

misc = require('../misc');
