// Generated by CoffeeScript 1.9.1
module.exports = function(options, callback) {
  var cmd, exec_opts, flag, i, j, k, len, len1, opt, p, ref, ref1, ref2, ref3, ref4;
  if (options.image == null) {
    return callback(Error('Missing image'));
  }
  if (options.service == null) {
    options.service = true;
  }
  if (options.rm == null) {
    options.rm = !options.service;
  }
  if (options.service && options.rm) {
    return callback(Error('Invalid parameter, rm cannot be true if service is true'));
  }
  if (!((options.name != null) || options.rm)) {
    if (typeof options.log === "function") {
      options.log('[WARN] should specify a name if rm is false!');
    }
  }
  cmd = 'docker run';
  ref = {
    name: '--name',
    hostname: '-h',
    cpu_shares: '-c',
    cgroup_parent: '--cgroup-parent',
    cid_file: '--cidfile',
    blkio_weight: '--blkio-weight',
    cpuset_cpus: '--cpuset-cpus',
    entrypoint: '--entrypoint',
    ipc: '--ipc',
    log_driver: '--log-driver',
    memory: '-m',
    mac_address: '--mac-address',
    memory_swap: '--memory-swap',
    net: '--net',
    pid: '--pid',
    work_dir: '-w'
  };
  for (opt in ref) {
    flag = ref[opt];
    if (options[opt] != null) {
      cmd += " " + flag + " " + options[opt];
    }
  }
  cmd += options.service ? ' -d' : ' -t';
  ref1 = {
    rm: '--rm',
    publish_all: '-P',
    privileged: '--privileged',
    read_only: '--read-only'
  };
  for (opt in ref1) {
    flag = ref1[opt];
    if (options[opt]) {
      cmd += " " + flag;
    }
  }
  ref2 = {
    port: '-p',
    volume: '-v',
    device: '--device',
    label: '-l',
    label_file: '--label-file',
    expose: '--expose',
    env: '-e',
    env_file: '--env-file',
    dns: '--dns',
    dns_search: '--dns-search',
    volumes_from: '--volumes-from',
    cap_add: '--cap-add',
    cap_drop: '--cap-drop',
    ulimit: '--ulimit',
    add_host: '--add-host'
  };
  for (opt in ref2) {
    flag = ref2[opt];
    if (options[opt] != null) {
      if (typeof options[opt] === 'string' || 'number') {
        cmd += " " + flag + " " + options[opt];
      } else if (Array.isArray(options.port)) {
        ref3 = options[opt];
        for (i = 0, len = ref3.length; i < len; i++) {
          p = ref3[i];
          cmd += " " + flag + " " + p;
        }
      } else {
        callback(Error("Invalid parameter, typeof " + opt + " should be string or string array"));
      }
    }
  }
  cmd += " " + options.image;
  if (options.cmd) {
    cmd += " " + options.cmd;
  }
  exec_opts = {
    cmd: cmd
  };
  ref4 = ['ssh', 'log', 'stdout', 'stderr', 'cwd', 'code', 'code_skipped'];
  for (j = 0, len1 = ref4.length; j < len1; j++) {
    k = ref4[j];
    if (options[k] != null) {
      exec_opts[k] = options[k];
    }
  }
  return this.execute(exec_opts, function(err, executed, stdout, stderr) {
    return callback(err, executed, stdout, stderr);
  });
};
