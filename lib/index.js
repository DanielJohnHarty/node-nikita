// Generated by CoffeeScript 1.9.3
var conditions, each, registry, wrap,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
  slice = [].slice;

module.exports = function() {
  var afters, befores, call_callback, enrich_options, handler, intercept_before, j, jump_to_error, len, name, normalize_arguments, obj, option, properties, proto, ref, run, stack, store, todos;
  if (arguments.length === 2) {
    obj = arguments[0];
    obj.options = arguments[1];
  } else if (arguments.length === 1) {
    obj = {};
    obj.options = arguments[0];
  } else {
    obj = {};
    obj.options = {};
  }
  if (obj.registry == null) {
    obj.registry = {};
  }
  if (obj.propagated_options == null) {
    obj.propagated_options = [];
  }
  ref = module.exports.propagated_options;
  for (j = 0, len = ref.length; j < len; j++) {
    option = ref[j];
    obj.propagated_options.push(option);
  }
  store = {};
  properties = {};
  stack = [];
  todos = [];
  todos.err = null;
  todos.status = [];
  todos.throw_if_error = true;
  befores = [];
  afters = [];
  normalize_arguments = function(_arguments, type) {
    var arg, callback, copy, found_handler, handler, i, k, l, len1, len2, len3, len4, len5, len6, len7, m, multiple, n, o, options, opts, p, q, r, v;
    if (type == null) {
      type = 'call';
    }
    multiple = false;
    handler = null;
    callback = null;
    if (typeof _arguments[0] === 'function') {
      options = [{}];
    } else if (Array.isArray(_arguments[0])) {
      multiple = true;
      options = _arguments[0];
      options = (function() {
        var l, len1, ref1, results;
        ref1 = _arguments[0];
        results = [];
        for (l = 0, len1 = ref1.length; l < len1; l++) {
          opts = ref1[l];
          copy = {};
          for (k in opts) {
            v = opts[k];
            copy[k] = v;
          }
          results.push(copy);
        }
        return results;
      })();
    } else if (_arguments[0] && typeof _arguments[0] === 'object') {
      arg = _arguments[0];
      options = {};
      for (k in arg) {
        v = arg[k];
        options[k] = v;
      }
      options = [options];
    } else {
      options = [
        {
          argument: _arguments[0]
        }
      ];
    }
    found_handler = options.every(function(opts) {
      return !!opts.handler;
    });
    for (i = l = 0, len1 = _arguments.length; l < len1; i = ++l) {
      arg = _arguments[i];
      if (i === 0 && typeof arg !== 'function') {
        continue;
      }
      if (typeof arg === 'function') {
        if (handler || (found_handler && options.length !== 0)) {
          callback = arg;
        } else {
          handler = arg;
        }
      } else if (Array.isArray(arg)) {
        console.log('NOT SUPPORTED');
      } else if (typeof arg === 'object') {
        for (m = 0, len2 = options.length; m < len2; m++) {
          option = options[m];
          for (k in arg) {
            v = arg[k];
            option[k] = v;
          }
        }
      } else {
        for (n = 0, len3 = options.length; n < len3; n++) {
          option = options[n];
          options.argument = arg;
        }
      }
    }
    if ((callback != null ? callback.length : void 0) > 2) {
      for (o = 0, len4 = options.length; o < len4; o++) {
        opts = options[o];
        opts.user_args = true;
      }
    }
    for (p = 0, len5 = options.length; p < len5; p++) {
      opts = options[p];
      if (opts.store == null) {
        opts.store = store;
      }
    }
    for (q = 0, len6 = options.length; q < len6; q++) {
      opts = options[q];
      if (opts.type == null) {
        opts.type = type;
      }
    }
    if (handler) {
      for (r = 0, len7 = options.length; r < len7; r++) {
        opts = options[r];
        if (opts.handler == null) {
          opts.handler = handler;
        }
      }
    }
    return {
      type: type,
      options: options,
      multiple: multiple,
      callback: callback
    };
  };
  enrich_options = function(user_options) {
    var global_options, k, l, len1, len2, len3, local_options, local_opts, m, n, options, opts, parent_options, v;
    global_options = obj.options;
    parent_options = todos.options;
    local_options = user_options;
    options = [];
    for (l = 0, len1 = local_options.length; l < len1; l++) {
      local_opts = local_options[l];
      if ((local_opts != null) && typeof local_opts !== 'object') {
        local_opts = {
          argument: local_opts
        };
      }
      opts = {};
      for (k in local_opts) {
        v = local_opts[k];
        opts[k] = local_opts[k];
      }
      options.push(opts);
    }
    for (k in parent_options) {
      v = parent_options[k];
      for (m = 0, len2 = options.length; m < len2; m++) {
        opts = options[m];
        if (opts[k] === void 0 && indexOf.call(obj.propagated_options, k) >= 0) {
          opts[k] = v;
        }
      }
    }
    for (k in global_options) {
      v = global_options[k];
      for (n = 0, len3 = options.length; n < len3; n++) {
        opts = options[n];
        if (opts[k] === void 0) {
          opts[k] = v;
        }
      }
    }
    return options;
  };
  intercept_before = function(options, callback) {
    if (options.intercept_before) {
      return callback();
    }
    return each(befores).run(function(before, next) {
      var action, k, ref1, v;
      ref1 = before.event;
      for (k in ref1) {
        v = ref1[k];
        if (v !== options[k]) {
          return next();
        }
      }
      action = {};
      for (k in before) {
        v = before[k];
        action[k] = v;
      }
      action.options = [
        {
          intercept_before: true
        }
      ];
      for (k in options) {
        v = options[k];
        if (k === 'handler') {
          action.options[0][k] = before.options[0][k];
        } else {
          action.options[0][k] = v;
        }
      }
      return run(action, next);
    }).then(callback);
  };
  call_callback = function(fn, args) {
    var err, mtodos;
    stack.unshift(todos);
    todos = [];
    todos.err = null;
    todos.status = [];
    todos.throw_if_error = true;
    try {
      fn.apply(obj, args);
    } catch (_error) {
      err = _error;
      todos = stack.shift();
      jump_to_error(err);
      return run();
    }
    mtodos = todos;
    todos = stack.shift();
    if (mtodos.length) {
      return todos.unshift.apply(todos, mtodos);
    }
  };
  jump_to_error = function(err) {
    if (todos == null) {
      throw err;
    }
    while (todos[0] && todos[0].type !== 'then') {
      todos.shift();
    }
    return todos.err = err;
  };
  run = function(action, callback) {
    var err, ref1, run_callback, status;
    if (!action) {
      action = todos.shift();
    }
    if (!action) {
      if (todos.err && todos.throw_if_error) {
        throw todos.err;
      }
      return;
    }
    if (action.type === 'then') {
      err = todos.err, status = todos.status;
      status = status.some(function(status) {
        return !!status;
      });
      todos.err = null;
      todos.status = [];
      todos.throw_if_error = true;
      if ((ref1 = action.handler) != null) {
        ref1.call(obj, err, status);
      }
      run();
      return;
    }
    action.options = enrich_options(action.options);
    run_callback = function(err, throw_error, statuses, user_args) {
      var callback_args, ref2, status_callback;
      if (user_args.length === 0) {
        user_args.length = 2;
      }
      if (todos.length === 0) {
        todos = stack.shift();
      }
      if (err && throw_error) {
        jump_to_error(err);
      }
      if (err && action.callback) {
        todos.throw_if_error = false;
      }
      status_callback = statuses.some(function(status) {
        return !!status;
      });
      statuses = statuses.some(function(status, i) {
        if (action.options[i].shy) {
          return false;
        }
        return !!status;
      });
      if (!action.multiple) {
        user_args = user_args[0];
      }
      callback_args = [err, status_callback].concat(slice.call(user_args));
      todos.status[0] = statuses && !action.options.shy;
      if (action.callback) {
        call_callback(action.callback, callback_args);
      }
      if ((ref2 = action.options[0]) != null ? ref2.relax : void 0) {
        err = null;
      }
      if (callback) {
        callback(err, statuses);
      }
      return run();
    };
    todos.status.unshift(void 0);
    stack.unshift(todos);
    todos = [];
    todos.err = null;
    todos.status = [];
    todos.throw_if_error = true;
    return wrap.options(action.options, function(err) {
      var options, statuses, throw_error, user_args;
      statuses = [];
      user_args = (function() {
        var l, len1, ref2, results;
        ref2 = action.options;
        results = [];
        for (l = 0, len1 = ref2.length; l < len1; l++) {
          options = ref2[l];
          results.push([]);
        }
        return results;
      })();
      throw_error = void 0;
      return each(action.options).run(function(options, index, next) {
        var copy, k, v;
        copy = {};
        for (k in options) {
          v = options[k];
          copy[k] = v;
        }
        options = copy;
        return intercept_before(options, function(err) {
          var handler, relax;
          relax = function(e) {
            if (e && !options.relax) {
              throw_error = true;
            }
            return next(e);
          };
          if (err) {
            return relax(err);
          }
          handler = options.handler;
          options.handler = void 0;
          return conditions.all(obj, options, function(err) {
            statuses.push(false);
            return relax(err);
          }, function() {
            var e, status_sync, wait_children;
            for (k in options) {
              v = options[k];
              if (/^if.*/.test(k) || /^not_if.*/.test(k)) {
                delete options[k];
              }
            }
            todos.options = options;
            try {
              if (handler.length === 2) {
                return handler.call(obj, options, function() {
                  var arg, args, err, i, l, len1, status;
                  err = arguments[0], status = arguments[1], args = 3 <= arguments.length ? slice.call(arguments, 2) : [];
                  statuses.push(status);
                  for (i = l = 0, len1 = args.length; l < len1; i = ++l) {
                    arg = args[i];
                    user_args[index].push(arg);
                  }
                  return setImmediate(function() {
                    return relax(err);
                  });
                });
              } else {
                handler.call(obj, options);
                status_sync = false;
                wait_children = function() {
                  if (!todos.length) {
                    statuses.push(status_sync);
                    return setImmediate(relax);
                  }
                  return run(todos.shift(), function(err, status) {
                    if (err) {
                      return relax(err);
                    }
                    if (status) {
                      status_sync = true;
                    }
                    return wait_children();
                  });
                };
                return wait_children();
              }
            } catch (_error) {
              e = _error;
              return relax(e);
            }
          });
        });
      }).then(function(err) {
        return run_callback(err, throw_error, statuses, user_args);
      });
    });
  };
  properties.child = {
    get: function() {
      return function() {
        return module.exports(obj.options);
      };
    }
  };
  properties.then = {
    get: function() {
      return function() {
        todos.push({
          type: 'then',
          handler: arguments[0]
        });
        if (todos.length === 1) {
          setImmediate(run);
        }
        return obj;
      };
    }
  };
  properties.call = {
    get: function() {
      return function() {
        var args;
        args = [].slice.call(arguments);
        todos.push(normalize_arguments(args));
        if (todos.length === 1) {
          setImmediate(run);
        }
        return obj;
      };
    }
  };
  properties.before = {
    get: function() {
      return function() {
        var action, event;
        event = arguments[0];
        if (typeof event === 'string') {
          event = {
            type: event
          };
        }
        action = normalize_arguments([arguments[1]], 'before');
        action.event = event;
        befores.push(action);
        return obj;
      };
    }
  };
  properties.after = {
    get: function() {
      return function() {
        afters.push({
          type: 'after',
          options: arguments
        });
        return obj;
      };
    }
  };
  properties.status = {
    get: function() {
      return function(index) {
        if (arguments.length === 0) {
          return stack[0].status.some(function(status) {
            return !!status;
          });
        } else {
          return stack[0].status[Math.abs(index)];
        }
      };
    }
  };
  proto = Object.defineProperties(obj, properties);
  Object.defineProperty(obj, 'register', {
    get: function() {
      return function(name, handler) {
        var is_registered_locally;
        is_registered_locally = obj.registered(name, true);
        if (handler === null || handler === false) {
          if (is_registered_locally) {
            delete obj.registry[name];
            delete obj[name];
          } else if (module.exports.registered(name)) {
            throw Error('Unregister a global function from local context');
          }
          return obj;
        }
        if (is_registered_locally) {
          throw Error("Function already defined '" + name + "'");
        }
        obj.registry[name] = handler;
        return Object.defineProperty(obj, name, {
          configurable: true,
          get: function() {
            return function() {
              var arg, args, i, l, len1;
              args = [].slice.call(arguments);
              for (i = l = 0, len1 = args.length; l < len1; i = ++l) {
                arg = args[i];
                if (typeof arg === 'function') {
                  args.splice(i, 0, obj.registry[name] || registry[name]);
                  break;
                }
                if (i + 1 === args.length) {
                  args.push(obj.registry[name] || registry[name]);
                }
              }
              todos.push(normalize_arguments(args, name));
              if (todos.length === 1) {
                setImmediate(run);
              }
              return obj;
            };
          }
        });
      };
    }
  });
  Object.defineProperty(obj, 'registered', {
    get: function() {
      return function(name, local_only) {
        var global, local;
        if (local_only == null) {
          local_only = false;
        }
        global = Object.prototype.hasOwnProperty.call(module.exports, name);
        local = Object.prototype.hasOwnProperty.call(obj, name);
        if (local_only) {
          return local;
        } else {
          return global || local;
        }
      };
    }
  });
  for (name in registry) {
    handler = registry[name];
    obj.register(name, handler);
  }
  return obj;
};

module.exports.propagated_options = ['ssh', 'log', 'stdout', 'stderr'];

registry = require('./misc/registry');

(function() {
  var handler, name, register, registered;
  register = module.exports.register = function(name, handler, api) {
    if (handler === null || handler === false) {
      if (registered(name)) {
        delete registry[name];
      }
      if (registered(name)) {
        delete module.exports[name];
      }
      return module.exports;
    }
    if (registered(name)) {
      throw Error("Function already defined '" + name + "'");
    }
    if (!api) {
      registry[name] = handler;
    }
    return Object.defineProperty(module.exports, name, {
      configurable: true,
      get: function() {
        return module.exports()[name];
      }
    });
  };
  registered = module.exports.registered = function(name) {
    return Object.prototype.hasOwnProperty.call(module.exports, name);
  };
  for (name in registry) {
    handler = registry[name];
    register(name, handler);
  }
  register('before', module.exports().before, true);
  register('call', module.exports().call, true);
  return register('then', module.exports().then, true);
})();

conditions = require('./misc/conditions');

wrap = require('./misc/wrap');

each = require('each');
