// Generated by CoffeeScript 1.10.0
var EventEmitter, conditions, domain, each, registry, todos_create, todos_reset, wrap,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

module.exports = function() {
  var _run_, afters, befores, call_callback, depth, domain_on_error, enrich_options, handle_multiple_call, handler, intercept_after, intercept_before, j, jump_to_error, killed, len, listeners, name, normalize_options, obj, option, properties, proto, ref, ref1, run, stack, store, todos;
  if (arguments.length === 2) {
    obj = arguments[0];
    obj.options = arguments[1];
  } else if (arguments.length === 1) {
    obj = new EventEmitter;
    obj.options = arguments[0];
  } else {
    obj = new EventEmitter;
    obj.options = {};
  }
  if (obj.registry == null) {
    obj.registry = {};
  }
  if (obj.propagated_options == null) {
    obj.propagated_options = [];
  }
  ref = module.exports.propagated_options;
  for (j = 0, len = ref.length; j < len; j++) {
    option = ref[j];
    obj.propagated_options.push(option);
  }
  store = {};
  properties = {};
  listeners = {};
  stack = [];
  todos = todos_create();
  befores = [];
  afters = [];
  depth = 0;
  killed = false;
  if (obj.options.domain === true) {
    obj.options.domain = domain.create();
  }
  domain_on_error = function(err) {
    err.message = "Invalid State Error [" + err.message + "]";
    return handle_multiple_call(err);
  };
  if ((ref1 = obj.options.domain) != null) {
    ref1.on('error', domain_on_error);
  }
  normalize_options = function(_arguments, type, enrich) {
    var a, arg, callback, empty, handler, i, k, l, len1, len2, len3, len4, m, n, options, opts, p, ref2, v;
    if (enrich == null) {
      enrich = true;
    }
    empty = false;
    handler = null;
    callback = null;
    options = [];
    for (l = 0, len1 = _arguments.length; l < len1; l++) {
      arg = _arguments[l];
      if (typeof arg === 'function') {
        if (!handler) {
          handler = arg;
        } else if (!callback) {
          callback = arg;
        } else {
          throw Error("Invalid third function argument");
        }
      } else if (Array.isArray(arg)) {
        if (arg.length === 0) {
          empty = true;
        }
        for (m = 0, len2 = arg.length; m < len2; m++) {
          a = arg[m];
          if (!(typeof a === 'object' && !Array.isArray(a) && a !== null)) {
            a = {
              argument: a
            };
          }
          options.push(a);
        }
      } else {
        if (typeof arg !== 'object' && arg !== null) {
          arg = {
            argument: arg
          };
        }
        if (options.length === 0) {
          options.push(arg);
        } else {
          for (n = 0, len3 = options.length; n < len3; n++) {
            opts = options[n];
            for (k in arg) {
              v = arg[k];
              opts[k] = v;
            }
          }
        }
      }
    }
    if (options.length === 0 && empty) {
      return options;
    }
    if (options.length === 0) {
      options.push({});
    }
    if (options.length && options.filter(function(opts) {
      return !opts.handler;
    }).length === 0) {
      callback = handler;
      handler = null;
    }
    for (i = p = 0, len4 = options.length; p < len4; i = ++p) {
      opts = options[i];
      options[i] = {};
      for (k in opts) {
        v = opts[k];
        options[i][k] = v;
      }
      opts = options[i];
      if (type) {
        opts.type = type;
      }
      if (handler) {
        if (opts.handler == null) {
          opts.handler = handler;
        }
      }
      if (callback) {
        if (opts.callback == null) {
          opts.callback = callback;
        }
      }
      if (enrich && ((ref2 = opts.callback) != null ? ref2.length : void 0) > 2) {
        opts.user_args = true;
      }
      if (enrich && store) {
        if (opts.store == null) {
          opts.store = store;
        }
      }
      if (opts.debug) {
        if (opts.log == null) {
          opts.log = function(log) {
            return process.stdout.write("[" + log.level + " " + log.time + "] " + log.message + "\n");
          };
        }
        if (opts.stdout == null) {
          opts.stdout = process.stdout;
        }
        if (opts.stderr == null) {
          opts.stderr = process.stderr;
        }
      }
    }
    return options;
  };
  enrich_options = function(user_options) {
    var _log, emit, global_options, k, local_options, options, parent_options, ref2, v;
    user_options.enriched = true;
    global_options = obj.options;
    parent_options = todos.options;
    local_options = user_options;
    options = {};
    for (k in local_options) {
      v = local_options[k];
      options[k] = local_options[k];
    }
    for (k in parent_options) {
      v = parent_options[k];
      if (options[k] === void 0 && indexOf.call(obj.propagated_options, k) >= 0) {
        options[k] = v;
      }
    }
    for (k in global_options) {
      v = global_options[k];
      if (options[k] === void 0) {
        options[k] = v;
      }
    }
    emit = function(log) {
      var l, len1, listener, ref2, results;
      ref2 = listeners[log.type] != null;
      results = [];
      for (l = 0, len1 = ref2.length; l < len1; l++) {
        listener = ref2[l];
        results.push(listener.call(null, log));
      }
      return results;
    };
    if (!((ref2 = options.log) != null ? ref2.dont : void 0)) {
      _log = options.log;
    }
    options.log = function(log) {
      var args, file, frame, line, method, path, stackTrace;
      if (typeof log === 'string') {
        log = {
          message: log
        };
      }
      if (log.level == null) {
        log.level = 'INFO';
      }
      if (log.time == null) {
        log.time = Date.now();
      }
      if (log.module == null) {
        log.module = void 0;
      }
      if (log.header_depth == null) {
        log.header_depth = depth;
      }
      if (log.total_depth == null) {
        log.total_depth = stack.length;
      }
      if (log.type == null) {
        log.type = 'text';
      }
      args = 1 <= arguments.length ? [].slice.call(arguments, 0) : [];
      stackTrace = require('stack-trace');
      path = require('path');
      frame = stackTrace.get()[1];
      file = path.basename(frame.getFileName());
      line = frame.getLineNumber();
      method = frame.getFunctionName();
      log.file = file;
      log.line = line;
      args.unshift("" + file + ":" + line + " in " + method + "()");
      if (typeof _log === "function") {
        _log(log);
      }
      return typeof obj.emit === "function" ? obj.emit(log.type, log) : void 0;
    };
    options.log.dont = true;
    return options;
  };
  intercept_before = function(target_options, callback) {
    if (target_options.intercept_before) {
      return callback();
    }
    return each(befores).run(function(before, next) {
      var k, options, v;
      for (k in before) {
        v = before[k];
        if (k === 'handler') {
          continue;
        }
        if (v !== target_options[k]) {
          return next();
        }
      }
      options = {
        intercept_before: true
      };
      for (k in before) {
        v = before[k];
        options[k] = v;
      }
      for (k in target_options) {
        v = target_options[k];
        if (k === 'handler' || k === 'callback') {
          continue;
        }
        if (options[k] == null) {
          options[k] = v;
        }
      }
      return run(options, next);
    }).then(callback);
  };
  intercept_after = function(target_options, args, callback) {
    if (target_options.intercept_after) {
      return callback();
    }
    return each(afters).run(function(after, next) {
      var k, options, v;
      for (k in after) {
        v = after[k];
        if (k === 'handler') {
          continue;
        }
        if (v !== target_options[k]) {
          return next();
        }
      }
      options = {
        intercept_after: true
      };
      for (k in after) {
        v = after[k];
        options[k] = v;
      }
      for (k in target_options) {
        v = target_options[k];
        if (k === 'handler' || k === 'callback') {
          continue;
        }
        if (options[k] == null) {
          options[k] = v;
        }
      }
      options.callback_arguments = args;
      return run(options, next);
    }).then(callback);
  };
  call_callback = function(fn, args) {
    var err, mtodos;
    stack.unshift(todos);
    todos = todos_create();
    try {
      fn.apply(obj, args);
    } catch (error) {
      err = error;
      todos = stack.shift();
      jump_to_error(err);
      return run();
    }
    mtodos = todos;
    todos = stack.shift();
    if (mtodos.length) {
      return todos.unshift.apply(todos, mtodos);
    }
  };
  handle_multiple_call = function(err) {
    killed = true;
    while (stack.length) {
      todos = stack.shift();
    }
    jump_to_error(err);
    return run();
  };
  jump_to_error = function(err) {
    if (todos == null) {
      throw err;
    }
    while (todos[0] && todos[0].type !== 'then') {
      todos.shift();
    }
    return todos.err = err;
  };
  _run_ = function() {
    if (obj.options.domain) {
      return obj.options.domain.run(run);
    } else {
      return run();
    }
  };
  run = function(options, callback) {
    var err, ref2, ref3, status;
    if (!options) {
      options = todos.shift();
    }
    if (!options) {
      if (stack.length === 0) {
        if ((ref2 = obj.options.domain) != null) {
          ref2.removeListener('error', domain_on_error);
        }
      }
      if (callback) {
        callback(todos.err);
      } else {
        if (stack.length === 0 && todos.err && todos.throw_if_error) {
          throw todos.err;
        }
      }
      return;
    }
    if (options.type === 'then') {
      err = todos.err, status = todos.status;
      status = status.some(function(status) {
        return !!status;
      });
      todos_reset(todos);
      if ((ref3 = options.handler) != null) {
        ref3.call(obj, err, status);
      }
      run();
      return;
    }
    if (killed) {
      return;
    }
    options = enrich_options(options);
    if (options.header) {
      depth++;
    }
    if (options.header) {
      options.log({
        message: options.header,
        type: 'header',
        depth: depth
      });
    }
    if (options.type === 'end') {
      return conditions.all(obj, options, function(err) {
        if (callback) {
          callback(err);
        }
        return run();
      }, function() {
        while (todos[0] && todos[0].type !== 'then') {
          todos.shift();
        }
        if (callback) {
          callback(err);
        }
        return run();
      });
    }
    todos.status.unshift(void 0);
    stack.unshift(todos);
    todos = todos_create();
    return wrap.options(options, function(err) {
      var copy, k, v;
      copy = {};
      for (k in options) {
        v = options[k];
        copy[k] = v;
      }
      options = copy;
      return intercept_before(options, function(err) {
        var exec_callback, options_callback, options_handler;
        exec_callback = function(args) {
          if (killed) {
            return;
          }
          if (!args[0]) {
            args[0] = void 0;
          }
          args[1] = !!args[1];
          if (todos.length === 0) {
            todos = stack.shift();
          }
          if (args[0] && !options.relax) {
            jump_to_error(args[0]);
          }
          if (args[0] && options_callback) {
            todos.throw_if_error = false;
          }
          todos.status[0] = args[1] && !options.shy;
          if (options_callback) {
            call_callback(options_callback, args);
          }
          if (options.relax) {
            args[0] = null;
          }
          if (options.header) {
            depth--;
          }
          if (callback) {
            callback(args[0], args[1]);
          }
          return run();
        };
        if (err) {
          return exec_callback([err]);
        }
        options_handler = options.handler;
        options.handler = void 0;
        options_callback = options.callback;
        options.callback = void 0;
        return conditions.all(obj, options, function(err) {
          return exec_callback([err]);
        }, function() {
          var called, status_sync, wait_children;
          for (k in options) {
            v = options[k];
            if (/^if.*/.test(k) || /^unless.*/.test(k)) {
              delete options[k];
            }
          }
          todos.options = options;
          called = false;
          try {
            if (options_handler.length === 2) {
              return options_handler.call(obj, options, function() {
                var args;
                if (killed) {
                  return;
                }
                if (called) {
                  return handle_multiple_call(Error('Multiple call detected'));
                }
                called = true;
                args = [].slice.call(arguments, 0);
                return setImmediate(function() {
                  return intercept_after(options, args, function(err) {
                    return exec_callback(err ? [err] : args);
                  });
                });
              });
            } else {
              options_handler.call(obj, options);
              if (killed) {
                return;
              }
              if (called) {
                return handle_multiple_call(Error('Multiple call detected'));
              }
              called = true;
              status_sync = false;
              wait_children = function() {
                if (!todos.length) {
                  return setImmediate(function() {
                    var args;
                    args = [null, status_sync];
                    return intercept_after(options, args, function(err) {
                      return exec_callback(err ? [err] : args);
                    });
                  });
                }
                options = todos.shift();
                return run(options, function(err, status) {
                  if (err) {
                    return exec_callback([err]);
                  }
                  if (status && !options.shy) {
                    status_sync = true;
                  }
                  return wait_children();
                });
              };
              return wait_children();
            }
          } catch (error) {
            err = error;
            return exec_callback([err]);
          }
        });
      });
    });
  };
  properties.child = {
    get: function() {
      return function() {
        return module.exports(obj.options);
      };
    }
  };
  properties.then = {
    get: function() {
      return function() {
        todos.push({
          type: 'then',
          handler: arguments[0]
        });
        if (todos.length === 1) {
          setImmediate(_run_);
        }
        return obj;
      };
    }
  };
  properties.end = {
    get: function() {
      return function() {
        var args, l, len1, options, opts;
        args = [].slice.call(arguments);
        options = normalize_options(args, 'end');
        for (l = 0, len1 = options.length; l < len1; l++) {
          opts = options[l];
          todos.push(opts);
        }
        if (todos.length === options.length) {
          setImmediate(_run_);
        }
        return obj;
      };
    }
  };
  properties.call = {
    get: function() {
      return function() {
        var args, l, len1, options, opts;
        args = [].slice.call(arguments);
        options = normalize_options(args, 'call');
        for (l = 0, len1 = options.length; l < len1; l++) {
          opts = options[l];
          todos.push(opts);
        }
        if (todos.length === options.length) {
          setImmediate(_run_);
        }
        return obj;
      };
    }
  };
  properties.before = {
    get: function() {
      return function() {
        var l, len1, options, opts;
        if (typeof arguments[0] === 'string') {
          arguments[0] = {
            type: arguments[0]
          };
        }
        options = normalize_options(arguments, null, false);
        for (l = 0, len1 = options.length; l < len1; l++) {
          opts = options[l];
          if (typeof opts.handler !== 'function') {
            throw Error("Invalid handler " + (JSON.stringify(opts.handler)));
          }
          befores.push(opts);
        }
        return obj;
      };
    }
  };
  properties.after = {
    get: function() {
      return function() {
        var l, len1, options, opts;
        if (typeof arguments[0] === 'string') {
          arguments[0] = {
            type: arguments[0]
          };
        }
        options = normalize_options(arguments, null, false);
        for (l = 0, len1 = options.length; l < len1; l++) {
          opts = options[l];
          if (typeof opts.handler !== 'function') {
            throw Error("Invalid handler " + (JSON.stringify(opts.handler)));
          }
          afters.push(opts);
        }
        return obj;
      };
    }
  };
  properties.status = {
    get: function() {
      return function(index) {
        var value;
        if (arguments.length === 0) {
          return stack[0].status.some(function(status) {
            return !!status;
          });
        } else if (index === false) {
          value = stack[0].status.some(function(status) {
            return !!status;
          });
          stack[0].status = stack[0].status.map(function() {
            return false;
          });
          return value;
        } else if (index === true) {
          value = stack[0].status.some(function(status) {
            return !!status;
          });
          stack[0].status = stack[0].status.map(function() {
            return true;
          });
          return value;
        } else {
          return stack[0].status[Math.abs(index)];
        }
      };
    }
  };
  proto = Object.defineProperties(obj, properties);
  Object.defineProperty(obj, 'register', {
    get: function() {
      return function(name, handler) {
        var is_registered_locally;
        is_registered_locally = obj.registered(name, true);
        if (handler === null || handler === false) {
          if (is_registered_locally) {
            delete obj.registry[name];
            delete obj[name];
          } else if (module.exports.registered(name)) {
            throw Error('Unregister a global function from local context');
          }
          return obj;
        }
        if (is_registered_locally) {
          throw Error("Function already defined '" + name + "'");
        }
        obj.registry[name] = handler;
        return Object.defineProperty(obj, name, {
          configurable: true,
          get: function() {
            return function() {
              var args, l, len1, options, opts;
              args = [].slice.call(arguments);
              args.unshift(obj.registry[name]);
              options = normalize_options(args, name);
              for (l = 0, len1 = options.length; l < len1; l++) {
                opts = options[l];
                todos.push(opts);
              }
              if (todos.length === options.length) {
                setImmediate(_run_);
              }
              return obj;
            };
          }
        });
      };
    }
  });
  Object.defineProperty(obj, 'registered', {
    get: function() {
      return function(name, local_only) {
        var global, local;
        if (local_only == null) {
          local_only = false;
        }
        global = Object.prototype.hasOwnProperty.call(module.exports, name);
        local = Object.prototype.hasOwnProperty.call(obj, name);
        if (local_only) {
          return local;
        } else {
          return global || local;
        }
      };
    }
  });
  for (name in registry) {
    handler = registry[name];
    obj.register(name, handler);
  }
  return obj;
};

module.exports.propagated_options = ['ssh', 'log', 'stdout', 'stderr'];

todos_create = function() {
  var todos;
  todos = [];
  todos_reset(todos);
  return todos;
};

todos_reset = function(todos) {
  todos.err = null;
  todos.status = [];
  return todos.throw_if_error = true;
};

domain = require('domain');

EventEmitter = require('events').EventEmitter;

registry = require('./misc/registry');

(function() {
  var handler, name, register, registered;
  register = module.exports.register = function(name, handler, api) {
    if (handler === null || handler === false) {
      if (registered(name)) {
        delete registry[name];
      }
      if (registered(name)) {
        delete module.exports[name];
      }
      return module.exports;
    }
    if (registered(name)) {
      throw Error("Function already defined '" + name + "'");
    }
    if (!api) {
      registry[name] = handler;
    }
    return Object.defineProperty(module.exports, name, {
      configurable: true,
      get: function() {
        return module.exports()[name];
      }
    });
  };
  registered = module.exports.registered = function(name) {
    return Object.prototype.hasOwnProperty.call(module.exports, name);
  };
  for (name in registry) {
    handler = registry[name];
    register(name, handler);
  }
  register('end', module.exports().end, true);
  register('call', module.exports().call, true);
  register('before', module.exports().before, true);
  register('after', module.exports().after, true);
  register('then', module.exports().then, true);
  return module.exports.on = function() {
    var o, obj;
    obj = module.exports();
    return o = obj.on.apply(obj, arguments);
  };
})();

each = require('each');

conditions = require('./misc/conditions');

wrap = require('./misc/wrap');
