// Generated by CoffeeScript 1.9.1
var handler, name, register, registered, registry, wrap,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
  slice = [].slice;

module.exports = function() {
  var afters, call_async, call_callback, call_sync, enrich_options, handler, j, jump_to_error, len, name, normalize_arguments, obj, option, properties, proto, ref, run, stack, todos;
  if (arguments.length === 2) {
    obj = arguments[0];
    obj.options = arguments[1];
  } else if (arguments.length === 1) {
    obj = {};
    obj.options = arguments[0];
  } else {
    obj = {};
    obj.options = {};
  }
  if (obj.registry == null) {
    obj.registry = {};
  }
  if (obj.propagated_options == null) {
    obj.propagated_options = [];
  }
  ref = module.exports.propagated_options;
  for (j = 0, len = ref.length; j < len; j++) {
    option = ref[j];
    obj.propagated_options.push(option);
  }
  properties = {};
  stack = [];
  todos = [];
  todos.err = null;
  todos.status = [];
  todos.throw_if_error = true;
  afters = [];
  normalize_arguments = function(_arguments, type) {
    var arg, callback, handler, i, is_array, k, l, len1, len2, len3, len4, m, n, o, options, v;
    if (type == null) {
      type = 'call';
    }
    is_array = false;
    handler = null;
    callback = null;
    if (typeof _arguments[0] === 'function') {
      options = [{}];
    } else if (Array.isArray(_arguments[0])) {
      is_array = true;
      options = _arguments[0];
    } else if (_arguments[0] && typeof _arguments[0] === 'object') {
      options = [_arguments[0]];
    } else {
      options = [
        {
          argument: _arguments[0]
        }
      ];
    }
    for (l = 0, len1 = options.length; l < len1; l++) {
      option = options[l];
      option.type = type;
    }
    for (i = m = 0, len2 = _arguments.length; m < len2; i = ++m) {
      arg = _arguments[i];
      if (i === 0 && typeof arg !== 'function') {
        continue;
      }
      if (typeof arg === 'function') {
        if (handler) {
          callback = arg;
        } else {
          handler = arg;
        }
      } else if (Array.isArray(arg)) {
        console.log('NOT SUPPORTED');
      } else if (typeof arg === 'object') {
        for (n = 0, len3 = options.length; n < len3; n++) {
          option = options[n];
          for (k in arg) {
            v = arg[k];
            option[k] = v;
          }
        }
      } else {
        for (o = 0, len4 = options.length; o < len4; o++) {
          option = options[o];
          options.argument = arg;
        }
      }
    }
    if (!is_array) {
      options = options[0];
    }
    return {
      type: type,
      options: options,
      handler: handler,
      callback: callback
    };
  };
  enrich_options = function(user_options) {
    var global_options, k, l, len1, len2, len3, local_options, local_options_array, local_opts, m, n, options, opts, parent_options, v;
    global_options = obj.options;
    parent_options = todos.options;
    local_options_array = Array.isArray(user_options);
    local_options = user_options;
    if (!local_options_array) {
      local_options = [local_options];
    }
    options = [];
    for (l = 0, len1 = local_options.length; l < len1; l++) {
      local_opts = local_options[l];
      if ((local_opts != null) && typeof local_opts !== 'object') {
        local_opts = {
          argument: local_opts
        };
      }
      opts = {};
      for (k in local_opts) {
        v = local_opts[k];
        opts[k] = local_opts[k];
      }
      options.push(opts);
    }
    for (k in parent_options) {
      v = parent_options[k];
      for (m = 0, len2 = options.length; m < len2; m++) {
        opts = options[m];
        if (opts[k] === void 0 && indexOf.call(obj.propagated_options, k) >= 0) {
          opts[k] = v;
        }
      }
    }
    for (k in global_options) {
      v = global_options[k];
      for (n = 0, len3 = options.length; n < len3; n++) {
        opts = options[n];
        if (opts[k] === void 0) {
          opts[k] = v;
        }
      }
    }
    if (!local_options_array) {
      options = options[0];
    }
    if (options == null) {
      options = {};
    }
    return options;
  };
  call_callback = function(fn, args) {
    var err, mtodos;
    stack.unshift(todos);
    todos = [];
    todos.err = null;
    todos.status = [];
    todos.throw_if_error = true;
    try {
      fn.apply(obj, args);
    } catch (_error) {
      err = _error;
      todos = stack.shift();
      jump_to_error(err);
      return run();
    }
    mtodos = todos;
    todos = stack.shift();
    if (mtodos.length) {
      return todos.unshift.apply(todos, mtodos);
    }
  };
  call_sync = function(action) {
    var err, mtodos, options, status;
    options = enrich_options(action.options);
    todos.status.unshift(void 0);
    stack.unshift(todos);
    todos = [];
    todos.err = null;
    todos.status = [];
    todos.throw_if_error = true;
    try {
      status = action.handler.apply(obj, [options]);
    } catch (_error) {
      err = _error;
      todos = stack.shift();
      jump_to_error(err);
      return run();
    }
    mtodos = todos;
    todos = stack.shift();
    if (mtodos.length) {
      todos.unshift.apply(todos, mtodos);
    }
    return todos.status.unshift(status);
  };
  call_async = function(action) {
    var callback, err, finish, options, status_action, status_callback;
    options = enrich_options(action.options);
    callback = action.callback;
    try {
      todos.status.unshift(void 0);
      stack.unshift(todos);
      todos = [];
      todos.err = null;
      todos.status = [];
      todos.throw_if_error = true;
      status_callback = [];
      status_action = [];
      finish = function(err) {
        var callback_args;
        if (arguments.length === 0) {
          arguments.length = 2;
        }
        if (todos.length === 0) {
          todos = stack.shift();
        }
        if (err && callback) {
          todos.throw_if_error = false;
        }
        if (err) {
          jump_to_error(err);
        }
        status_callback = status_callback.some(function(status) {
          return !!status;
        });
        status_action = status_action.some(function(status) {
          return !!status;
        });
        callback_args = [err, status_callback].concat(slice.call([].slice.call(arguments).slice(1)));
        todos.status[0] = status_action && !options.shy;
        if (callback) {
          call_callback(callback, callback_args);
        }
        return run();
      };
      return wrap(obj, [options, finish], function(options, callback) {
        todos.options = options;
        return action.handler.call(obj, options, function() {
          var args, err, status;
          err = arguments[0], status = arguments[1], args = 3 <= arguments.length ? slice.call(arguments, 2) : [];
          status_callback.push(status);
          if (!options.shy) {
            status_action.push(status);
          }
          return setImmediate(function() {
            return callback.apply(null, [err, status].concat(slice.call(args)));
          });
        });
      });
    } catch (_error) {
      err = _error;
      todos = stack.shift();
      jump_to_error(err);
      return run();
    }
  };
  jump_to_error = function(err) {
    while (todos[0] && todos[0].type !== 'then') {
      todos.shift();
    }
    return todos.err = err;
  };
  run = function() {
    var err, ref1, status, todo;
    todo = todos.shift();
    if (!todo) {
      if (todos.err && todos.throw_if_error) {
        throw todos.err;
      }
      return;
    }
    if (todo.type === 'then') {
      err = todos.err, status = todos.status;
      status = status.some(function(status) {
        return !!status;
      });
      todos.err = null;
      todos.status = [];
      todos.throw_if_error = true;
      todo.handler.call(obj, err, status);
      run();
      return;
    }
    todo.options.user_args = ((ref1 = todo.options.callback) != null ? ref1.length : void 0) > 2;
    if (todo.handler.length === 2) {
      return call_async(todo);
    } else {
      call_sync(todo);
      return run();
    }
  };
  properties.child = {
    get: function() {
      return function() {
        return module.exports(obj.options);
      };
    }
  };
  properties.then = {
    get: function() {
      return function() {
        todos.push({
          type: 'then',
          handler: arguments[0]
        });
        if (todos.length === 1) {
          setImmediate(run);
        }
        return obj;
      };
    }
  };
  properties.call = {
    get: function() {
      return function() {
        var args;
        args = [].slice.call(arguments);
        todos.push(normalize_arguments(args));
        if (todos.length === 1) {
          setImmediate(run);
        }
        return obj;
      };
    }
  };
  proto = Object.defineProperties(obj, properties);
  Object.defineProperty(obj, 'register', {
    get: function() {
      return function(name, handler) {
        var is_registered_locally;
        is_registered_locally = obj.registered(name, true);
        if (handler === null || handler === false) {
          if (is_registered_locally) {
            delete obj.registry[name];
            delete obj[name];
          } else if (module.exports.registered(name)) {
            throw Error('Unregister a global function from local context');
          }
          return obj;
        }
        if (is_registered_locally) {
          throw Error("Function already defined '" + name + "'");
        }
        obj.registry[name] = handler;
        return Object.defineProperty(obj, name, {
          configurable: true,
          get: function() {
            return function() {
              var arg, args, i, l, len1;
              args = [].slice.call(arguments);
              for (i = l = 0, len1 = args.length; l < len1; i = ++l) {
                arg = args[i];
                if (typeof arg === 'function') {
                  args.splice(i, 0, obj.registry[name] || registry[name]);
                  break;
                }
                if (i + 1 === args.length) {
                  args.push(obj.registry[name] || registry[name]);
                }
              }
              todos.push(normalize_arguments(args));
              if (todos.length === 1) {
                setImmediate(run);
              }
              return obj;
            };
          }
        });
      };
    }
  });
  Object.defineProperty(obj, 'registered', {
    get: function() {
      return function(name, local_only) {
        var global, local;
        if (local_only == null) {
          local_only = false;
        }
        global = Object.prototype.hasOwnProperty.call(module.exports, name);
        local = Object.prototype.hasOwnProperty.call(obj, name);
        if (local_only) {
          return local;
        } else {
          return global || local;
        }
      };
    }
  });
  Object.defineProperty(obj, 'status', {
    get: function() {
      return function(index) {
        if (arguments.length === 0) {
          return stack[0].status.some(function(status) {
            return !!status;
          });
        } else {
          return stack[0].status[Math.abs(index)];
        }
      };
    }
  });
  for (name in registry) {
    handler = registry[name];
    obj.register(name, handler);
  }
  return obj;
};

module.exports.propagated_options = ['ssh', 'log', 'stdout', 'stderr'];

register = module.exports.register = function(name, handler) {
  if (handler === null || handler === false) {
    if (registered(name)) {
      delete registry[name];
    }
    if (registered(name)) {
      delete module.exports[name];
    }
    return module.exports;
  }
  if (registered(name)) {
    throw Error("Function already defined '" + name + "'");
  }
  if (name !== 'call') {
    registry[name] = handler;
  }
  return Object.defineProperty(module.exports, name, {
    configurable: true,
    get: function() {
      return module.exports()[name];
    }
  });
};

registered = module.exports.registered = function(name) {
  return Object.prototype.hasOwnProperty.call(module.exports, name);
};

registry = require('./misc/registry');

for (name in registry) {
  handler = registry[name];
  register(name, handler);
}

register('call', module.exports().call);

wrap = require('./misc/wrap');
