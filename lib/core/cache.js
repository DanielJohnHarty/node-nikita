// Generated by CoffeeScript 1.10.0
var curl, misc, path, protocols_ftp, protocols_http, ssh2fs, url,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

module.exports = function(options, callback) {
  var algo, cmd, fail, hash, k, ref, ref1, ref2, u;
  if (!options.source) {
    return callback(Error("Missing source: '" + options.source + "'"));
  }
  if (!(options.cache_file || options.destination || options.cache_dir)) {
    return callback(Error("Missing one of 'destination', 'cache_file' or 'cache_dir' option"));
  }
  if (options.destination == null) {
    options.destination = options.cache_file;
  }
  if (options.destination == null) {
    options.destination = path.basename(options.source);
  }
  options.destination = path.resolve(options.cache_dir, options.destination);
  if (/^file:\/\//.test(options.source)) {
    options.source = options.source.substr(7);
  }
  if (options.md5 != null) {
    if ((ref = typeof options.md5) !== 'string' && ref !== 'boolean') {
      return callback(new Error("Invalid MD5 Hash:" + options.md5));
    }
    algo = 'md5';
    hash = options.md5;
  } else if (options.sha1 != null) {
    if ((ref1 = typeof options.sha1) !== 'string' && ref1 !== 'boolean') {
      return callback(new Error("Invalid SHA-1 Hash:" + options.sha1));
    }
    algo = 'sha1';
    hash = options.sha1;
  } else {
    algo = 'md5';
    hash = false;
  }
  u = url.parse(options.source);
  this.call({
    handler: function(_, callback) {
      if (u.protocol !== null) {
        options.log({
          message: "Bypass source hash computation for non-file protocols",
          level: 'WARN',
          module: 'mecano/src/cache'
        });
        return callback();
      }
      if (hash !== true) {
        return callback();
      }
      return misc.file.hash(options.ssh, options.source, algo, function(err, value) {
        if (err) {
          return callback(err);
        }
        options.log({
          message: "Computed hash value is '" + value + "'",
          level: 'INFO',
          module: 'mecano/src/cache'
        });
        hash = value;
        return callback();
      });
    }
  });
  this.call({
    shy: true,
    handler: function(_, callback) {
      options.log({
        message: "Check if destination (" + options.destination + ") exists",
        level: 'DEBUG',
        module: 'mecano/src/cache'
      });
      return ssh2fs.exists(options.ssh, options.destination, (function(_this) {
        return function(err, exists) {
          if (err) {
            return callback(err);
          }
          if (exists) {
            options.log({
              message: "Destination exists",
              level: 'INFO',
              module: 'mecano/src/cache'
            });
            if (options.force) {
              options.log({
                message: "Force mode, cache will be overwritten",
                level: 'DEBUG',
                module: 'mecano/src/cache'
              });
              return callback(null, true);
            } else if (hash && typeof hash === 'string') {
              options.log({
                message: "Comparing " + algo + " hash",
                level: 'DEBUG',
                module: 'mecano/src/cache'
              });
              return misc.file.hash(options.ssh, options.destination, algo, function(err, c_hash) {
                if (err) {
                  return callback(err);
                }
                if (hash === c_hash) {
                  options.log({
                    message: "Hashes match, skipping",
                    level: 'DEBUG',
                    module: 'mecano/src/cache'
                  });
                  return callback(null, false);
                }
                options.log({
                  message: "Hashes don't match, delete then re-download",
                  level: 'WARN',
                  module: 'mecano/src/cache'
                });
                return ssh2fs.unlink(options.ssh, options.destination, function(err) {
                  if (err) {
                    return callback(err);
                  }
                  return callback(null, true);
                });
              });
            } else {
              options.log({
                message: "Destination exists, check disabled, skipping",
                level: 'DEBUG',
                module: 'mecano/src/cache'
              });
              return callback(null, false);
            }
          } else {
            options.log({
              message: "Destination does not exists",
              level: 'INFO',
              module: 'mecano/src/cache'
            });
            return callback(null, true);
          }
        };
      })(this));
    }
  }, function(err, status) {
    if (!status) {
      return this.end();
    }
  });
  if (ref2 = u.protocol, indexOf.call(protocols_http, ref2) >= 0) {
    fail = options.fail ? "--fail" : '';
    k = u.protocol === 'https:' ? '-k' : '';
    cmd = "curl " + fail + " " + k + " -s " + options.source + " -o " + options.destination;
    if (options.proxy) {
      cmd += " -x " + options.proxy;
    }
    this.mkdir(path.dirname(options.destination));
    this.execute({
      cmd: cmd,
      not_if_exists: options.destination
    });
  } else {
    this.mkdir({
      destination: "" + (path.dirname(options.destination))
    });
    this.copy({
      source: "" + options.source,
      destination: "" + options.destination
    });
  }
  return this.then(function(err, status) {
    return callback(err, status, options.destination);
  });
};

module.exports.protocols_http = protocols_http = ['http:', 'https:'];

module.exports.protocols_ftp = protocols_ftp = ['ftp:', 'ftps:'];

path = require('path');

url = require('url');

ssh2fs = require('ssh2-fs');

misc = require('../misc');

curl = require('../misc/curl');
