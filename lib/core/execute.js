// Generated by CoffeeScript 1.10.0
var exec, misc;

module.exports = function(options, callback) {
  var child, stderr, stdout, stds;
  options.log({
    message: "Entering execute",
    level: 'DEBUG',
    module: 'mecano/lib/execute'
  });
  stds = options.user_args;
  if (typeof options.argument === 'string') {
    options.cmd = options.argument;
  }
  if (options.code == null) {
    options.code = [0];
  }
  if (!Array.isArray(options.code)) {
    options.code = [options.code];
  }
  if (options.code_skipped == null) {
    options.code_skipped = [];
  }
  if (!Array.isArray(options.code_skipped)) {
    options.code_skipped = [options.code_skipped];
  }
  if (options.stdout_callback === void 0) {
    options.stdout_callback = true;
  }
  if (options.stderr_callback === void 0) {
    options.stderr_callback = true;
  }
  if (options.stdout_log == null) {
    options.stdout_log = false;
  }
  if (options.stderr_log == null) {
    options.stderr_log = false;
  }
  if (typeof options.cmd === 'function') {
    options.cmd = options.cmd.call(this, options);
  }
  if (options.cmd == null) {
    throw Error("Missing cmd: " + options.cmd);
  }
  if (options.trap) {
    options.cmd = "set -e\n" + options.cmd;
  }
  options.log({
    message: options.cmd,
    type: 'stdin',
    module: 'mecano/lib/execute'
  });
  child = exec(options);
  stdout = [];
  stderr = [];
  if (options.stdout) {
    child.stdout.pipe(options.stdout, {
      end: false
    });
  }
  if (options.stderr) {
    child.stderr.pipe(options.stderr, {
      end: false
    });
  }
  if (options.stdout_callback || options.stdout_log) {
    child.stdout.on('data', function(data) {
      if (options.stdout_log) {
        options.log({
          message: data,
          type: 'stdout_stream',
          module: 'mecano/lib/execute'
        });
      }
      if (options.stdout_callback) {
        if (Array.isArray(stdout)) {
          return stdout.push(data);
        } else {
          return console.log('stdout coming after child exit');
        }
      }
    });
  }
  if (options.stderr_callback || stderr_log) {
    child.stderr.on('data', function(data) {
      if (options.stderr_log) {
        options.log({
          message: data,
          type: 'stderr_stream',
          module: 'mecano/lib/execute'
        });
      }
      if (options.stderr_callback) {
        if (Array.isArray(stderr)) {
          return stderr.push(data);
        } else {
          return console.log('stderr coming after child exit');
        }
      }
    });
  }
  return child.on("exit", function(code) {
    return setTimeout(function() {
      var err, executed;
      if (!(options.stdout === false || options.stdout === null)) {
        options.log({
          message: null,
          type: 'stdout_stream',
          module: 'mecano/lib/execute'
        });
      }
      if (!(options.stderr === false || options.stderr === null)) {
        options.log({
          message: null,
          type: 'stderr_stream',
          module: 'mecano/lib/execute'
        });
      }
      stdout = stdout.map(function(d) {
        return d.toString();
      }).join('');
      stderr = stderr.map(function(d) {
        return d.toString();
      }).join('');
      if (!(options.stdout === false || options.stdout === null)) {
        if (stdout && stdout !== '') {
          options.log({
            message: stdout,
            type: 'stdout',
            module: 'mecano/lib/execute'
          });
        }
      }
      if (!(options.stderr === false || options.stderr === null)) {
        if (stderr && stderr !== '') {
          options.log({
            message: stderr,
            type: 'stderr',
            module: 'mecano/lib/execute'
          });
        }
      }
      if (options.stdout) {
        child.stdout.unpipe(options.stdout);
      }
      if (options.stderr) {
        child.stderr.unpipe(options.stderr);
      }
      if (options.code.indexOf(code) === -1 && options.code_skipped.indexOf(code) === -1) {
        err = new Error("Invalid Exit Code: " + code);
        err.code = code;
        return callback(err, null, stdout, stderr);
      }
      if (options.code_skipped.indexOf(code) === -1) {
        executed = true;
      } else {
        options.log({
          message: "Skip exit code \"" + code + "\"",
          level: 'INFO',
          module: 'mecano/lib/execute'
        });
      }
      return callback(null, executed, stdout, stderr, code);
    }, 1);
  });
};

exec = require('ssh2-exec');

misc = require('../misc');
