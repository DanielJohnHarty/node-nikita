// Generated by CoffeeScript 1.10.0
var curl, fs, misc, path, ssh2fs, url,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

module.exports = function(options) {
  var algo, destination, hash, hash_info, protocols_ftp, protocols_http, ref, ref1, source, stageDestination, use_cache;
  destination = options.destination, source = options.source;
  if (!source) {
    return callback(new Error("Missing source: " + source));
  }
  if (!destination) {
    return callback(new Error("Missing destination: " + destination));
  }
  if (/^file:\/\//.test(options.source)) {
    options.source = source = options.source.substr(7);
  }
  stageDestination = destination + "." + (Date.now()) + (Math.round(Math.random() * 1000));
  if (options.md5 != null) {
    if ((ref = typeof options.md5) !== 'string' && ref !== 'boolean') {
      return callback(new Error("Invalid MD5 Hash:" + options.md5));
    }
    algo = 'md5';
    hash = options.md5;
  } else if (options.sha1 != null) {
    if ((ref1 = typeof options.sha1) !== 'string' && ref1 !== 'boolean') {
      return callback(new Error("Invalid SHA-1 Hash:" + options.sha1));
    }
    algo = 'sha1';
    hash = options.sha1;
  } else {
    algo = 'md5';
    hash = false;
  }
  protocols_http = ['http:', 'https:'];
  protocols_ftp = ['ftp:', 'ftps:'];
  use_cache = !!(options.cache_dir || options.cache_file);
  hash_info = null;
  this.call({
    handler: function(_, callback) {
      var u;
      u = url.parse(source);
      if (u.protocol !== null) {
        if (typeof options.log === "function") {
          options.log("Mecano `download`: bypass source hash computation for non-file protocols [WARN]");
        }
        return callback();
      }
      if (hash !== true) {
        return callback();
      }
      return misc.file.hash(options.ssh, source, algo, function(err, value) {
        if (err) {
          return callback(err);
        }
        if (typeof options.log === "function") {
          options.log("Mecano `download`: computed hash value is '" + value + "' [INFO]");
        }
        hash = value;
        return callback();
      });
    }
  });
  this.call({
    shy: true,
    handler: function(_, callback) {
      if (typeof options.log === "function") {
        options.log("Mecano `download`: Check if destination (" + destination + ") exists [DEBUG]");
      }
      return ssh2fs.exists(options.ssh, destination, (function(_this) {
        return function(err, exists) {
          if (err) {
            return callback(err);
          }
          if (exists) {
            if (typeof options.log === "function") {
              options.log("Mecano `download`: destination exists [INFO]");
            }
            if (options.force) {
              if (typeof options.log === "function") {
                options.log("Mecano `download`: Force download [DEBUG]");
              }
              return callback(null, true);
            } else if (hash && typeof hash === 'string') {
              if (typeof options.log === "function") {
                options.log("Mecano `download`: comparing " + algo + " hash [DEBUG]");
              }
              return misc.file.hash(options.ssh, destination, algo, function(err, c_hash) {
                if (err) {
                  return callback(err);
                }
                if (hash === c_hash) {
                  if (typeof options.log === "function") {
                    options.log("Mecano `download`: Hashes match, skipping [DEBUG]");
                  }
                  return callback(null, false);
                }
                if (typeof options.log === "function") {
                  options.log("Mecano `download`: Hashes don't match, delete then re-download [WARN]");
                }
                return ssh2fs.unlink(options.ssh, destination, function(err) {
                  if (err) {
                    return callback(err);
                  }
                  return callback(null, true);
                });
              });
            } else {
              if (typeof options.log === "function") {
                options.log("Mecano `download`: destination exists, check disabled, skipping [DEBUG]");
              }
              return callback(null, false);
            }
          } else {
            return callback(null, true);
          }
        };
      })(this));
    }
  }, function(err, status) {
    if (!status) {
      return this.end();
    }
  });
  this.cache({
    "if": use_cache,
    ssh: null,
    source: options.source,
    cache_dir: options.cache_dir,
    cache_file: options.cache_file,
    md5: options.md5,
    proxy: options.proxy
  }, function(err, cached, file) {
    if (err) {
      throw err;
    }
    if (use_cache) {
      return source = file;
    }
  });
  this.call(function(_, callback) {
    var rs, u, ws;
    u = url.parse(source);
    if (u.protocol !== null) {
      return callback();
    }
    if (!use_cache) {
      if (hash === true) {
        hash_info = {
          ssh: options.ssh,
          source: options.source
        };
      }
      this.mkdir(path.dirname(stageDestination));
      this.copy({
        source: options.source,
        destination: stageDestination
      });
      return this.then(callback);
    } else if (!options.ssh && use_cache) {
      if (hash === true) {
        hash_info = {
          ssh: null,
          source: source
        };
      }
      rs = fs.createReadStream(source);
      ws = fs.createWriteStream(stageDestination);
      return rs.pipe(ws).on('close', callback).on('error', callback);
    } else if (options.ssh && use_cache) {
      if (hash === true) {
        hash_info = {
          ssh: null,
          source: source
        };
      }
      rs = fs.createReadStream(source);
      return ssh2fs.writeFile(options.ssh, stageDestination, rs, function(err) {
        return callback(err);
      });
    } else {
      return callback(Error("Unsupported API"));
    }
  });
  this.call(function(_, callback) {
    var cmd, fail, k, ref2, rs, u, ws;
    u = url.parse(source);
    if (ref2 = u.protocol, indexOf.call(protocols_http, ref2) < 0) {
      return callback();
    }
    if (!use_cache) {
      if (hash === true) {
        hash_info = {
          ssh: options.ssh,
          source: options.source
        };
      }
      fail = options.fail ? "--fail" : '';
      k = u.protocol === 'https:' ? '-k' : '';
      cmd = "curl " + fail + " " + k + " -s " + options.source + " -o " + stageDestination;
      if (options.proxy) {
        cmd += " -x " + options.proxy;
      }
      if (typeof options.log === "function") {
        options.log("Mecano `download`: 'Download file from url using curl'");
      }
      this.mkdir(path.dirname(stageDestination));
      this.execute({
        cmd: cmd
      });
      return this.then(callback);
    } else if (!options.ssh && use_cache) {
      if (hash === true) {
        hash_info = {
          ssh: null,
          source: source
        };
      }
      rs = fs.createReadStream(source);
      ws = fs.createWriteStream(stageDestination);
      return rs.pipe(ws).on('close', callback).on('error', callback);
    } else if (options.ssh && use_cache) {
      if (hash === true) {
        hash_info = {
          ssh: null,
          source: source
        };
      }
      rs = fs.createReadStream(source);
      return ssh2fs.writeFile(options.ssh, stageDestination, rs, function(err) {
        return callback(err);
      });
    } else {
      return callback(Error("Unsupported API"));
    }
  });
  this.call(function(_, callback) {
    if (!hash_info) {
      return callback();
    }
    return misc.file.hash(hash_info.ssh, hash_info.source, algo, function(err, calc_hash) {
      hash = calc_hash;
      return callback(err);
    });
  });
  this.call(function(_, callback) {
    if (!hash) {
      return callback();
    }
    if (typeof options.log === "function") {
      options.log("Mecano `download`: Compare the downloaded file with the provided checksum [DEBUG]");
    }
    return misc.file.hash(options.ssh, stageDestination, algo, function(err, calc_hash) {
      if (err) {
        return callback(err);
      }
      if (hash === calc_hash) {
        "Mecano `download`: download is valid [INFO]";
        return callback();
      }
      return misc.file.remove(options.ssh, stageDestination, function(err) {
        if (err) {
          return callback(err);
        }
        return callback(new Error("Invalid checksum, found \"" + calc_hash + "\" instead of \"" + hash + "\""));
      });
    });
  });
  return this.call(function() {
    if (typeof options.log === "function") {
      options.log("Mecano `download`: Unstage downloaded file [DEBUG]");
    }
    this.move({
      source: stageDestination,
      destination: destination,
      source_md5: options.md5
    });
    this.chmod({
      destination: destination,
      mode: options.mode,
      "if": options.mode != null
    });
    return this.chown({
      destination: destination,
      uid: options.uid,
      gid: options.gid,
      "if": (options.uid != null) || (options.gid != null)
    });
  });
};

fs = require('fs');

ssh2fs = require('ssh2-fs');

path = require('path');

url = require('url');

misc = require('../misc');

curl = require('../misc/curl');
