// Generated by CoffeeScript 1.10.0
var compare_hash, curl, fs, misc, path, ssh2fs, url,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

module.exports = function(options) {
  var algo, destination, protocols_ftp, protocols_http, ref, ref1, source, source_hash, source_url, stageDestination;
  options.log({
    message: "Calling download",
    level: 'WARN',
    module: 'mecano/lib/download'
  });
  destination = options.destination, source = options.source;
  if (!source) {
    return callback(new Error("Missing source: " + source));
  }
  if (!destination) {
    return callback(new Error("Missing destination: " + destination));
  }
  if (/^file:\/\//.test(options.source)) {
    options.source = options.source.substr(7);
  }
  stageDestination = destination + "." + (Date.now()) + (Math.round(Math.random() * 1000));
  if (options.md5 != null) {
    if ((ref = typeof options.md5) !== 'string' && ref !== 'boolean') {
      return callback(new Error("Invalid MD5 Hash:" + options.md5));
    }
    algo = 'md5';
    source_hash = options.md5;
  } else if (options.sha1 != null) {
    if ((ref1 = typeof options.sha1) !== 'string' && ref1 !== 'boolean') {
      return callback(new Error("Invalid SHA-1 Hash:" + options.sha1));
    }
    algo = 'sha1';
    source_hash = options.sha1;
  } else {
    algo = 'md5';
  }
  protocols_http = ['http:', 'https:'];
  protocols_ftp = ['ftp:', 'ftps:'];
  if (options.cache == null) {
    options.cache = !!(options.cache_dir || options.cache_file);
  }
  options.log({
    message: "Using force: " + (JSON.stringify(options.force)),
    level: 'DEBUG',
    module: 'mecano/lib/download'
  });
  source_url = url.parse(source);
  this.call({
    "if": typeof source_hash === 'string',
    shy: true,
    handler: function(_, callback) {
      options.log({
        message: "Shortcircuit check if provided hash match destination",
        level: 'WARN',
        module: 'mecano/lib/download'
      });
      return misc.file.hash(options.ssh, options.destination, algo, (function(_this) {
        return function(err, hash) {
          if ((err != null ? err.code : void 0) === 'ENOENT') {
            err = null;
          }
          return callback(err, source_hash === hash);
        };
      })(this));
    }
  }, function(err, end) {
    if (!end) {
      return;
    }
    options.log({
      message: "Destination with valid signature, download aborted",
      level: 'INFO',
      module: 'mecano/lib/download'
    });
    return this.end();
  });
  this.cache({
    "if": options.cache,
    ssh: null,
    source: options.source,
    cache_dir: options.cache_dir,
    cache_file: options.cache_file,
    headers: options.headers,
    md5: options.md5,
    proxy: options.proxy
  }, function(err, cached, file) {
    if (err) {
      throw err;
    }
    if (options.cache) {
      options.source = file;
    }
    return source_url = url.parse(options.source);
  });
  this.call({
    "if": function() {
      var ref2;
      return ref2 = source_url.protocol, indexOf.call(protocols_http, ref2) >= 0;
    },
    handler: function(_, callback) {
      var cmd, fail, k;
      fail = options.fail ? "--fail" : '';
      k = source_url.protocol === 'https:' ? '-k' : '';
      cmd = "curl " + fail + " " + k + " -s " + options.source + " -o " + stageDestination;
      if (options.proxy) {
        cmd += " -x " + options.proxy;
      }
      options.log({
        message: "Download file from url using curl",
        level: 'INFO',
        module: 'mecano/lib/download'
      });
      this.mkdir({
        shy: true,
        destination: path.dirname(stageDestination)
      });
      this.execute({
        cmd: cmd,
        shy: true
      });
      this.call({
        "if": typeof source_hash === 'string',
        handler: function(_, callback) {
          return misc.file.hash(options.ssh, stageDestination, algo, (function(_this) {
            return function(err, hash) {
              if (source_hash !== hash) {
                return callback(Error("Invalid downloaded checksum, found '" + hash + "' instead of '" + source_hash + "'"));
              }
              return callback();
            };
          })(this));
        }
      });
      this.call(function(_, callback) {
        return compare_hash(null, stageDestination, options.ssh, options.destination, algo, function(err, match, hash1, hash2) {
          options.log({
            message: "Downloaded hash is '" + hash1 + "'",
            level: 'INFO',
            module: 'mecano/lib/download'
          });
          options.log({
            message: "Destination hash is '" + hash2 + "'",
            level: 'INFO',
            module: 'mecano/lib/download'
          });
          return callback(err, !match);
        });
      });
      this.remove({
        unless: function() {
          return this.status(-1);
        },
        shy: true,
        destination: stageDestination
      });
      return this.then(callback);
    }
  });
  this.call({
    "if": function() {
      return source_url.protocol === null && !options.cache;
    },
    handler: function(_, callback) {
      options.log({
        message: "No cache, rely on copy",
        level: 'DEBUG',
        module: 'mecano/lib/download'
      });
      this.call(function(_, callback) {
        return compare_hash(options.ssh, options.source, options.ssh, options.destination, algo, function(err, match, hash1, hash2) {
          if (!match) {
            options.log({
              message: "Hash dont match, source is '" + hash1 + "' and destination is '" + hash2 + "'",
              level: 'WARN',
              module: 'mecano/lib/download'
            });
          }
          if (match) {
            options.log({
              message: "Hash matches as '" + hash1 + "'",
              level: 'INFO',
              module: 'mecano/lib/download'
            });
          }
          return callback(err, !match);
        });
      });
      this.mkdir({
        "if": function() {
          return this.status(-1);
        },
        shy: true,
        destination: path.dirname(stageDestination)
      });
      this.call({
        "if": function() {
          return this.status(-2);
        },
        handler: function(_, callback) {
          var rs, ws;
          rs = fs.createReadStream(options.source);
          rs.on('error', function(err) {
            options.log({
              message: "No such source file: " + options.source + " (ssh is " + (JSON.stringify(!!options.ssh)) + ")",
              level: 'ERROR',
              module: 'mecano/lib/download'
            });
            err.message = 'No such source file';
            return callback(err);
          });
          ws = fs.createWriteStream(stageDestination);
          return rs.pipe(ws).on('close', callback).on('error', callback);
        }
      });
      return this.then(callback);
    }
  });
  this.call({
    "if": function() {
      return source_url.protocol === null && options.cache && !options.ssh;
    },
    handler: function(_, callback) {
      options.log({
        message: "With cache and without SSH, ",
        level: 'DEBUG',
        module: 'mecano/lib/download'
      });
      this.call(function(_, callback) {
        return compare_hash(null, options.source, options.ssh, options.destination, algo, function(err, match) {
          return callback(err, !match);
        });
      });
      this.mkdir({
        "if": function() {
          return this.status(-1);
        },
        shy: true,
        destination: path.dirname(stageDestination)
      });
      this.call({
        "if": function() {
          return this.status(-2);
        },
        handler: function(_, callback) {
          var rs, ws;
          rs = fs.createReadStream(options.source);
          rs.on('error', function(err) {
            return console.log('rs on error', err);
          });
          ws = fs.createWriteStream(stageDestination);
          return rs.pipe(ws).on('close', callback).on('error', callback);
        }
      });
      return this.then(callback);
    }
  });
  this.call({
    "if": function() {
      return source_url.protocol === null && options.cache && options.ssh;
    },
    handler: function(_, callback) {
      this.call(function(_, callback) {
        return compare_hash(null, options.source, options.ssh, options.destination, algo, function(err, match, hash1, hash2) {
          return callback(err, !match);
        });
      });
      this.mkdir({
        "if": function() {
          return this.status(-1);
        },
        shy: true,
        destination: path.dirname(stageDestination)
      });
      this.call({
        "if": function() {
          return this.status(-2);
        },
        handler: function(_, callback) {
          var rs;
          rs = fs.createReadStream(options.source);
          rs.on('error', function(err) {
            return console.log('rs on error', err);
          });
          return ssh2fs.writeFile(options.ssh, stageDestination, rs, function(err) {
            if (err) {
              options.log("Upload failed from local to remote");
            }
            return callback(err);
          });
        }
      });
      return this.then(callback);
    }
  });
  return this.call(function() {
    options.log({
      message: "Unstage downloaded file",
      level: 'DEBUG',
      module: 'mecano/lib/download'
    });
    this.move({
      "if": this.status(),
      source: stageDestination,
      destination: options.destination
    });
    this.chmod({
      destination: options.destination,
      mode: options.mode,
      "if": options.mode != null
    });
    return this.chown({
      destination: options.destination,
      uid: options.uid,
      gid: options.gid,
      "if": (options.uid != null) || (options.gid != null)
    });
  });
};

compare_hash = function(ssh1, file1, ssh2, file2, algo, callback) {
  return misc.file.hash(ssh1, file1, algo, function(err, hash1) {
    if (err) {
      return callback(err);
    }
    return misc.file.hash(ssh2, file2, algo, function(err, hash2) {
      if ((err != null ? err.code : void 0) === 'ENOENT') {
        err = null;
      }
      if (err) {
        return callback(err);
      }
      return callback(null, hash1 === hash2, hash1, hash2);
    });
  });
};

fs = require('fs');

ssh2fs = require('ssh2-fs');

path = require('path');

url = require('url');

misc = require('../misc');

curl = require('../misc/curl');
