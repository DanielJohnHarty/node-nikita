// Generated by CoffeeScript 2.3.0
// # Nikita Context
var EventEmitter, array, called_deprecate_destination, called_deprecate_local_source, conditions, domain, each, handle_get, merge, path, promise, registry, string, todos_create, todos_reset, util, wrap;

called_deprecate_destination = false;

called_deprecate_local_source = false;

module.exports = function() {
  var _run_, call_callback, domain_on_error, enrich_options, handle_multiple_call, jump_to_error, k, normalize_options, obj, proxy, ref, ref1, reg, run, state, v;
  if (arguments.length === 2) {
    obj = arguments[0];
    obj.options = arguments[1];
  } else if (arguments.length === 1) {
    obj = new EventEmitter;
    obj.options = arguments[0];
  } else {
    obj = new EventEmitter;
    obj.options = {};
  }
  if (obj.registry == null) {
    obj.registry = {};
  }
  if (obj.propagation == null) {
    obj.propagation = obj.options.propagation || {};
  }
  if (obj.store == null) {
    obj.store = {};
  }
  ref = module.exports.propagation;
  // Merge global default propagation
  for (k in ref) {
    v = ref[k];
    if (obj.propagation[k] === void 0) {
      obj.propagation[k] = v;
    }
  }
  // Internal state
  state = {};
  state.properties = {};
  state.stack = [];
  state.todos = todos_create();
  state.befores = [];
  state.afters = [];
  state.depth = 0;
  state.headers = [];
  state.once = {};
  state.killed = false;
  state.index_counter = 0;
  if (obj.options.domain === true) {
    // Domain
    obj.options.domain = domain.create();
  }
  domain_on_error = function(err) {
    err.message = `Invalid State Error [${err.message}]`;
    return handle_multiple_call(err);
  };
  if ((ref1 = obj.options.domain) != null) {
    ref1.on('error', domain_on_error);
  }
  // Proxify
  proxy = new Proxy(obj, {
    has: function(target, name) {
      return console.warns('proxy has is being called', name);
    },
    // target[name]? or target.registry.registered(proxy.type)? or registry.registered(name)?
    apply: function(target, thisArg, argumentsList) {
      return console.warn('apply');
    },
    get: function(target, name) {
      var get_proxy_builder;
      if (obj[name] != null) {
        return target[name];
      }
      if (name === 'domain' || name === '_events' || name === '_maxListeners') {
        return target[name];
      }
      proxy.type = [];
      proxy.type.push(name);
      if (!obj.registry.registered(proxy.type, {
        parent: true
      }) && !registry.registered(proxy.type, {
        parent: true
      })) {
        proxy.type = [];
        return void 0;
      }
      get_proxy_builder = function() {
        var builder;
        builder = function() {
          var args, get, j, len, options, opts, values;
          args = [].slice.call(arguments);
          options = normalize_options(args, proxy.type);
          ({get, values} = handle_get(proxy, options));
          if (get) {
            return values;
          }
          proxy.type = [];
          for (j = 0, len = options.length; j < len; j++) {
            opts = options[j];
            state.todos.push(opts);
          }
          if (state.todos.length === options.length) { // Activate the pump
            setImmediate(_run_);
          }
          return proxy;
        };
        return new Proxy(builder, {
          get: function(target, name) {
            if (target[name] != null) {
              return target[name];
            }
            proxy.type.push(name);
            if (!obj.registry.registered(proxy.type, {
              parent: true
            }) && !registry.registered(proxy.type, {
              parent: true
            })) {
              proxy.type = [];
              return void 0;
            }
            return get_proxy_builder();
          }
        });
      };
      return get_proxy_builder();
    }
  });
  normalize_options = function(_arguments, type, enrich = true) {
    var a, arg, callback, cloned_arg, empty, handler, i, j, l, len, len1, len2, len3, m, middleware, n, options, opts, ref2;
    empty = false;
    if (Array.isArray(type)) {
      middleware = obj.registry.get(type) || registry.get(type);
    }
    if (middleware) {
      _arguments.unshift(middleware.handler);
    }
    handler = null;
    callback = null;
    options = [];
    for (j = 0, len = _arguments.length; j < len; j++) {
      arg = _arguments[j];
      if (typeof arg === 'function') {
        if (!handler) {
          handler = arg;
        } else if (!callback) {
          callback = arg;
        } else {
          throw Error("Invalid third function argument");
        }
      } else if (Array.isArray(arg)) {
        if (arg.length === 0) {
          empty = true;
        }
        for (l = 0, len1 = arg.length; l < len1; l++) {
          a = arg[l];
          if (type === 'call') {
            if (!(typeof a === 'object' && !Array.isArray(a) && a !== null)) {
              a = {
                handler: a
              };
            }
          } else {
            if (!(typeof a === 'object' && !Array.isArray(a) && a !== null)) {
              a = {
                argument: a
              };
            }
          }
          options.push(a);
        }
      } else {
        if (typeof arg !== 'object' && arg !== null) {
          arg = {
            argument: arg
          };
        }
        if (options.length === 0) {
          cloned_arg = {};
          for (k in arg) {
            v = arg[k];
            cloned_arg[k] = v;
          }
          options.push(cloned_arg);
        } else {
          for (m = 0, len2 = options.length; m < len2; m++) {
            opts = options[m];
            for (k in arg) {
              v = arg[k];
              opts[k] = v;
            }
          }
        }
      }
    }
    if (options.length === 0 && empty) {
      return options;
    }
    if (options.length === 0) {
      options.push({});
    }
    if (options.length && options.filter(function(opts) {
      return !opts.handler;
    }).length === 0) {
      callback = handler;
      handler = null;
    }
// Normalize
    for (i = n = 0, len3 = options.length; n < len3; i = ++n) {
      opts = options[i];
      // Clone
      options[i] = {};
      if (Array.isArray(type)) {
        merge(options[i], middleware);
      }
      for (k in opts) {
        v = opts[k];
        options[i][k] = v;
      }
      opts = options[i];
      // Argument
      if (type === 'call' && !opts.handler) { //and typeof opts.argument is 'function'
        opts.handler = opts.argument;
        opts.argument = void 0;
      }
      // Enrich
      if (opts.destination) {
        if (!called_deprecate_destination) {
          console.info('Use options target instead of destination');
        }
        called_deprecate_destination = true;
        if (opts.target == null) {
          opts.target = opts.destination;
        }
      }
      if (opts.local_source) {
        if (!called_deprecate_local_source) {
          console.info('Use options local instead of local_source');
        }
        called_deprecate_local_source = true;
        if (opts.local == null) {
          opts.local = opts.local_source;
        }
      }
      if (type) {
        opts.type = type;
      }
      if (!Array.isArray(opts.type)) {
        opts.type = [opts.type];
      }
      if (handler) {
        if (opts.handler == null) {
          opts.handler = handler;
        }
      }
      if (callback) {
        if (opts.callback == null) {
          opts.callback = callback;
        }
      }
      if (enrich && ((ref2 = opts.callback) != null ? ref2.length : void 0) > 2) {
        opts.user_args = true;
      }
      if (opts.once === true) {
        opts.once = ['handler'];
      }
      if (opts.once === false) {
        delete opts.once;
      }
      if (Array.isArray(opts.once)) {
        opts.once = opts.once.sort();
      }
      if (opts.sleep == null) {
        opts.sleep = 3000; // Wait 3s between retry
      }
      if (opts.retry == null) {
        opts.retry = 0;
      }
      if (opts.disabled == null) {
        opts.disabled = false;
      }
      if (opts.status == null) {
        opts.status = true;
      }
      if (opts.status === false && opts.shy === false) { // Room for argument, leave it strict for now until we come accross a usecase justifying it.
        throw Error('Incompatible Options: status "false" implies shy "true"');
      }
      if (opts.status === false) {
        if (opts.shy == null) {
          opts.shy = true;
        }
      }
      if (!(typeof opts.sleep === 'number' && opts.sleep >= 0)) {
        // Validation
        jump_to_error(Error(`Invalid options sleep, got ${JSON.stringify(opts.sleep)}`));
      }
    }
    return options;
  };
  enrich_options = function(user_options) {
    var _logs, global_options, log_disabled, match, options, parent_options, ref2, ref3;
    user_options.enriched = true;
    global_options = obj.options;
    parent_options = state.todos.options;
    options = {};
    for (k in user_options) {
      v = user_options[k];
      options[k] = user_options[k];
    }
    for (k in parent_options) {
      v = parent_options[k];
      if (options[k] === void 0 && obj.propagation[k]) {
        options[k] = v;
      }
    }
    for (k in global_options) {
      v = global_options[k];
      if (options[k] === void 0) {
        options[k] = v;
      }
    }
    if (!((ref2 = options.log) != null ? ref2.dont : void 0)) {
      if (options.log && !Array.isArray(options.log)) {
        _logs = [options.log];
      } else if (!options.log) {
        _logs = [];
      }
    }
    if (options.log === false) {
      log_disabled = true;
    }
    if (log_disabled) {
      options.log = [];
    }
    if ((ref3 = options.log) != null ? ref3._nikita_ : void 0) { // not clean but no better way to detect user provided option with the one from nikita
      options.log = [];
    }
    if (options.log == null) {
      options.log = [];
    }
    if (!Array.isArray(options.log)) {
      options.log = [options.log];
    }
    _logs = options.log;
    if (options.debug) {
      _logs.push(function(log) {
        var msg, ref4, ref5, ref6;
        if ((ref4 = log.type) !== 'text' && ref4 !== 'stdin' && ref4 !== 'stdout_stream' && ref4 !== 'stderr_stream') {
          return;
        }
        if (((ref5 = log.type) === 'stdout_stream' || ref5 === 'stderr_stream') && log.message === null) {
          return;
        }
        msg = ((ref6 = log.message) != null ? ref6.toString : void 0) != null ? log.message.toString() : log.message;
        msg = `[${log.total_depth}.${log.level} ${log.module}] ${JSON.stringify(msg)}`;
        msg = (function() {
          switch (log.type) {
            case 'stdin':
              return `\x1b[33m${msg}\x1b[39m`;
            case 'stdout_stream':
              return `\x1b[36m${msg}\x1b[39m`;
            case 'stderr_stream':
              return `\x1b[35m${msg}\x1b[39m`;
            default:
              return `\x1b[32m${msg}\x1b[39m`;
          }
        })();
        return process.stdout.write(`${msg
    // todo: switch with stderr
}\n`);
      });
    }
    options.log = function(log) {
      var _log, args, file, frame, header, j, l, len, len1, line, method, ref4, stackTrace;
      if (typeof log === 'string') {
        log = {
          message: log
        };
      }
      if (log.level == null) {
        log.level = 'INFO';
      }
      if (log.time == null) {
        log.time = Date.now();
      }
      if (log.module == null) {
        log.module = void 0;
      }
      if (log.header_depth == null) {
        log.header_depth = state.depth;
      }
      ref4 = state.headers;
      for (j = 0, len = ref4.length; j < len; j++) {
        header = ref4[j];
        if (log.headers == null) {
          log.headers = header;
        }
      }
      if (log.total_depth == null) {
        log.total_depth = state.stack.length;
      }
      if (log.type == null) {
        log.type = 'text';
      }
      if (log.shy == null) {
        log.shy = options.shy;
      }
      args = 1 <= arguments.length ? [].slice.call(arguments, 0) : [];
      stackTrace = require('stack-trace');
      frame = stackTrace.get()[1];
      file = path.basename(frame.getFileName());
      line = frame.getLineNumber();
      method = frame.getFunctionName();
      log.file = file;
      log.line = line;
      args.unshift("" + file + ":" + line + " in " + method + "()");
      for (l = 0, len1 = _logs.length; l < len1; l++) {
        _log = _logs[l];
        _log(log);
      }
      if (!log_disabled) {
        return typeof obj.emit === "function" ? obj.emit(log.type, log) : void 0;
      }
    };
    options.log._nikita_ = true;
    if (options.source && (match = /~($|\/.*)/.exec(options.source))) {
      if (!obj.store['nikita:ssh:connection']) {
        options.source = path.join(process.env.HOME, match[1]);
      } else {
        options.source = path.posix.join('.', match[1]);
      }
    }
    if (options.target && (match = /~($|\/.*)/.exec(options.target))) {
      if (!obj.store['nikita:ssh:connection']) {
        options.target = path.join(process.env.HOME, match[1]);
      } else {
        options.target = path.posix.join('.', match[1]);
      }
    }
    return options;
  };
  call_callback = function(fn, args) {
    var err, mtodos;
    state.stack.unshift(state.todos);
    state.todos = todos_create();
    try {
      fn.apply(proxy, args);
    } catch (error) {
      err = error;
      state.todos = state.stack.shift();
      jump_to_error(err);
      args[0] = err;
      return run();
    }
    mtodos = state.todos;
    state.todos = state.stack.shift();
    if (mtodos.length) {
      return state.todos.unshift(...mtodos);
    }
  };
  handle_multiple_call = function(err) {
    state.killed = true;
    while (state.stack.length) {
      state.todos = state.stack.shift();
    }
    jump_to_error(err);
    return run();
  };
  jump_to_error = function(err) {
    var ref2;
    while (state.todos[0] && ((ref2 = state.todos[0].type) !== 'catch' && ref2 !== 'next' && ref2 !== 'promise')) {
      state.todos.shift();
    }
    return state.todos.err = err;
  };
  _run_ = function() {
    if (obj.options.domain) {
      return obj.options.domain.run(run);
    } else {
      return run();
    }
  };
  run = function(options, callback) {
    var err, header, index, org_options, parent_options, ref2, ref3, ref4, status;
    if (!options) {
      options = state.todos.shift();
    }
    // Nothing more to do in current queue
    if (!options) {
      if ((ref2 = obj.options.domain) != null) {
        ref2.removeListener('error', domain_on_error);
      }
      // Run is called with a callback
      if (callback) {
        if (callback) {
          callback(state.todos.err);
        }
        return;
      } else {
        if (!state.killed && state.stack.length === 0 && state.todos.err && state.todos.throw_if_error) {
          obj.emit('error', state.todos.err);
          if (obj.listenerCount() !== 0) {
            throw state.todos.err;
          }
        }
      }
      if (state.stack.length === 0) {
        if (!state.todos.err) {
          obj.emit('end', {
            level: 'INFO'
          });
        }
      }
      return;
    }
    org_options = options;
    parent_options = state.todos.options;
    for (k in parent_options) {
      v = parent_options[k];
      if (org_options[k] === void 0 && k !== 'log' && obj.propagation[k] === true) {
        org_options[k] = v;
      }
    }
    options = enrich_options(options);
    options.original = org_options;
    if (options.type === 'next') {
      ({err, status} = state.todos);
      status = status.some(function(status) {
        return !status.shy && !!status.value;
      });
      state.todos.final_err = err;
      todos_reset(state.todos);
      if ((ref3 = options.handler) != null) {
        ref3.call(proxy, err, status);
      }
      run();
      return;
    }
    if (options.type === 'promise') {
      ({err, status} = state.todos);
      status = status.some(function(status) {
        return !status.shy && !!status.value;
      });
      state.todos.final_err = err;
      todos_reset(state.todos);
      if ((ref4 = options.handler) != null) {
        ref4.call(proxy, err, status);
      }
      if (!err) {
        options.deferred.resolve(status);
      } else {
        options.deferred.reject(err);
      }
      return;
    }
    if (state.killed) {
      return;
    }
    if (array.compare(options.type, ['end'])) {
      return conditions.all(proxy, options, function() {
        var ref5;
        while (state.todos[0] && ((ref5 = state.todos[0].type) !== 'next' && ref5 !== 'promise')) {
          state.todos.shift();
        }
        if (callback) {
          callback(err);
        }
        return run();
      }, function(err) {
        if (callback) {
          callback(err);
        }
        return run();
      });
    }
    index = state.index_counter++;
    if (options.header) {
      state.depth++;
    }
    if (options.header) {
      state.headers.push(options.header);
    }
    if (options.header) {
      options.log({
        message: options.header,
        type: 'header',
        index: index,
        depth: state.depth,
        headers: (function() {
          var j, len, ref5, results;
          ref5 = state.headers;
          results = [];
          for (j = 0, len = ref5.length; j < len; j++) {
            header = ref5[j];
            results.push(header);
          }
          return results;
        })()
      });
    }
    state.todos.status.unshift({
      shy: options.shy,
      value: void 0
    });
    state.stack.unshift(state.todos);
    state.todos = todos_create();
    state.todos.options = org_options;
    return wrap.options(options, function(err) {
      var do_callback, do_conditions, do_disabled, do_handler, do_intercept_after, do_intercept_before, do_once, do_options_after, do_options_before;
      do_disabled = function() {
        if (!options.disabled) {
          options.log({
            type: 'lifecycle',
            message: 'disabled_false',
            level: 'DEBUG',
            index: index,
            depth: state.depth,
            error: null,
            status: false
          });
          return do_once();
        } else {
          options.log({
            type: 'lifecycle',
            message: 'disabled_true',
            level: 'INFO',
            index: index,
            depth: state.depth,
            error: null,
            status: false
          });
          return do_callback([]);
        }
      };
      do_once = function() {
        var hash, hashme;
        hashme = function(value) {
          if (typeof value === 'string') {
            value = `string:${string.hash(value)}`;
          } else if (typeof value === 'boolean') {
            value = `boolean:${value}`;
          } else if (typeof value === 'function') {
            value = `function:${string.hash(value.toString())}`;
          } else if (value === void 0 || value === null) {
            value = 'null';
          } else if (Array.isArray(value)) {
            value = 'array:' + value.sort().map(function(value) {
              return hashme(value);
            }).join(':');
          } else if (typeof value === 'object') {
            value = 'object';
          } else {
            throw Error(`Invalid data type: ${JSON.stringify(value)}`);
          }
          return value;
        };
        if (options.once) {
          if (typeof options.once === 'string') {
            hash = string.hash(options.once);
          } else if (Array.isArray(options.once)) {
            hash = string.hash(options.once.map(function(k) {
              return hashme(options[k]);
            }).join('|'));
          } else {
            throw Error(`Invalid Option 'once': ${JSON.stringify(options.once)} must be a string or an array of string`);
          }
          if (state.once[hash]) {
            return do_callback([]);
          }
          state.once[hash] = true;
        }
        return do_options_before();
      };
      do_options_before = function() {
        if (options.options_before) {
          return do_intercept_before();
        }
        if (options.before == null) {
          options.before = [];
        }
        if (!Array.isArray(options.before)) {
          options.before = [options.before];
        }
        return each(options.before).call(function(before, next) {
          var opts;
          before = normalize_options([before], 'call', false);
          before = before[0];
          opts = {
            options_before: true
          };
          for (k in before) {
            v = before[k];
            opts[k] = v;
          }
          for (k in options) {
            v = options[k];
            if (k === 'handler' || k === 'callback') {
              continue;
            }
            if (opts[k] == null) {
              opts[k] = v;
            }
          }
          return run(opts, next);
        }).error(function(err) {
          return do_callback([err]);
        }).next(do_intercept_before);
      };
      do_intercept_before = function() {
        if (options.intercepting) {
          return do_conditions();
        }
        return each(state.befores).call(function(before, next) {
          var opts;
          for (k in before) {
            v = before[k];
            switch (k) {
              case 'handler':
                continue;
              case 'type':
                if (!array.compare(v, options[k])) {
                  return next();
                }
                break;
              default:
                if (v !== options[k]) {
                  return next();
                }
            }
          }
          opts = {
            intercepting: true
          };
          for (k in before) {
            v = before[k];
            opts[k] = v;
          }
          for (k in options) {
            v = options[k];
            if (k === 'handler' || k === 'callback') {
              continue;
            }
            if (opts[k] == null) {
              opts[k] = v;
            }
          }
          return run(opts, next);
        }).error(function(err) {
          return do_callback([err]);
        }).next(do_conditions);
      };
      do_conditions = function() {
        return conditions.all(proxy, options, function() {
// Remove conditions from options
          for (k in options) {
            v = options[k];
            if (/^if.*/.test(k) || /^unless.*/.test(k)) {
              delete options[k];
            }
          }
          options.log({
            type: 'lifecycle',
            message: 'conditions_passed',
            index: index,
            depth: state.depth,
            error: null,
            status: false
          });
          return do_handler();
        }, function(err) {
          options.log({
            type: 'lifecycle',
            message: 'conditions_failed',
            index: index,
            depth: state.depth,
            error: err,
            status: false
          });
          return do_callback([err]);
        });
      };
      options.attempt = -1;
      do_handler = function() {
        var called, do_next, handle_async_and_promise, option, options_callback, options_handler, options_handler_length, opts, promise_returned, propagate, ref5, ref6, ref7, result, status_sync, wait_children;
        options.attempt++;
        do_next = function([err]) {
          options.handler = options_handler;
          options.callback = options_callback;
          if (err && !(err instanceof Error)) {
            err = Error('First argument not a valid error');
            arguments[0][0] = err;
          }
          if (err) {
            options.log({
              message: err.message,
              level: 'ERROR',
              index: index,
              module: 'nikita'
            });
          }
          if (err && (options.retry === true || options.attempt < options.retry - 1)) {
            options.log({
              message: `Retry on error, attempt ${options.attempt + 1}`,
              level: 'WARN',
              index: index,
              module: 'nikita'
            });
            return setTimeout(do_handler, options.sleep);
          }
          return do_intercept_after(...arguments);
        };
        if (options.handler == null) {
          options.handler = ((ref5 = obj.registry.get(options.type)) != null ? ref5.handler : void 0) || ((ref6 = registry.get(options.type)) != null ? ref6.handler : void 0);
        }
        if (!options.handler) {
          return handle_multiple_call(Error(`Unregistered Middleware: ${options.type.join('.')}`));
        }
        options_handler = options.handler;
        options_handler_length = options.handler.length;
        options.handler = void 0;
        options_callback = options.callback;
        options.callback = void 0;
        called = false;
        try {
          // Option to inject
          opts = {};
// Clone first level properties
          for (k in options) {
            v = options[k];
            opts[k] = v;
          }
          ref7 = obj.propagation;
          for (option in ref7) {
            propagate = ref7[option];
            if (propagate === false) {
              delete opts[option];
            }
          }
          if (options.deprecate) {
            // Handle deprecation
            options_handler = (function(options_handler) {
              return util.deprecate(function() {
                return options_handler.apply(this, arguments);
              }, options.deprecate === true ? `${options.type.join('/')} is deprecated` : `${options.type.join('/')} is deprecated, use ${options.deprecate}`);
            })(options_handler);
          }
          handle_async_and_promise = function() {
            var args;
            if (state.killed) {
              return;
            }
            if (called) {
              return handle_multiple_call(Error('Multiple call detected'));
            }
            called = true;
            args = [].slice.call(arguments, 0);
            return setImmediate(function() {
              return do_next(args);
            });
          };
          if (options_handler_length === 2) { // Async style
            promise_returned = false;
            result = options_handler.call(proxy, opts, function() {
              if (promise_returned) {
                return;
              }
              return handle_async_and_promise.apply(null, arguments);
            });
            if (promise.is(result)) {
              promise_returned = true;
              return handle_async_and_promise(Error('Invalid Promise: returning promise is not supported in asynchronuous mode')); // Sync style
            }
          } else {
            result = options_handler.call(proxy, opts);
            if (promise.is(result)) { // result is a promisee
              return result.then(function(value) {
                if (!Array.isArray(value)) {
                  value = [value];
                }
                return handle_async_and_promise(null, ...value);
              }, function(reason) {
                if (reason == null) {
                  reason = Error('Rejected Promise: reject called without any arguments');
                }
                return handle_async_and_promise(reason);
              });
            } else {
              if (state.killed) {
                return;
              }
              if (called) {
                return handle_multiple_call(Error('Multiple call detected'));
              }
              called = true;
              status_sync = false;
              wait_children = function() {
                var loptions;
                if (!state.todos.length) {
                  return setImmediate(function() {
                    return do_next([null, status_sync]);
                  });
                }
                loptions = state.todos.shift();
                return run(loptions, function(err, status) {
                  if (err) {
                    return do_next([err]);
                  }
                  if (status && !loptions.shy) {
                    // Discover status of all unshy children
                    status_sync = true;
                  }
                  return wait_children();
                });
              };
              return wait_children();
            }
          }
        } catch (error) {
          err = error;
          state.todos = [];
          return do_next([err]);
        }
      };
      do_intercept_after = function(args, callback) {
        if (options.intercepting) {
          return do_options_after(args);
        }
        return each(state.afters).call(function(after, next) {
          var opts;
          for (k in after) {
            v = after[k];
            switch (k) {
              case 'handler':
                continue;
              case 'type':
                if (!array.compare(v, options[k])) {
                  return next();
                }
                break;
              default:
                if (v !== options[k]) {
                  return next();
                }
            }
          }
          opts = {
            intercepting: true
          };
          for (k in after) {
            v = after[k];
            opts[k] = v;
          }
          for (k in options) {
            v = options[k];
            if (k === 'handler' || k === 'callback') {
              continue;
            }
            if (opts[k] == null) {
              opts[k] = v;
            }
          }
          opts.callback_arguments = args;
          return run(opts, next);
        }).error(function(err) {
          return do_callback([err]);
        }).next(function() {
          return do_options_after(args);
        });
      };
      do_options_after = function(args) {
        if (options.options_after) {
          return do_callback(args);
        }
        if (options.after == null) {
          options.after = [];
        }
        if (!Array.isArray(options.after)) {
          options.after = [options.after];
        }
        return each(options.after).call(function(after, next) {
          var opts;
          after = normalize_options([after], 'call', false);
          after = after[0];
          opts = {
            options_after: true
          };
          for (k in after) {
            v = after[k];
            opts[k] = v;
          }
          for (k in options) {
            v = options[k];
            if (k === 'handler' || k === 'callback') {
              continue;
            }
            if (opts[k] == null) {
              opts[k] = v;
            }
          }
          return run(opts, next);
        }).error(function(err) {
          return do_callback([err]);
        }).next(function() {
          return do_callback(args);
        });
      };
      do_callback = function(args) {
        if (options.header) {
          state.depth--;
        }
        if (options.header) {
          state.headers.pop();
        }
        options.log({
          type: 'handled',
          index: index,
          depth: state.depth,
          error: args[0],
          status: args[1]
        });
        if (state.killed) {
          return;
        }
        if (!args[0]) {
          args[0] = void 0;
        }
        if (options.status) { // Status is a boolean, error or not
          args[1] = !!args[1];
        }
        if (state.todos.length === 0) {
          state.todos = state.stack.shift();
        }
        if (args[0] && !options.relax) {
          jump_to_error(args[0]);
        }
        if (args[0] && options.callback) {
          state.todos.throw_if_error = false;
        }
        if (options.status) {
          // todo: we might want to log here a change of status, sth like:
          // options.log type: 'lifecycle', message: 'status', index: index, depth: state.depth, error: err, status: true if options.status and args[1] and not state.todos.status.some (satus) -> status
          state.todos.status[0].value = args[1];
        }
        if (options.callback) {
          call_callback(options.callback, args);
        }
        if (options.relax) {
          args[0] = null;
        }
        if (callback) {
          callback(args[0], args[1]);
        }
        return run();
      };
      return do_disabled();
    });
  };
  state.properties.child = {
    get: function() {
      return function() {
        return module.exports(obj.options);
      };
    }
  };
  state.properties.next = {
    get: function() {
      return function() {
        state.todos.push({
          type: 'next',
          handler: arguments[0]
        });
        if (state.todos.length === 1) { // Activate the pump
          setImmediate(_run_);
        }
        return proxy;
      };
    }
  };
  state.properties.promise = {
    get: function() {
      return function() {
        var deferred, promise;
        deferred = {};
        promise = new Promise(function(resolve, reject) {
          deferred.resolve = resolve;
          return deferred.reject = reject;
        });
        state.todos.push({
          type: 'promise',
          deferred: deferred // handler: arguments[0],
        });
        if (state.todos.length === 1) { // Activate the pump
          setImmediate(_run_);
        }
        return promise;
      };
    }
  };
  state.properties.end = {
    get: function() {
      return function() {
        var args, j, len, options, opts;
        args = [].slice.call(arguments);
        options = normalize_options(args, 'end');
        for (j = 0, len = options.length; j < len; j++) {
          opts = options[j];
          state.todos.push(opts);
        }
        if (state.todos.length === options.length) { // Activate the pump
          setImmediate(_run_);
        }
        return proxy;
      };
    }
  };
  state.properties.call = {
    get: function() {
      return function() {
        var args, get, j, l, len, len1, mod, options, opts, ref2, values;
        args = [].slice.call(arguments);
        options = normalize_options(args, 'call');
        for (j = 0, len = options.length; j < len; j++) {
          opts = options[j];
          if (typeof opts.handler === 'string') {
            if (opts.handler.substr(0, 1) === '.') {
              opts.handler = path.resolve(process.cwd(), opts.handler);
            }
            mod = require.main.require(opts.handler);
            if (Array.isArray(mod)) {
              throw Error('Array modules not yet supported');
            }
            mod = normalize_options([mod], 'call');
            opts.handler = mod.handler;
            ref2 = mod[0];
            for (k in ref2) {
              v = ref2[k];
              if (opts[k] == null) {
                opts[k] = v;
              }
            }
          }
          if (!opts.handler) {
            throw Error('Missing handler option');
          }
          if (typeof opts.handler !== 'function') {
            throw Error(`Invalid Handler: expect a function, got '${opts.handler}'`);
          }
        }
        ({get, values} = handle_get(proxy, options));
        if (get) {
          return values;
        }
        for (l = 0, len1 = options.length; l < len1; l++) {
          opts = options[l];
          state.todos.push(opts);
        }
        if (state.todos.length === options.length) { // Activate the pump
          setImmediate(_run_);
        }
        return proxy;
      };
    }
  };
  state.properties.each = {
    get: function() {
      return function() {
        var arg, args, j, key, l, len, len1, options, opts, value;
        args = [].slice.call(arguments);
        arg = args.shift();
        if ((arg == null) || typeof arg !== 'object') {
          jump_to_error(Error(`Invalid Argument: first argument must be an array or an object to iterate, got ${JSON.stringify(arg)}`));
          return proxy;
        }
        options = normalize_options(args, 'call');
        for (j = 0, len = options.length; j < len; j++) {
          opts = options[j];
          if (Array.isArray(arg)) {
            for (l = 0, len1 = arg.length; l < len1; l++) {
              key = arg[l];
              opts.key = key;
              this.call(opts);
            }
          } else {
            for (key in arg) {
              value = arg[key];
              opts.key = key;
              opts.value = value;
              this.call(opts);
            }
          }
        }
        return proxy;
      };
    }
  };
  state.properties.before = {
    get: function() {
      return function() {
        var j, len, options, opts;
        if (typeof arguments[0] === 'string' || Array.isArray(arguments[0])) {
          arguments[0] = {
            type: arguments[0]
          };
        }
        options = normalize_options(arguments, null, false);
        for (j = 0, len = options.length; j < len; j++) {
          opts = options[j];
          if (typeof opts.handler !== 'function') {
            throw Error(`Invalid handler ${JSON.stringify(opts.handler)}`);
          }
          state.befores.push(opts);
        }
        return proxy;
      };
    }
  };
  state.properties.after = {
    get: function() {
      return function() {
        var j, len, options, opts;
        if (typeof arguments[0] === 'string' || Array.isArray(arguments[0])) {
          arguments[0] = {
            type: arguments[0]
          };
        }
        options = normalize_options(arguments, null, false);
        for (j = 0, len = options.length; j < len; j++) {
          opts = options[j];
          if (typeof opts.handler !== 'function') {
            throw Error(`Invalid handler ${JSON.stringify(opts.handler)}`);
          }
          state.afters.push(opts);
        }
        return proxy;
      };
    }
  };
  state.properties.status = {
    get: function() {
      return function(index) {
        var j, l, len, len1, ref2, ref3, ref4, status, value;
        if (arguments.length === 0) {
          return state.stack[0].status.some(function(status) {
            return !status.shy && !!status.value;
          });
        } else if (index === false) {
          value = state.stack[0].status.some(function(status) {
            return !status.shy && !!status.value;
          });
          ref2 = state.stack[0].status;
          for (j = 0, len = ref2.length; j < len; j++) {
            status = ref2[j];
            status.value = false;
          }
          return value;
        } else if (index === true) {
          value = state.stack[0].status.some(function(status) {
            return !status.shy && !!status.value;
          });
          ref3 = state.stack[0].status;
          for (l = 0, len1 = ref3.length; l < len1; l++) {
            status = ref3[l];
            status.value = true;
          }
          return value;
        } else {
          return (ref4 = state.stack[0].status[Math.abs(index)]) != null ? ref4.value : void 0;
        }
      };
    }
  };
  Object.defineProperties(obj, state.properties);
  reg = registry.registry({});
  Object.defineProperty(obj.registry, 'get', {
    get: function() {
      return function(name, handler) {
        return reg.get(...arguments);
      };
    }
  });
  Object.defineProperty(obj.registry, 'register', {
    get: function() {
      return function(name, handler) {
        reg.register(...arguments);
        return proxy;
      };
    }
  });
  Object.defineProperty(obj.registry, 'registered', {
    get: function() {
      return function(name, handler) {
        return reg.registered(...arguments);
      };
    }
  });
  Object.defineProperty(obj.registry, 'unregister', {
    get: function() {
      return function(name, handler) {
        reg.unregister(...arguments);
        return proxy;
      };
    }
  });
  if (obj.options.ssh) {
    if (obj.options.ssh.config) {
      obj.store['nikita:ssh:connection'] = obj.options.ssh;
      delete obj.options.ssh;
    } else {
      if (!obj.options.no_ssh) {
        proxy.ssh.open(obj.options.ssh);
      }
    }
  }
  return proxy;
};

module.exports.propagation = {
  cwd: true,
  ssh: true,
  log: true,
  stdout: true,
  stderr: true,
  debug: true,
  after: false,
  before: false,
  disabled: false,
  domain: false,
  handler: false,
  header: false,
  once: false,
  relax: false,
  shy: false,
  sleep: false,
  sudo: true
};

// ## Helper functions
todos_create = function() {
  var todos;
  todos = [];
  todos_reset(todos);
  return todos;
};

todos_reset = function(todos) {
  todos.err = null;
  todos.status = [];
  return todos.throw_if_error = true;
};

handle_get = function(proxy, options) {
  var get, opts, values;
  if (options.length !== 1) {
    return {
      get: false
    };
  }
  if (options.length === options.filter(function(opts) {
    return opts.get === true;
  }).length) {
    get = true;
    values = (function() {
      var j, len, results;
      results = [];
      for (j = 0, len = options.length; j < len; j++) {
        opts = options[j];
        results.push(opts.handler.call(proxy, opts, opts.callback));
      }
      return results;
    })();
    if (values.length === 1) {
      values = values[0];
    }
  }
  return {
    get: get,
    values: values
  };
};

// ## Dependencies
registry = require('./registry');

domain = require('domain');

each = require('each');

path = require('path');

util = require('util');

array = require('./misc/array');

promise = require('./misc/promise');

conditions = require('./misc/conditions');

wrap = require('./misc/wrap');

string = require('./misc/string');

({merge} = require('./misc'));

({EventEmitter} = require('events'));
