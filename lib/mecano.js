// Generated by CoffeeScript 1.6.3
var EventEmitter, Ftp, child, conditions, each, eco, exec, fs, ini, ldap, ldap_client, mecano, misc, path, request, url, util;

fs = require('fs');

path = require('path');

url = require('url');

util = require('util');

each = require('each');

eco = require('eco');

exec = require('superexec');

request = require('request');

ini = require('ini');

Ftp = require('jsftp');

ldap = require('ldapjs');

ldap_client = require('ldapjs/lib/client/client');

EventEmitter = require('events').EventEmitter;

conditions = require('./conditions');

misc = require('./misc');

child = require('./child');

/*

Mecano gather a set of functions usually used during system deployment. All the functions share a 
common API with flexible options.

Functions include "copy", "download", "exec", "extract", "git", "link", "mkdir", "move", "remove", "render", "service", "write". They all share common usages and philosophies:   
*   Run actions both locally and remotely over SSH.   
*   Ability to see if an action had an effect through the second argument provided in the callback.   
*   Common API with options and callback arguments and calling the callback with an error and the number of affected actions.   
*   Run one or multiple actions depending on option argument being an object or an array of objects.
*/


mecano = module.exports = {
  /*
  
  `cp` `copy(options, callback)`
  ------------------------------
  
  Copy a file. The behavior is similar to the one of the `cp` 
  Unix utility. Copying a file over an existing file will 
  overwrite it.
  
  `options`           Command options include:   
  
  *   `source`        The file or directory to copy.
  *   `destination`   Where the file or directory is copied.
  *   `not_if_exists` Equals destination if true.
  *   `mode`          Permissions of the file or the parent directory
  *   `ssh`           Run the action on a remote server using SSH, an ssh2 instance or an configuration object used to initialize the SSH connection.   
   
  `callback`          Received parameters are:   
  
  *   `err`           Error object if any.   
  *   `copied`        Number of files or parent directories copied.
  
  todo:
  *   preserve permissions if `mode` is `true`
  */

  copy: function(options, callback) {
    return misc.options(options, function(err, options) {
      var copied;
      if (err) {
        return callback(err);
      }
      copied = 0;
      return each(options).on('item', function(options, next) {
        var search;
        if (!options.source) {
          return next(new Error('Missing source'));
        }
        if (!options.destination) {
          return next(new Error('Missing destination'));
        }
        if (options.not_if_exists === true) {
          options.not_if_exists = options.destination;
        }
        search = function() {
          var chmod, copy, copyDir, copyFile, directory, dstStat, finish, srcStat;
          srcStat = null;
          dstStat = null;
          misc.file.stat(options.ssh, options.source, function(err, stat) {
            if (err) {
              return next(err);
            }
            srcStat = stat;
            return misc.file.stat(options.ssh, options.destination, function(err, stat) {
              var sourceEndWithSlash;
              if (err && err.code !== 'ENOENT') {
                return next(err);
              }
              dstStat = stat;
              sourceEndWithSlash = options.source.lastIndexOf('/') === options.source.length - 1;
              if (srcStat.isDirectory() && dstStat && !sourceEndWithSlash) {
                options.destination = path.resolve(options.destination, path.basename(options.source));
              }
              if (srcStat.isDirectory()) {
                return directory(options.source);
              } else {
                return copy(options.source, next);
              }
            });
          });
          directory = function(dir) {
            return each().files("" + dir + "/**").on('item', function(file, next) {
              return copy(file, next);
            }).on('both', next);
          };
          copy = function(source, next) {
            var destination;
            if (srcStat.isDirectory()) {
              destination = path.resolve(options.destination, path.relative(options.source, source));
            } else if (!srcStat.isDirectory() && (dstStat != null ? dstStat.isDirectory() : void 0)) {
              destination = path.resolve(options.destination, path.basename(source));
            } else {
              destination = options.destination;
            }
            return misc.file.stat(options.ssh, source, function(err, stat) {
              if (err) {
                return next(err);
              }
              if (stat.isDirectory()) {
                return copyDir(source, destination, next);
              } else {
                return copyFile(source, destination, next);
              }
            });
          };
          copyDir = function(source, destination, next) {
            if (source === options.source) {
              return next();
            }
            return misc.file.mkdir(options.ssh, destination, function(err) {
              if ((err != null ? err.code : void 0) === 'EEXIST') {
                return next();
              }
              if (err) {
                return next(err);
              }
              return finish(next);
            });
          };
          copyFile = function(source, destination, next) {
            return misc.file.compare(options.ssh, [source, destination], function(err, md5) {
              var s;
              if (err && err.message.indexOf('Does not exist') !== 0) {
                return next(err);
              }
              if (md5) {
                return next();
              }
              s = function(ssh, callback) {
                if (!ssh) {
                  return callback(null, fs);
                } else {
                  return options.ssh.sftp(callback);
                }
              };
              return s(options.ssh, function(err, fs) {
                var rs, ws;
                rs = fs.createReadStream(source);
                ws = rs.pipe(fs.createWriteStream(destination));
                ws.on('close', function() {
                  if (fs.end) {
                    fs.end();
                  }
                  return chmod(source, next);
                });
                return ws.on('error', next);
              });
            });
          };
          chmod = function(file, next) {
            if (!options.mode || options.mode === dstStat.mode) {
              return finish(next);
            }
            return misc.file.chmod(options.ssh, options.destination, options.mode, function(err) {
              if (err) {
                return next(err);
              }
              return finish(next);
            });
          };
          return finish = function(next) {
            copied++;
            return next();
          };
        };
        return conditions.all(options, next, search);
      }).on('both', function(err) {
        return callback(err, copied);
      });
    });
  },
  /*
  
  `download(options, callback)`
  -----------------------------
  
  Download files using various protocols.
  
  When executed locally: the `http` protocol is handled 
  with the "request" module; the `ftp` protocol is handled 
  with the "jsftp"; the `file` protocol is handle with the navite 
  `fs` module.
  
  `options`           Command options include:   
  
  *   `source`        File, HTTP URL, FTP, GIT repository. File is the default protocol if source is provided without any.   
  *   `destination`   Path where the file is downloaded.   
  *   `force`         Overwrite destination file if it exists.   
  *   `stdout`        Writable Stream in which commands output will be piped.   
  *   `stderr`        Writable Stream in which commands error will be piped.   
  
  `callback`          Received parameters are:   
  
  *   `err`           Error object if any.   
  *   `downloaded`    Number of downloaded files
  
  File example
  
      mecano.download
        source: 'file://path/to/something'
        destination: 'node-sigar.tgz'
      , (err, downloaded) -> ...
  
  HTTP example
  
      mecano.download
        source: 'https://github.com/wdavidw/node-sigar/tarball/v0.0.1'
        destination: 'node-sigar.tgz'
      , (err, downloaded) -> ...
  
  FTP example
  
      mecano.download
        source: 'ftp://myhost.com:3334/wdavidw/node-sigar/tarball/v0.0.1'
        destination: 'node-sigar.tgz'
        user: "johndoe",
        pass: "12345"
      , (err, downloaded) -> ...
  
  File example
  */

  download: function(options, callback) {
    var finish, result;
    result = child(mecano);
    finish = function(err, downloaded) {
      if (callback) {
        callback(err, downloaded);
      }
      return result.end(err, downloaded);
    };
    return misc.options(options, function(err, options) {
      var downloaded;
      if (err) {
        return finish(err);
      }
      downloaded = 0;
      return each(options).on('item', function(options, next) {
        var checksum, destination, download, md5sum, prepare, source, stageDestination, unstage;
        destination = options.destination, source = options.source, md5sum = options.md5sum;
        if (!source) {
          return next(new Error("Missing source: " + source));
        }
        if (!destination) {
          return next(new Error("Missing destination: " + destination));
        }
        if (options.force == null) {
          options.force = false;
        }
        stageDestination = "" + destination + "." + (Date.now()) + (Math.round(Math.random() * 1000));
        prepare = function() {
          return misc.file.exists(options.ssh, destination, function(err, exists) {
            if (exists && !options.force) {
              if (!md5sum) {
                return next();
              }
              return misc.file.hash(options.ssh, destination, 'md5', function(err, hash) {
                if (hash === md5sum) {
                  return next();
                }
                return misc.file.unlink(options.ssh, destination, function(err) {
                  if (err) {
                    return next(err);
                  }
                  return download();
                });
              });
            } else if (exists) {
              return mecano.remove({
                ssh: options.ssh,
                destination: destination
              }, function(err) {
                if (err) {
                  return next(err);
                }
                return download();
              });
            } else {
              return download();
            }
          });
        };
        download = function() {
          var cmd, ftp, pass, rs, u, user, ws, _ref;
          u = url.parse(source);
          if (options.ssh) {
            if (u.protocol === 'http:') {
              cmd = "curl " + source + " -o " + stageDestination;
              if (options.proxy) {
                cmd += " -x " + options.proxy;
              }
              return mecano.execute({
                ssh: options.ssh,
                cmd: cmd,
                stdout: options.stdout,
                stderr: options.stderr
              }, function(err, executed, stdout, stderr) {
                if (err) {
                  return next(curl.error(err));
                }
                return checksum();
              });
            } else if (u.protocol === 'ftp:') {
              return next(new Error('FTP download not supported over SSH'));
            } else {
              return options.ssh.sftp(function(err, sftp) {
                var rs, ws;
                if (err) {
                  return next(err);
                }
                rs = sftp.createReadStream(u.pathname);
                ws = rs.pipe(fs.createWriteStream(stageDestination));
                ws.on('close', function() {
                  return checksum();
                });
                return ws.on('error', next);
              });
            }
          } else {
            ws = fs.createWriteStream(stageDestination);
            if (u.protocol === 'http:') {
              options.url = source;
              request(options).pipe(ws);
            } else if (u.protocol === 'ftp:') {
              if (options.host == null) {
                options.host = u.hostname;
              }
              if (options.port == null) {
                options.port = u.port;
              }
              if (u.auth) {
                _ref = u.auth.split(':'), user = _ref.user, pass = _ref.pass;
              }
              if (options.user == null) {
                options.user = user;
              }
              if (options.pass == null) {
                options.pass = pass;
              }
              ftp = new Ftp(options);
              ftp.getGetSocket(u.pathname, function(err, rs) {
                if (err) {
                  return next(err);
                }
                rs.pipe(ws);
                return rs.resume();
              });
            } else {
              rs = fs.createReadStream(u.pathname);
              rs.pipe(ws);
            }
            ws.on('close', function() {
              return checksum();
            });
            return ws.on('error', function(err) {
              return mecano.remove(ws, function(err) {
                return next(err);
              });
            });
          }
        };
        checksum = function() {
          if (!md5sum) {
            return unstage();
          }
          return misc.file.hash(options.ssh, stageDestination, 'md5', function(err, hash) {
            if (hash === md5sum) {
              return unstage();
            }
            return misc.file.remove(options.ssh, stageDestination, function(err) {
              if (err) {
                return next(err);
              }
              return next(new Error("Invalid checksum, found \"" + hash + "\" instead of \"" + md5sum + "\""));
            });
          });
        };
        unstage = function() {
          return misc.file.rename(options.ssh, stageDestination, destination, function(err) {
            if (err) {
              return next(err);
            }
            downloaded++;
            return next();
          });
        };
        return prepare();
      }).on('both', function(err) {
        return finish(err, downloaded);
      });
    });
  },
  /*
  
  `exec` `execute([goptions], options, callback)`
  -----------------------------------------------
  Run a command locally or with ssh if `host` or `ssh` is provided.
  
  `options`           Command options include:   
  
  *   `cmd`           String, Object or array; Command to execute.   
  *   `env`           Environment variables, default to `process.env`.   
  *   `cwd`           Current working directory.   
  *   `uid`           Unix user id.   
  *   `gid`           Unix group id.   
  *   `code`          Expected code(s) returned by the command, int or array of int, default to 0.  
  *   `code_skipped`  Expected code(s) returned by the command if it has no effect, executed will not be incremented, int or array of int.   
  *   `stdout`        Writable Stream in which commands output will be piped.   
  *   `stderr`        Writable Stream in which commands error will be piped.   
  *   `ssh`           Run the action on a remote server using SSH, an ssh2 instance or an configuration object used to initialize the SSH connection.   
  
  `callback`          Received parameters are:   
  
  *   `err`           Error if any.   
  *   `executed`      Number of executed commandes.   
  *   `stdout`        Stdout value(s) unless `stdout` option is provided.   
  *   `stderr`        Stderr value(s) unless `stderr` option is provided.
  */

  execute: function(options, callback) {
    var finish, isArray, result;
    result = child(mecano);
    finish = function(err, created, stdout, stderr) {
      if (callback) {
        callback(err, created, stdout, stderr);
      }
      return result.end(err, created);
    };
    isArray = Array.isArray(options);
    misc.options(options, function(err, options) {
      var escape, executed, stderrs, stdouts, stds;
      if (err) {
        return finish(err);
      }
      executed = 0;
      stdouts = [];
      stderrs = [];
      escape = function(cmd) {
        var char, esccmd, _i, _len;
        esccmd = '';
        for (_i = 0, _len = cmd.length; _i < _len; _i++) {
          char = cmd[_i];
          if (char === '$') {
            esccmd += '\\';
          }
          esccmd += char;
        }
        return esccmd;
      };
      stds = callback ? callback.length > 2 : false;
      return each(options).parallel(true).on('item', function(options, i, next) {
        var cmd;
        if (typeof options === 'string') {
          options = {
            cmd: options
          };
        }
        if (options.cmd == null) {
          return next(new Error("Missing cmd: " + options.cmd));
        }
        if (options.code == null) {
          options.code = [0];
        }
        if (!Array.isArray(options.code)) {
          options.code = [options.code];
        }
        if (options.code_skipped == null) {
          options.code_skipped = [];
        }
        if (!Array.isArray(options.code_skipped)) {
          options.code_skipped = [options.code_skipped];
        }
        cmd = function() {
          var run, stderr, stdout;
          run = exec(options);
          stdout = stderr = [];
          if (options.stdout) {
            run.stdout.pipe(options.stdout, {
              end: false
            });
          }
          if (stds) {
            run.stdout.on('data', function(data) {
              return stdout.push(data);
            });
          }
          if (options.stderr) {
            run.stderr.pipe(options.stderr, {
              end: false
            });
          }
          if (stds) {
            run.stderr.on('data', function(data) {
              return stderr.push(data);
            });
          }
          return run.on("exit", function(code) {
            return setTimeout(function() {
              stdouts.push(stds ? stdout.join('') : void 0);
              stderrs.push(stds ? stderr.join('') : void 0);
              if (options.stdout) {
                run.stdout.unpipe(options.stdout);
              }
              if (options.stderr) {
                run.stderr.unpipe(options.stderr);
              }
              if (options.code.indexOf(code) === -1 && options.code_skipped.indexOf(code) === -1) {
                err = new Error("Invalid exec code " + code);
                err.code = code;
                return next(err);
              }
              if (options.code_skipped.indexOf(code) === -1) {
                executed++;
              }
              return next();
            }, 1);
          });
        };
        return conditions.all(options, next, cmd);
      }).on('both', function(err) {
        if (!isArray) {
          stdouts = stdouts[0];
        }
        if (!isArray) {
          stderrs = stderrs[0];
        }
        return finish(err, executed, stdouts, stderrs);
      });
    });
    return result;
  },
  /*
  
  `extract(options, callback)` 
  ----------------------------
  
  Extract an archive. Multiple compression types are supported. Unless 
  specified as an option, format is derived from the source extension. At the 
  moment, supported extensions are '.tgz', '.tar.gz' and '.zip'.   
  
  `options`           Command options include:   
  
  *   `source`        Archive to decompress.   
  *   `destination`   Default to the source parent directory.   
  *   `format`        One of 'tgz' or 'zip'.   
  *   `creates`       Ensure the given file is created or an error is send in the callback.   
  *   `not_if_exists` Cancel extraction if file exists.   
  *   `ssh`           Run the action on a remote server using SSH, an ssh2 instance or an configuration object used to initialize the SSH connection.   
  
  `callback`          Received parameters are:   
  
  *   `err`           Error object if any.   
  *   `extracted`     Number of extracted archives.
  */

  extract: function(options, callback) {
    return misc.options(options, function(err, options) {
      var extracted;
      if (err) {
        return callback(err);
      }
      extracted = 0;
      return each(options).on('item', function(options, next) {
        var creates, destination, ext, extract, format, success, _ref;
        if (!options.source) {
          return next(new Error("Missing source: " + options.source));
        }
        destination = (_ref = options.destination) != null ? _ref : path.dirname(options.source);
        if (options.format != null) {
          format = options.format;
        } else {
          if (/\.(tar\.gz|tgz)$/.test(options.source)) {
            format = 'tgz';
          } else if (/\.zip$/.test(options.source)) {
            format = 'zip';
          } else {
            ext = path.extname(options.source);
            return next(new Error("Unsupported extension, got " + (JSON.stringify(ext))));
          }
        }
        extract = function() {
          var cmd;
          cmd = null;
          switch (format) {
            case 'tgz':
              cmd = "tar xzf " + options.source + " -C " + destination;
              break;
            case 'zip':
              cmd = "unzip -u " + options.source + " -d " + destination;
          }
          options.cmd = cmd;
          return exec(options, function(err, stdout, stderr) {
            if (err) {
              return next(err);
            }
            return creates();
          });
        };
        creates = function() {
          if (options.creates == null) {
            return success();
          }
          return misc.file.exists(options.ssh, options.creates, function(err, exists) {
            if (!exists) {
              return next(new Error("Failed to create '" + (path.basename(options.creates)) + "'"));
            }
            return success();
          });
        };
        success = function() {
          extracted++;
          return next();
        };
        if (typeof options.should_exist === 'undefined') {
          options.should_exist = options.source;
        }
        return conditions.all(options, next, extract);
      }).on('both', function(err) {
        return callback(err, extracted);
      });
    });
  },
  /*
  
  `git`
  -----
  
  `options`           Command options include:   
  
  *   `source`        Git source repository address.   
  *   `destination`   Directory where to clone the repository.   
  *   `revision`      Git revision, branch or tag.   
  *   `ssh`           Run the action on a remote server using SSH, an ssh2 instance or an configuration object used to initialize the SSH connection.   
  *   `stdout`        Writable EventEmitter in which command output will be piped.   
  *   `stderr`        Writable EventEmitter in which command error will be piped.
  */

  git: function(options, callback) {
    return misc.options(options, function(err, options) {
      var updated;
      if (err) {
        return callback(err);
      }
      updated = 0;
      return each(options).on('item', function(options, next) {
        var checkout, clone, log, prepare, rev;
        if (options.revision == null) {
          options.revision = 'HEAD';
        }
        rev = null;
        prepare = function() {
          return misc.file.exists(options.ssh, options.destination, function(err, exists) {
            var gitDir;
            if (err) {
              return next(err);
            }
            if (!exists) {
              return clone();
            }
            gitDir = "" + options.destination + "/.git";
            return misc.file.exists(options.ssh, gitDir, function(err, exists) {
              if (!exists) {
                return next(new Error("Not a git repository"));
              }
              return log();
            });
          });
        };
        clone = function() {
          return mecano.exec({
            ssh: options.ssh,
            cmd: "git clone " + options.source + " " + options.destination,
            cwd: path.dirname(options.destination),
            stdout: options.stdout,
            stderr: options.stderr
          }, function(err, executed, stdout, stderr) {
            if (err) {
              return next(err);
            }
            return checkout();
          });
        };
        log = function() {
          return mecano.exec({
            ssh: options.ssh,
            cmd: "git log --pretty=format:'%H' -n 1",
            cwd: options.destination,
            stdout: options.stdout,
            stderr: options.stderr
          }, function(err, executed, stdout, stderr) {
            var current;
            if (err) {
              return next(err);
            }
            current = stdout.trim();
            return mecano.exec({
              ssh: options.ssh,
              cmd: "git rev-list --max-count=1 " + options.revision,
              cwd: options.destination,
              stdout: options.stdout,
              stderr: options.stderr
            }, function(err, executed, stdout, stderr) {
              if (err) {
                return next(err);
              }
              if (stdout.trim() !== current) {
                return checkout();
              } else {
                return next();
              }
            });
          });
        };
        checkout = function() {
          return mecano.exec({
            ssh: options.ssh,
            cmd: "git checkout " + options.revision,
            cwd: options.destination,
            stdout: options.stdout,
            stderr: options.stderr
          }, function(err) {
            if (err) {
              return next(err);
            }
            updated++;
            return next();
          });
        };
        return conditions.all(options, next, prepare);
      }).on('both', function(err) {
        return callback(err, updated);
      });
    });
  },
  /*
  
  `ini(options, callback`
  -----------------------
  Write an object as .ini file. Note, we are internally using the
  [ini](https://github.com/isaacs/ini) module. However, there is 
  a subtile difference. Any key provided with value of `undefined` 
  or `null` will be disregarded. Within a `merge`, it get more prowerfull
  and tricky: the original value will be kept if `undefined` is provided 
  while the value will be removed if `null` is provided.
  
  The `ini` function rely on the `write` function and accept all of its 
  options. It introduces the `merge` option which instruct to read the
  destination file if it exists and merge its parsed object with the one
  provided in the `content` option.
  
  `options`           Command options include:   
  
  *   `append`        Append the content to the destination file. If destination does not exist, the file will be created. When used with the `match` and `replace` options, it will append the `replace` value at the end of the file if no match if found and if the value is a string.   
  *   `backup`        Create a backup, append a provided string to the filename extension or a timestamp if value is not a string.   
  *   `content`       Object to stringify.   
  *   `stringify`     User defined function to stringify to ini format, default to `require('ini').stringify`.   
  *   `destination`   File path where to write content to or a callback.   
  *   `from`          Replace from after this marker, a string or a regular expression.   
  *   `local_source`  Treat the source as local instead of remote, only apply with "ssh" option.   
  *   `match`         Replace this marker, a string or a regular expression.   
  *   `merge`         Read the destination if it exists and merge its content.   
  *   `replace`       The content to be inserted, used conjointly with the from, to or match options.   
  *   `source`        File path from where to extract the content, do not use conjointly with content.   
  *   `ssh`           Run the action on a remote server using SSH, an ssh2 instance or an configuration object used to initialize the SSH connection.   
  *   `to`            Replace to before this marker, a string or a regular expression.
  */

  ini: function(options, callback) {
    var clean, finish, result;
    clean = function(content, undefinedOnly) {
      var k, v;
      for (k in content) {
        v = content[k];
        if (v && typeof v === 'object') {
          content[k] = clean(v, undefinedOnly);
          continue;
        }
        if (typeof v === 'undefined') {
          delete content[k];
        }
        if (!undefinedOnly && v === null) {
          delete content[k];
        }
      }
      return content;
    };
    result = child(mecano);
    finish = function(err, written) {
      if (callback) {
        callback(err, written);
      }
      return result.end(err, written);
    };
    misc.options(options, function(err, options) {
      var written;
      if (err) {
        return finish(err);
      }
      written = 0;
      return each(options).on('item', function(options, next) {
        var content, destination, get, merge, ssh, write;
        merge = options.merge, destination = options.destination, content = options.content, ssh = options.ssh;
        if (!content) {
          return next(new Error('Missing content'));
        }
        if (!destination) {
          return next(new Error('Missing destination'));
        }
        get = function() {
          if (!merge) {
            return write();
          }
          return misc.file.exists(ssh, destination, function(err, exists) {
            if (err) {
              return next(err);
            }
            if (!exists) {
              return write();
            }
            return misc.file.readFile(ssh, destination, 'ascii', function(err, c) {
              if (err && err.code !== 'ENOENT') {
                return next(err);
              }
              content = clean(content, true);
              content = misc.merge(ini.parse(c), content);
              return write();
            });
          });
        };
        write = function() {
          var stringify;
          clean(content);
          stringify = options.stringify || ini.stringify;
          options.content = stringify(content);
          return mecano.write(options, function(err, w) {
            written += w;
            return next(err);
          });
        };
        return get();
      }).on('both', function(err) {
        return finish(err, written);
      });
    });
    return result;
  },
  /*
  
  `ldap_acl(options, callback`
  ----------------------------
  
  `options`           Command options include:   
  
  *   `to`            What to control access to as a string.   
  *   `by`            Who to grant access to and the access to grant as an array (eg: `{..., by:["ssf=64 anonymous auth"]}`)   
  *   `url`           Specify URI referring to the ldap server, alternative to providing an [ldapjs client] instance.  
  *   `binddn`        Distinguished Name to bind to the LDAP directory, alternative to providing an [ldapjs client] instance.  
  *   `passwd`        Password for simple authentication, alternative to providing an [ldapjs client] instance.   
  *   `ldap`          Instance of an pldapjs client][ldapclt], alternative to providing the `url`, `binddn` and `passwd` connection properties.   
  *   `unbind`        Close the ldap connection, default to false if connection is an [ldapjs client][ldapclt] instance.   
  *   `name`          Distinguish name storing the "olcAccess" property, using the database adress (eg: "olcDatabase={2}bdb,cn=config").   
  *   `overwrite`     Overwrite existing "olcAccess", default is to merge.   
  
  Resources:
  http://www.openldap.org/doc/admin24/access-control.html
  
  [ldapclt]: http://ldapjs.org/client.html
  */

  ldap_acl: function(options, callback) {
    var finish, result;
    result = child(mecano);
    finish = function(err, modified) {
      if (callback) {
        callback(err, modified);
      }
      return result.end(err, modified);
    };
    misc.options(options, function(err, options) {
      var modified;
      if (err) {
        return finish(err);
      }
      modified = 0;
      return each(options).on('item', function(options, next) {
        var b, client, connect, diff, end, i, parse, save, search, stringify, unbind, updated, _i, _len, _ref;
        client = null;
        updated = false;
        options.to = options.to.trim();
        _ref = options.by;
        for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
          b = _ref[i];
          options.by[i] = b.trim();
        }
        connect = function() {
          if (options.ldap instanceof ldap_client) {
            client = options.ldap;
            return search();
          }
          client = ldap.createClient({
            url: options.url
          });
          return client.bind(options.binddn, options.passwd, function(err) {
            if (err) {
              return end(err);
            }
            return search();
          });
        };
        search = function() {
          return client.search(options.name, {
            scope: 'base',
            attributes: ['olcAccess']
          }, function(err, search) {
            var olcAccess;
            if (err) {
              return unbind(err);
            }
            olcAccess = null;
            search.on('searchEntry', function(entry) {
              olcAccess = entry.object.olcAccess || [];
              if (!Array.isArray(olcAccess)) {
                return olcAccess = [olcAccess];
              }
            });
            return search.on('end', function() {
              return parse(olcAccess);
            });
          });
        };
        parse = function(_olcAccess) {
          var access, buf, buftype, bys, c, matches, olcAccess, to, _j, _k, _len1, _len2;
          olcAccess = [];
          for (i = _j = 0, _len1 = _olcAccess.length; _j < _len1; i = ++_j) {
            access = _olcAccess[i];
            to = '';
            bys = [];
            buftype = 0;
            buf = '';
            for (i = _k = 0, _len2 = access.length; _k < _len2; i = ++_k) {
              c = access[i];
              buf += c;
              if (buftype === 0) {
                if (/to$/.test(buf)) {
                  buf = '';
                  buftype = 1;
                }
              }
              if (buftype === 1) {
                if (matches = /^(.*)by$/.exec(buf)) {
                  to = matches[1].trim();
                  buf = '';
                  buftype = 2;
                }
              }
              if (buftype === 2) {
                if (matches = /^(.*)by$/.exec(buf)) {
                  bys.push(matches[1].trim());
                  buf = '';
                } else if (i + 1 === access.length) {
                  bys.push(buf.trim());
                }
              }
            }
            olcAccess.push({
              to: to,
              by: bys
            });
          }
          return diff(olcAccess);
        };
        diff = function(olcAccess) {
          var aby, access, fby, found, oby, toAlreadyExist, _j, _k, _l, _len1, _len2, _len3, _ref1, _ref2;
          toAlreadyExist = false;
          for (i = _j = 0, _len1 = olcAccess.length; _j < _len1; i = ++_j) {
            access = olcAccess[i];
            if (options.to !== access.to) {
              continue;
            }
            toAlreadyExist = true;
            fby = !options.overwrite ? access.by : [];
            _ref1 = options.by;
            for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
              oby = _ref1[_k];
              found = false;
              _ref2 = access.by;
              for (_l = 0, _len3 = _ref2.length; _l < _len3; _l++) {
                aby = _ref2[_l];
                if (oby === aby) {
                  found = true;
                  break;
                }
              }
              if (!found) {
                updated = true;
                fby.push(oby);
              }
            }
            olcAccess[i].by = fby;
          }
          if (!toAlreadyExist) {
            updated = true;
            olcAccess.push({
              to: options.to,
              by: options.by
            });
          }
          if (updated) {
            return stringify(olcAccess);
          } else {
            return unbind();
          }
        };
        stringify = function(olcAccess) {
          var access, bie, value, _j, _k, _len1, _len2, _ref1;
          for (i = _j = 0, _len1 = olcAccess.length; _j < _len1; i = ++_j) {
            access = olcAccess[i];
            value = "{" + i + "}to " + access.to;
            _ref1 = access.by;
            for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
              bie = _ref1[_k];
              value += " by " + bie;
            }
            olcAccess[i] = value;
          }
          return save(olcAccess);
        };
        save = function(olcAccess) {
          var change;
          change = new ldap.Change({
            operation: 'replace',
            modification: {
              olcAccess: olcAccess
            }
          });
          return client.modify(options.name, change, function(err) {
            return unbind(err);
          });
        };
        unbind = function(err) {
          if (options.ldap instanceof ldap_client && !options.unbind) {
            return end(err);
          }
          return client.unbind(function(e) {
            if (e) {
              return next(e);
            }
            return end(err);
          });
        };
        end = function(err) {
          if (updated && !err) {
            modified += 1;
          }
          return next(err);
        };
        return conditions.all(options, next, connect);
      }).on('both', function(err) {
        return finish(err, modified);
      });
    });
    return result;
  },
  /*
  
  `ldap_index(options, callback`
  ------------------------------
  
  `options`           Command options include:   
  
  *   `indexes`       Object with keys mapping to indexed attributes and values mapping to indices ("pres", "approx", "eq", "sub" and 'special').   
  *   `url`           Specify URI referring to the ldap server, alternative to providing an [ldapjs client] instance.  
  *   `binddn`        Distinguished Name to bind to the LDAP directory, alternative to providing an [ldapjs client] instance.  
  *   `passwd`        Password for simple authentication, alternative to providing an [ldapjs client] instance.   
  *   `ldap`          Instance of an pldapjs client][ldapclt], alternative to providing the `url`, `binddn` and `passwd` connection properties.   
  *   `unbind`        Close the ldap connection, default to false if connection is an [ldapjs client][ldapclt] instance.   
  *   `name`          Distinguish name storing the "olcAccess" property, using the database adress (eg: "olcDatabase={2}bdb,cn=config").   
  *   `overwrite`     Overwrite existing "olcAccess", default is to merge.   
  
  Resources
  http://www.zytrax.com/books/ldap/apa/indeces.html
  */

  ldap_index: function(options, callback) {
    var finish, result;
    result = child(mecano);
    finish = function(err, created) {
      if (callback) {
        callback(err, created);
      }
      return result.end(err, created);
    };
    misc.options(options, function(err, options) {
      var modified;
      if (err) {
        return finish(err);
      }
      modified = 0;
      return each(options).on('item', function(options, next) {
        var client, connect, diff, end, get, parse, replace, stringifiy, unbind, updated;
        client = null;
        updated = false;
        connect = function() {
          if (options.ldap instanceof ldap_client) {
            client = options.ldap;
            return get();
          }
          client = ldap.createClient({
            url: options.url
          });
          return client.bind(options.binddn, options.passwd, function(err) {
            if (err) {
              return end(err);
            }
            return get();
          });
        };
        get = function() {
          return client.search('olcDatabase={2}bdb,cn=config', {
            scope: 'base',
            attributes: ['olcDbIndex']
          }, function(err, search) {
            var olcDbIndex;
            olcDbIndex = null;
            search.on('searchEntry', function(entry) {
              return olcDbIndex = entry.object.olcDbIndex;
            });
            return search.on('end', function() {
              return parse(olcDbIndex);
            });
          });
        };
        parse = function(arIndex) {
          var index, indexes, k, v, _i, _len, _ref;
          indexes = {};
          for (_i = 0, _len = arIndex.length; _i < _len; _i++) {
            index = arIndex[_i];
            _ref = index.split(' '), k = _ref[0], v = _ref[1];
            indexes[k] = v;
          }
          return diff(indexes);
        };
        diff = function(orgp) {
          var i, newp, nkl, okl, _i, _ref;
          if (!options.overwrite) {
            newp = misc.merge({}, orgp, options.indexes);
          } else {
            newp = options.indexes;
          }
          okl = Object.keys(orgp).sort();
          nkl = Object.keys(newp).sort();
          for (i = _i = 0, _ref = Math.min(okl.length, nkl.length); 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
            if (i === okl.length || i === nkl.length || okl[i] !== nkl[i] || orgp[okl[i]] !== newp[nkl[i]]) {
              updated = true;
              break;
            }
          }
          if (updated) {
            return stringifiy(newp);
          } else {
            return unbind();
          }
        };
        stringifiy = function(perms) {
          var indexes, k, v;
          indexes = [];
          for (k in perms) {
            v = perms[k];
            indexes.push("" + k + " " + v);
          }
          return replace(indexes);
        };
        replace = function(indexes) {
          var change;
          change = new ldap.Change({
            operation: 'replace',
            modification: {
              olcDbIndex: indexes
            }
          });
          return client.modify(options.name, change, function(err) {
            return unbind(err);
          });
        };
        unbind = function(err) {
          if (options.ldap instanceof ldap_client && !options.unbind) {
            return end(err);
          }
          return client.unbind(function(e) {
            if (e) {
              return next(e);
            }
            return end(err);
          });
        };
        end = function(err) {
          if (updated && !err) {
            modified += 1;
          }
          return next(err);
        };
        return conditions.all(options, next, connect);
      }).on('both', function(err) {
        return finish(err, modified);
      });
    });
    return result;
  },
  /*
  
  `ln` `link(options, callback)`
  ------------------------------
  Create a symbolic link and it's parent directories if they don't yet
  exist.
  
  `options`           Command options include:   
  
  *   `source`        Referenced file to be linked.   
  *   `destination`   Symbolic link to be created.   
  *   `exec`          Create an executable file with an `exec` command.   
  *   `mode`          Default to 0755.   
  
  `callback`          Received parameters are:   
  
  *   `err`           Error object if any.   
  *   `linked`        Number of created links.
  */

  link: function(options, callback) {
    return misc.options(options, function(err, options) {
      var exec_create, exec_exists, linked, option, parents, sym_create, sym_exists;
      if (err) {
        return callback(err);
      }
      if (options.ssh) {
        return next(new Error('SSH not yet supported'));
      }
      linked = 0;
      sym_exists = function(options, callback) {
        return misc.file.exists(options.ssh, options.destination, function(err, exists) {
          if (!exists) {
            return callback(null, false);
          }
          return fs.readlink(options.destination, function(err, resolvedPath) {
            if (err) {
              return callback(err);
            }
            if (resolvedPath === options.source) {
              return callback(null, true);
            }
            return fs.unlink(options.destination, function(err) {
              if (err) {
                return callback(err);
              }
              return callback(null, false);
            });
          });
        });
      };
      sym_create = function(options, callback) {
        return fs.symlink(options.source, options.destination, function(err) {
          if (err) {
            return callback(err);
          }
          linked++;
          return callback();
        });
      };
      exec_exists = function(options, callback) {
        return misc.file.exists(options.ssh, options.destination, function(err, exists) {
          if (!exists) {
            return callback(null, false);
          }
          return misc.file.readFile(options.ssh, options.destination, 'utf8', function(err, content) {
            var exec_cmd;
            if (err) {
              return callback(err);
            }
            exec_cmd = /exec (.*) \$@/.exec(content)[1];
            return callback(null, exec_cmd && exec_cmd === options.source);
          });
        });
      };
      exec_create = function(options, callback) {
        var content;
        content = "#!/bin/bash\nexec " + options.source + " $@";
        return misc.file.writeFile(options.ssh, options.destination, content, function(err) {
          if (err) {
            return callback(err);
          }
          return fs.chmod(options.destination, options.mode, function(err) {
            if (err) {
              return callback(err);
            }
            linked++;
            return callback();
          });
        });
      };
      parents = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = options.length; _i < _len; _i++) {
          option = options[_i];
          _results.push(path.normalize(path.dirname(option.destination)));
        }
        return _results;
      })();
      return mecano.mkdir(parents, function(err, created) {
        if (err) {
          return callback(err);
        }
        return each(options).parallel(true).on('item', function(options, next) {
          var dispatch;
          if (!options.source) {
            return next(new Error("Missing source, got " + (JSON.stringify(options.source))));
          }
          if (!options.destination) {
            return next(new Error("Missing destination, got " + (JSON.stringify(options.destination))));
          }
          if (options.mode == null) {
            options.mode = 0x1ed;
          }
          dispatch = function() {
            if (options.exec) {
              return exec_exists(options, function(err, exists) {
                if (exists) {
                  return next();
                }
                return exec_create(options, next);
              });
            } else {
              return sym_exists(options, function(err, exists) {
                if (exists) {
                  return next();
                }
                return sym_create(options, next);
              });
            }
          };
          return dispatch();
        }).on('both', function(err) {
          return callback(err, linked);
        });
      });
    });
  },
  /*
  
  `mkdir(options, callback)`
  --------------------------
  
  Recursively create a directory. The behavior is similar to the Unix command `mkdir -p`. 
  It supports an alternative syntax where options is simply the path of the directory
  to create.
  
  `options`           Command options include:   
  
  *   `source`        Path or array of paths.   
  *   `uid`           Unix user id.   
  *   `gid`           Unix group id.  
  *   `directory`     Alias for `source`
  *   `destination`   Alias for `source`
  *   `exclude`       Regular expression.   
  *   `mode`          Default to 0755.  
  *   `cwd`           Current working directory for relative paths.   
  
  `callback`          Received parameters are:   
  
  *   `err`           Error object if any.   
  *   `created`       Number of created directories
  
  Simple usage:
  
      mecano.mkdir './some/dir', (err, created) ->
        console.log err?.message ? created
  */

  mkdir: function(options, callback) {
    var finish, result;
    result = child(mecano);
    finish = function(err, created) {
      if (callback) {
        callback(err, created);
      }
      return result.end(err, created);
    };
    misc.options(options, function(err, options) {
      var created;
      if (err) {
        return finish(err);
      }
      created = 0;
      return each(options).on('item', function(options, next) {
        var check, create, cwd, _ref;
        if (typeof options === 'string') {
          options = {
            source: options
          };
        }
        if (options.source == null) {
          options.source = options.directory;
        }
        if (options.source == null) {
          options.source = options.destination;
        }
        if (options.source == null) {
          return next(new Error('Missing source option'));
        }
        cwd = (_ref = options.cwd) != null ? _ref : process.cwd();
        options.source = path.resolve(cwd, options.source);
        check = function() {
          return misc.file.stat(options.ssh, options.source, function(err, stat) {
            if (err && err.code === 'ENOENT') {
              return create();
            }
            if (err) {
              return next(err);
            }
            if (stat.isDirectory()) {
              return next();
            }
            return next(err('Invalid source, got #{JSON.encode(options.source)}'));
          });
        };
        create = function() {
          var current, dirCreated, dirs;
          if (options.mode == null) {
            options.mode = 0x1ed;
          }
          current = '';
          dirCreated = false;
          dirs = options.source.split('/');
          return each(dirs).on('item', function(dir, next) {
            if ((options.exclude != null) && options.exclude instanceof RegExp) {
              if (options.exclude.test(dir)) {
                return next();
              }
            }
            current += "/" + dir;
            return misc.file.exists(options.ssh, current, function(err, exists) {
              if (exists) {
                return next();
              }
              return misc.file.mkdir(options.ssh, current, options, function(err) {
                if (err) {
                  return next(err);
                }
                dirCreated = true;
                return next();
              });
            });
          }).on('both', function(err) {
            if (dirCreated) {
              created++;
            }
            return next(err);
          });
        };
        return conditions.all(options, next, check);
      }).on('both', function(err) {
        return finish(err, created);
      });
    });
    return result;
  },
  /*
  
  `mv` `move(options, callback)`
  --------------------------------
  
  Move files and directories.   
  
  `options`           Command options include:   
  
  *   `destination`   Final name of the moved resource.   
  *   `force`         Overwrite the destination if it exists.   
  *   `source`        File or directory to move.   
  
  `callback`          Received parameters are:   
  
  *   `err`           Error object if any.   
  *   `moved`         Number of moved resources.
  
  Example
  
    mecano.mv
      source: __dirname
      desination: '/temp/my_dir'
    , (err, moved) ->
      console.log "#{moved} dir moved"
  */

  move: function(options, callback) {
    return misc.options(options, function(err, options) {
      var moved;
      if (err) {
        return callback(err);
      }
      moved = 0;
      return each(options).on('item', function(options, next) {
        var exists, move, remove;
        exists = function() {
          return misc.file.stat(options.ssh, options.destination, function(err, stat) {
            if ((err != null ? err.code : void 0) === 'ENOENT') {
              return move();
            }
            if (err) {
              return next(err);
            }
            if (!options.force) {
              return next(new Error('Destination already exists, use the force option'));
            }
            return remove();
          });
        };
        remove = function() {
          return mecano.remove({
            ssh: options.ssh,
            destination: options.destination
          }, function(err, removed) {
            if (err) {
              return next(err);
            }
            return move();
          });
        };
        move = function() {
          return misc.file.rename(options.ssh, options.source, options.destination, function(err) {
            if (err) {
              return next(err);
            }
            moved++;
            return next();
          });
        };
        return conditions.all(options, next, exists);
      }).on('both', function(err) {
        return callback(err, moved);
      });
    });
  },
  /*
  
  `rm` `remove(options, callback)`
  --------------------------------
  
  Recursively remove files, directories and links. Internally, the function 
  use the [rimraf](https://github.com/isaacs/rimraf) library.
  
  `options`           Command options include:   
  
  *   `source`        File, directory or pattern.  
  *   `destination`   Alias for "source". 
  
  `callback`          Received parameters are:   
  
  *   `err`           Error object if any.   
  *   `removed`       Number of removed sources.   
  
  Example
  
      mecano.rm './some/dir', (err, removed) ->
        console.log "#{removed} dir removed"
  
  Removing a directory unless a given file exists
  
      mecano.rm
        source: './some/dir'
        not_if_exists: './some/file'
      , (err, removed) ->
        console.log "#{removed} dir removed"
  
  Removing multiple files and directories
  
      mecano.rm [
        { source: './some/dir', not_if_exists: './some/file' }
        './some/file'
      ], (err, removed) ->
        console.log "#{removed} dirs removed"
  */

  remove: function(options, callback) {
    var finish, result;
    result = child(mecano);
    finish = function(err, removed) {
      if (callback) {
        callback(err, removed);
      }
      return result.end(err, removed);
    };
    misc.options(options, function(err, options) {
      var removed;
      if (err) {
        return finish(err);
      }
      removed = 0;
      return each(options).on('item', function(options, next) {
        var remove;
        if (typeof options === 'string') {
          options = {
            source: options
          };
        }
        if (options.source == null) {
          options.source = options.destination;
        }
        if (options.source == null) {
          return next(new Error("Missing source"));
        }
        remove = function() {
          if (options.ssh) {
            return misc.file.exists(options.ssh, options.source, function(err, exists) {
              if (err) {
                return next(err);
              }
              if (exists) {
                removed++;
              }
              return misc.file.remove(options.ssh, options.source, next);
            });
          } else {
            return each().files(options.source).on('item', function(file, next) {
              removed++;
              return misc.file.remove(options.ssh, file, next);
            }).on('error', function(err) {
              return next(err);
            }).on('end', function() {
              return next();
            });
          }
        };
        return conditions.all(options, next, remove);
      }).on('both', function(err) {
        return finish(err, removed);
      });
    });
    return result;
  },
  /*
  
  `render(options, callback)`
  ---------------------------
  
  Render a template file At the moment, only the 
  [ECO](http://github.com/sstephenson/eco) templating engine is integrated.   
  
  `options`           Command options include:   
  
  *   `engine`        Template engine to use, default to "eco"   
  *   `content`       Templated content, bypassed if source is provided.   
  *   `source`        File path where to extract content from.   
  *   `destination`   File path where to write content to or a callback.   
  *   `context`       Map of key values to inject into the template.   
  *   `local_source`  Treat the source as local instead of remote, only apply with "ssh" option.   
  
  `callback`          Received parameters are:   
  
  *   `err`           Error object if any.   
  *   `rendered`      Number of rendered files.   
  
  If destination is a callback, it will be called multiple times with the   
  generated content as its first argument.
  */

  render: function(options, callback) {
    return misc.options(options, function(err, options) {
      var rendered;
      if (err) {
        return callback(err);
      }
      rendered = 0;
      return each(options).on('item', function(options, next) {
        var readSource, writeContent;
        if (!(options.source || options.content)) {
          return next(new Error('Missing source or content'));
        }
        if (!options.destination) {
          return next(new Error('Missing destination'));
        }
        readSource = function() {
          var ssh;
          if (!options.source) {
            return writeContent();
          }
          ssh = options.local_source ? null : options.ssh;
          return misc.file.exists(ssh, options.source, function(err, exists) {
            if (!exists) {
              return next(new Error("Invalid source, got " + (JSON.stringify(options.source))));
            }
            return misc.file.readFile(ssh, options.source, 'utf8', function(err, content) {
              if (err) {
                return next(err);
              }
              options.content = content;
              return writeContent();
            });
          });
        };
        writeContent = function() {
          options.source = null;
          return mecano.write(options, function(err, written) {
            if (err) {
              return next(err);
            }
            if (written) {
              rendered++;
            }
            return next();
          });
        };
        return conditions.all(options, next, readSource);
      }).on('both', function(err) {
        return callback(err, rendered);
      });
    });
  },
  /*
  `service(options, callback)`
  ----------------------------
  
  Install a service. For now, only yum over SSH.   
  
  `options`           Command options include:   
  
  *    name           Package name.   
  *    startup        Run service daemon on startup.   
  *    yum_name       Name used by the yum utility, default to "name".   
  *    chk_name       Name used by the chkconfig utility, default to "srv_name" and "name".   
  *    srv_name       Name used by the service utility, default to "name".   
  *    start          Ensure the service is started, a boolean.   
  *    stop           Ensure the service is stopped, a boolean.   
  *   `stdout`        Writable Stream in which commands output will be piped.   
  *   `stderr`        Writable Stream in which commands error will be piped.   
  
  `callback`          Received parameters are:   
  
  *   `err`           Error object if any.   
  *   `modified`      Number of action taken (installed, updated, started or stoped).
  */

  service: function(options, callback) {
    return misc.options(options, function(err, options) {
      var serviced;
      if (err) {
        return callback(err);
      }
      serviced = 0;
      return each(options).on('item', function(options, next) {
        var action, chkname, finish, install, installed, modified, pkgname, srvname, started, startup_add, startup_del, startuped, updates;
        if (!options.name) {
          return next(new Error('Missing service name'));
        }
        if (!options.ssh) {
          return next(new Error('Restricted to Yum over SSH'));
        }
        if ((options.start != null) && options.start === options.stop) {
          return next(new Error('Invalid configuration, start conflict with stop'));
        }
        pkgname = options.yum_name || options.name;
        chkname = options.chk_name || options.srv_name || options.name;
        srvname = options.srv_name || options.name;
        if ((options.startup != null) && typeof options.startup !== 'string') {
          options.startup = options.startup ? '2345' : '';
        }
        modified = false;
        installed = function() {
          return mecano.execute({
            ssh: options.ssh,
            cmd: "yum list installed | grep ^" + pkgname + "\\\\.",
            code_skipped: 1,
            stdout: options.stdout,
            stderr: options.stderr
          }, function(err, installed) {
            if (err) {
              return next(err);
            }
            if (installed) {
              return updates();
            } else {
              return install();
            }
          });
        };
        updates = function() {
          return mecano.execute({
            ssh: options.ssh,
            cmd: "yum list updates | grep ^" + pkgname + "\\\\.",
            code_skipped: 1,
            stdout: options.stdout,
            stderr: options.stderr
          }, function(err, outdated) {
            if (err) {
              return next(err);
            }
            if (outdated) {
              return install();
            } else {
              return startuped();
            }
          });
        };
        install = function() {
          return mecano.execute({
            ssh: options.ssh,
            cmd: "yum install -y " + pkgname,
            code_skipped: 1,
            stdout: options.stdout,
            stderr: options.stderr
          }, function(err, succeed) {
            if (err) {
              return next(err);
            }
            if (!succeed) {
              return next(new Error("No package " + pkgname + " available."));
            }
            if (installed) {
              modified = true;
            }
            return startuped();
          });
        };
        startuped = function() {
          if (options.startup == null) {
            return started();
          }
          return mecano.execute({
            ssh: options.ssh,
            cmd: "chkconfig --list " + chkname,
            code_skipped: 1,
            stdout: options.stdout,
            stderr: options.stderr
          }, function(err, registered, stdout, stderr) {
            var c, current_startup, level, status, _i, _len, _ref, _ref1;
            if (err) {
              return next(err);
            }
            if (/^error/.test(stderr)) {
              return next(new Error("Invalid chkconfig name " + chkname));
            }
            current_startup = '';
            if (registered) {
              _ref = stdout.split(' ').pop().trim().split('\t');
              for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                c = _ref[_i];
                _ref1 = c.split(':'), level = _ref1[0], status = _ref1[1];
                if (status === 'on') {
                  current_startup += level;
                }
              }
            }
            if (options.startup === current_startup) {
              return started();
            }
            modified = true;
            if (options.startup) {
              return startup_add();
            } else {
              return startup_del();
            }
          });
        };
        startup_add = function() {
          var cmd, i, startup_off, startup_on, _i;
          startup_on = startup_off = '';
          for (i = _i = 0; _i < 6; i = ++_i) {
            if (options.startup.indexOf(i) !== -1) {
              startup_on += i;
            } else {
              startup_off += i;
            }
          }
          cmd = "chkconfig --add " + chkname + ";";
          if (startup_on) {
            cmd += "chkconfig --level " + startup_on + " " + chkname + " on;";
          }
          if (startup_off) {
            cmd += "chkconfig --level " + startup_off + " " + chkname + " off;";
          }
          return mecano.execute({
            ssh: options.ssh,
            cmd: cmd,
            stdout: options.stdout,
            stderr: options.stderr
          }, function(err, stream) {
            if (err) {
              return next(err);
            }
            return started();
          });
        };
        startup_del = function() {
          return mecano.execute({
            ssh: options.ssh,
            cmd: "chkconfig --del " + chkname,
            stdout: options.stdout,
            stderr: options.stderr
          }, function(err, stream) {
            if (err) {
              return next(err);
            }
            return started();
          });
        };
        started = function() {
          if (options.action !== 'start' || options.actions !== 'stop') {
            return action();
          }
          return mecano.execute({
            ssh: options.ssh,
            cmd: "service " + srvname + " status",
            code_skipped: 3,
            stdout: options.stdout,
            stderr: options.stderr
          }, function(err, started) {
            if (err) {
              return next(err);
            }
            if (started) {
              if (options.action !== 'start') {
                return action();
              }
            } else {
              if (options.action !== 'stop') {
                return action();
              }
            }
            return finish();
          });
        };
        action = function() {
          if (!options.action) {
            return finish();
          }
          return mecano.execute({
            ssh: options.ssh,
            cmd: "service " + srvname + " " + options.action,
            stdout: options.stdout,
            stderr: options.stderr
          }, function(err, executed) {
            if (err) {
              return next(err);
            }
            modified = true;
            return finish();
          });
        };
        finish = function() {
          if (modified) {
            serviced++;
          }
          return next();
        };
        return conditions.all(options, next, installed);
      }).on('both', function(err) {
        return callback(err, serviced);
      });
    });
  },
  /*
  
  `upload(options, callback)`
  ---------------------------
  
  Upload a file to a remote location. Options are 
  identical to the "write" function with the addition of 
  the "binary" option.
  
  `options`           Command options include:   
  
  *   `binary`        Fast upload implementation, discard all the other option and use its own stream based implementation.   
  *   `from`          Replace from after this marker, a string or a regular expression.   
  *   `to`            Replace to before this marker, a string or a regular expression.   
  *   `match`         Replace this marker, a string or a regular expression.   
  *   `replace`       The content to be inserted, used conjointly with the from, to or match options.   
  *   `content`       Text to be written.   
  *   `source`        File path from where to extract the content, do not use conjointly with content.   
  *   `destination`   File path where to write content to.   
  *   `backup`        Create a backup, append a provided string to the filename extension or a timestamp if value is not a string.   
  
  `callback`          Received parameters are:   
  
  *   `err`           Error object if any.   
  *   `rendered`      Number of rendered files.
  */

  upload: function(options, callback) {
    return misc.options(options, function(err, options) {
      var uploaded;
      if (err) {
        return callback(err);
      }
      uploaded = 0;
      return each(options).on('item', function(options, next) {
        if (options.binary) {
          return options.ssh.sftp(function(err, sftp) {
            var from, to;
            from = fs.createReadStream(options.source);
            to = sftp.createWriteStream(options.destination);
            from.pipe(to);
            from.on('error', function(err) {
              return next(err);
            });
            return from.on('end', function() {
              uploaded++;
              return next();
            });
          });
        }
        options = misc.merge(options, {
          local_source: true
        });
        return mecano.write(options, function(err, written) {
          if (written === 1) {
            uploaded++;
          }
          return next(err);
        });
      }).on('both', function(err) {
        return callback(err, uploaded);
      });
    });
  },
  /*
  
  `write(options, callback)`
  --------------------------
  
  Write a file or a portion of an existing file.
  
  `options`           Command options include:   
  
  *   `from`          Replace from after this marker, a string or a regular expression.   
  *   `local_source`  Treat the source as local instead of remote, only apply with "ssh" option.   
  *   `to`            Replace to before this marker, a string or a regular expression.   
  *   `match`         Replace this marker, a string or a regular expression.   
  *   `replace`       The content to be inserted, used conjointly with the from, to or match options.   
  *   `content`       Text to be written, an alternative to source which reference a file.   
  *   `source`        File path from where to extract the content, do not use conjointly with content.   
  *   `destination`   File path where to write content to.   
  *   `backup`        Create a backup, append a provided string to the filename extension or a timestamp if value is not a string.   
  *   `append`        Append the content to the destination file. If destination does not exist, the file will be created.   
  *   `write`         An array containing multiple transformation where a transformation is an object accepting the options `from`, `to`, `match` and `replace`
  *   `ssh`           Run the action on a remote server using SSH, an ssh2 instance or an configuration object used to initialize the SSH connection.   
  
  `callback`          Received parameters are:   
  
  *   `err`           Error object if any.   
  *   `rendered`      Number of rendered files.   
  
  The option "append" allows some advance usages. If "append" is 
  null, it will add the `replace` value at the end of the file 
  if no match if found and if the value is a string. When used 
  conjointly with the `match` and `replace` options, it gets even 
  more interesting. If append is a string or a regular expression, 
  it will place the "replace" string just after the match. An 
  append string will be converted to a regular expression such as 
  "test" will end up converted as the string "test" is similar to the 
  RegExp /^.*test.*$/mg.
  
  Example replacing part of a file using from and to markers
  
      mecano.write
        content: 'here we are\n# from\nlets try to replace that one\n# to\nyou coquin'
        from: '# from\n'
        to: '# to'
        replace: 'my friend\n'
        destination: "#{scratch}/a_file"
      , (err, written) ->
        # here we are\n# from\nmy friend\n# to\nyou coquin
  
  Example replacing a matched line by a string with
  
      mecano.write
        content: 'email=david(at)adaltas(dot)com\nusername=root'
        match: /(username)=(.*)/
        replace: '$1=david (was $2)'
        destination: "#{scratch}/a_file"
      , (err, written) ->
        # email=david(at)adaltas(dot)com\nusername=david (was root)
  
  Example replacing part of a file using a regular expression
  
      mecano.write
        content: 'here we are\nlets try to replace that one\nyou coquin'
        match: /(.*try) (.*)/
        replace: ['my friend, $1']
        destination: "#{scratch}/a_file"
      , (err, written) ->
        # here we are\nmy friend, lets try\nyou coquin
  
  Example replacing with the global and multiple lines options
  
      mecano.write
        content: '#A config file\n#property=30\nproperty=10\n#End of Config'
        match: /^property=.*$/mg
        replace: 'property=50'
        destination: "#{scratch}/replace"
      , (err, written) ->
        '# A config file\n#property=30\nproperty=50\n#End of Config'
  
  Example appending a line after each line containing "property"
  
      mecano.write
        content: '#A config file\n#property=30\nproperty=10\n#End of Config'
        match: /^.*comment.*$/mg
        replace: '# comment'
        destination: "#{scratch}/replace"
        append: 'property'
      , (err, written) ->
        '# A config file\n#property=30\n# comment\nproperty=50\n# comment\n#End of Config'
  
  Example with multiple transformations
  
      mecano.write
        content: 'username: me\nemail: my@email\nfriends: you'
        write: [
          match: /^(username).*$/mg
          replace: "$1: you"
        ,
          match: /^email.*$/mg
          replace: ""
        ,
          match: /^(friends).*$/mg
          replace: "$1: me"
        ]
        destination: "#{scratch}/file"
      , (err, written) ->
        # username: you\n\nfriends: me
  */

  write: function(options, callback) {
    var finish, result;
    result = child(mecano);
    finish = function(err, written) {
      if (callback) {
        callback(err, written);
      }
      return result.end(err, written);
    };
    misc.options(options, function(err, options) {
      var written;
      if (err) {
        return finish(err);
      }
      written = 0;
      return each(options).on('item', function(options, next) {
        var append, backup, between, content, destination, destinationHash, from, readDestination, readSource, render, replacePartial, to, write, writeContent, _ref;
        if (!((options.source || (options.content != null)) || options.replace || ((_ref = options.write) != null ? _ref.length : void 0))) {
          return next(new Error('Missing source or content'));
        }
        if (options.source && options.content) {
          return next(new Error('Define either source or content'));
        }
        if (!options.destination) {
          return next(new Error('Missing destination'));
        }
        destination = null;
        destinationHash = null;
        content = null;
        from = to = between = null;
        append = options.append;
        write = options.write;
        if (write == null) {
          write = [];
        }
        if ((options.from != null) || (options.to != null) || (options.match != null)) {
          write.push({
            from: options.from,
            to: options.to,
            match: options.match,
            replace: options.replace,
            append: options.append
          });
        }
        readSource = function() {
          var source, ssh;
          if (options.content != null) {
            content = options.content;
            return readDestination();
          }
          source = options.source || options.destination;
          ssh = options.local_source ? null : options.ssh;
          return misc.file.exists(ssh, source, function(err, exists) {
            if (err) {
              return next(err);
            }
            if (!exists) {
              if (options.source) {
                return next(new Error("Source does not exist: \"" + options.source + "\""));
              }
              content = '';
              return readDestination();
            }
            return misc.file.readFile(ssh, source, 'utf8', function(err, src) {
              if (err) {
                return next(err);
              }
              content = src;
              return readDestination();
            });
          });
        };
        readDestination = function() {
          var exists, mkdir, read;
          if (typeof options.destination === 'function') {
            return render();
          }
          exists = function() {
            return misc.file.exists(options.ssh, options.destination, function(err, exists) {
              if (err) {
                return next(err);
              }
              if (exists) {
                return read();
              } else {
                return mkdir();
              }
            });
          };
          mkdir = function() {
            return mecano.mkdir({
              ssh: options.ssh,
              destination: path.dirname(options.destination),
              uid: options.uid,
              gid: options.gid,
              mode: options.mode
            }, function(err, created) {
              if (err) {
                return next(err);
              }
              return render();
            });
          };
          read = function() {
            return misc.file.readFile(options.ssh, options.destination, 'utf8', function(err, dest) {
              if (err) {
                return next(err);
              }
              destinationHash = misc.string.hash(dest);
              return render();
            });
          };
          return exists();
        };
        render = function() {
          if (options.context == null) {
            return replacePartial();
          }
          try {
            content = eco.render(content.toString(), options.context);
          } catch (_error) {
            err = _error;
            if (typeof err === 'string') {
              err = new Error(err);
            }
            return next(err);
          }
          return replacePartial();
        };
        replacePartial = function() {
          var linebreak, opts, orgContent, pos, posoffset, res, _i, _len;
          if (!write.length) {
            return writeContent();
          }
          for (_i = 0, _len = write.length; _i < _len; _i++) {
            opts = write[_i];
            if (opts.match) {
              if (opts.match instanceof RegExp) {
                if (opts.match.test(content)) {
                  content = content.replace(opts.match, opts.replace);
                  append = false;
                } else if (opts.append && typeof opts.replace === 'string') {
                  if (typeof opts.append === "string") {
                    opts.append = new RegExp("^.*" + opts.append + ".*$", 'mg');
                  }
                  if (opts.append instanceof RegExp) {
                    posoffset = 0;
                    orgContent = content;
                    while ((res = opts.append.exec(orgContent)) !== null) {
                      pos = posoffset + res.index + res[0].length;
                      content = content.slice(0, pos) + '\n' + opts.replace + content.slice(pos);
                      posoffset += opts.replace.length + 1;
                      if (!opts.append.global) {
                        break;
                      }
                    }
                    append = false;
                  } else {
                    linebreak = content.length === 0 || content.substr(content.length - 1) === '\n' ? '' : '\n';
                    content = content + linebreak + opts.replace;
                    append = false;
                  }
                } else {
                  continue;
                }
              } else {
                from = content.indexOf(opts.match);
                to = from + opts.match.length;
                content = content.substr(0, from) + opts.replace + content.substr(to);
              }
            } else {
              from = opts.from ? content.indexOf(opts.from) + opts.from.length : 0;
              to = opts.to ? content.indexOf(opts.to) : content.length;
              content = content.substr(0, from) + opts.replace + content.substr(to);
            }
          }
          return writeContent();
        };
        writeContent = function() {
          if (destinationHash === misc.string.hash(content)) {
            return next();
          }
          if (typeof options.destination === 'function') {
            options.destination(content);
            return next();
          } else {
            if (append) {
              if (options.flags == null) {
                options.flags = 'a';
              }
            }
            return misc.file.writeFile(options.ssh, options.destination, content, options, function(err) {
              if (err) {
                return next(err);
              }
              written++;
              return backup();
            });
          }
        };
        backup = function() {
          if (!options.backup) {
            return next();
          }
          backup = options.backup;
          if (backup === true) {
            backup = "." + (Date.now());
          }
          backup = "" + options.destination + backup;
          return misc.file.writeFile(options.ssh, backup, content, function(err) {
            if (err) {
              return next(err);
            }
            return next();
          });
        };
        return conditions.all(options, next, readSource);
      }).on('both', function(err) {
        return finish(err, written);
      });
    });
    return result;
  }
};

mecano.cp = mecano.copy;

mecano.exec = mecano.execute;

mecano.ln = mecano.link;

mecano.mv = mecano.move;

mecano.rm = mecano.remove;
