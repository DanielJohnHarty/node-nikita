// Generated by CoffeeScript 1.6.2
var EventEmitter, Ftp, child, conditions, each, eco, exec, fs, mecano, misc, path, request, url, util;

fs = require('fs');

path = require('path');

url = require('url');

util = require('util');

each = require('each');

eco = require('eco');

exec = require('superexec');

request = require('request');

Ftp = require('jsftp');

EventEmitter = require('events').EventEmitter;

conditions = require('./conditions');

misc = require('./misc');

child = require('./child');

/*

Mecano gather a set of functions usually used during system deployment. All the functions share a 
common API with flexible options.

Functions include "copy", "download", "exec", "extract", "git", "link", "mkdir", "move", "remove", "render", "service", "write". They all share common usages and philosophies:   
*   Run actions both locally and remotely over SSH.   
*   Ability to see if an action had an effect through the second argument provided in the callback.   
*   Common API with options and callback arguments and calling the callback with an error and the number of affected actions.   
*   Run one or multiple actions depending on option argument being an object or an array of objects.
*/


mecano = module.exports = {
  /*
  
  `cp` `copy(options, callback)`
  ------------------------------
  
  Copy a file. The behavior is similar to the one of the `cp` 
  Unix utility. Copying a file over an existing file will 
  overwrite it.
  
  `options`             Command options include:   
  
  *   `source`          The file or directory to copy.
  *   `destination`     Where the file or directory is copied.
  *   `not_if_exists`   Equals destination if true.
  *   `chmod`           Permissions of the file or the parent directory
  *   `ssh`             Run the action on a remote server using SSH, an ssh2 instance or an configuration object used to initialize the SSH connection.   
   
  `callback`            Received parameters are:   
  
  *   `err`             Error object if any.   
  *   `copied`          Number of files or parent directories copied.
  
  todo:
  *   preserve permissions if `chmod` is `true`
  */

  copy: function(options, callback) {
    return misc.options(options, function(err, options) {
      var copied;

      if (err) {
        return callback(err);
      }
      copied = 0;
      return each(options).on('item', function(options, next) {
        var search;

        if (!options.source) {
          return next(new Error('Missing source'));
        }
        if (!options.destination) {
          return next(new Error('Missing destination'));
        }
        if (options.ssh) {
          return next(new Error('SSH not yet supported'));
        }
        if (options.not_if_exists === true) {
          options.not_if_exists = options.destination;
        }
        search = function() {
          var chmod, copy, copyDir, copyFile, directory, dstStat, finish, srcStat;

          srcStat = null;
          dstStat = null;
          fs.stat(options.source, function(err, stat) {
            if (err) {
              return next(err);
            }
            srcStat = stat;
            return fs.stat(options.destination, function(err, stat) {
              var sourceEndWithSlash;

              dstStat = stat;
              sourceEndWithSlash = options.source.lastIndexOf('/') === options.source.length - 1;
              if (srcStat.isDirectory() && dstStat && !sourceEndWithSlash) {
                options.destination = path.resolve(options.destination, path.basename(options.source));
              }
              if (srcStat.isDirectory()) {
                return directory(options.source);
              } else {
                return copy(options.source, next);
              }
            });
          });
          directory = function(dir) {
            return each().files("" + dir + "/**").on('item', function(file, next) {
              return copy(file, next);
            }).on('both', next);
          };
          copy = function(source, next) {
            var destination;

            if (srcStat.isDirectory()) {
              destination = path.resolve(options.destination, path.relative(options.source, source));
            } else if (!srcStat.isDirectory() && (dstStat != null ? dstStat.isDirectory() : void 0)) {
              destination = path.resolve(options.destination, path.basename(source));
            } else {
              destination = options.destination;
            }
            return fs.stat(source, function(err, stat) {
              if (stat.isDirectory()) {
                return copyDir(source, destination, next);
              } else {
                return copyFile(source, destination, next);
              }
            });
          };
          copyDir = function(source, destination, next) {
            if (source === options.source) {
              return next();
            }
            return misc.file.mkdir(options.ssh, destination, function(err) {
              if ((err != null ? err.code : void 0) === 'EEXIST') {
                return next();
              }
              if (err) {
                return next(err);
              }
              return finish(next);
            });
          };
          copyFile = function(source, destination, next) {
            return misc.file.compare([source, destination], function(err, md5) {
              var input, output;

              if (err && err.message.indexOf('Does not exist') !== 0) {
                return next(err);
              }
              if (md5) {
                return next();
              }
              input = fs.createReadStream(source);
              output = fs.createWriteStream(destination);
              return input.pipe(output).on('close', function(err) {
                if (err) {
                  return next(err);
                }
                return chmod(source, next);
              });
            });
          };
          chmod = function(file, next) {
            if (!options.chmod || options.chmod === dstStat.mode) {
              return finish(next);
            }
            return fs.chmod(options.destination, options.chmod, function(err) {
              if (err) {
                return next(err);
              }
              return finish(next);
            });
          };
          return finish = function(next) {
            copied++;
            return next();
          };
        };
        return conditions.all(options, next, search);
      }).on('both', function(err) {
        return callback(err, copied);
      });
    });
  },
  /*
  
  `download(options, callback)`
  -----------------------------
  
  Download files using various protocols.
  
  When executed locally: the `http` scheme is handled 
  with the "request" module; the `ftp` scheme is handled 
  with the "jsftp"; the `file` scheme is handle with the navite 
  `fs` module.
  
  `options`         Command options include:   
  
  *   `source`      File, HTTP URL, FTP, GIT repository. File is the default protocol if source is provided without a scheme.   
  *   `destination` Path where the file is downloaded.   
  *   `force`       Overwrite destination file if it exists.   
  
  `callback`        Received parameters are:   
  
  *   `err`         Error object if any.   
  *   `downloaded`  Number of downloaded files
  
  File example
  
      mecano.download
        source: 'file://path/to/something'
        destination: 'node-sigar.tgz'
      , (err, downloaded) -> ...
  
  HTTP example
  
      mecano.download
        source: 'https://github.com/wdavidw/node-sigar/tarball/v0.0.1'
        destination: 'node-sigar.tgz'
      , (err, downloaded) -> ...
  
  FTP example
  
      mecano.download
        source: 'ftp://myhost.com:3334/wdavidw/node-sigar/tarball/v0.0.1'
        destination: 'node-sigar.tgz'
        user: "johndoe",
        pass: "12345"
      , (err, downloaded) -> ...
  
  File example
  */

  download: function(options, callback) {
    var finish, result;

    result = child(mecano);
    finish = function(err, downloaded) {
      if (callback) {
        callback(err, downloaded);
      }
      return result.end(err, downloaded);
    };
    return misc.options(options, function(err, options) {
      var downloaded;

      if (err) {
        return finish(err);
      }
      downloaded = 0;
      return each(options).on('item', function(options, next) {
        var download, prepare, _ref;

        if (!options.source) {
          return next(new Error("Missing source: " + options.source));
        }
        if (!options.destination) {
          return next(new Error("Missing destination: " + options.destination));
        }
        if ((_ref = options.force) == null) {
          options.force = false;
        }
        prepare = function() {
          return misc.file.exists(options.ssh, options.destination, function(err, exists) {
            if (exists && !options.force) {
              return next();
            } else if (exists) {
              return mecano.remove({
                ssh: options.ssh,
                destination: options.destination
              }, function(err) {
                if (err) {
                  return next(err);
                }
                return download();
              });
            } else {
              return download();
            }
          });
        };
        download = function() {
          var destination, ftp, pass, scheme, source, u, user, _ref1, _ref2, _ref3, _ref4, _ref5;

          u = url.parse(options.source);
          scheme = 'file';
          if (options.ssh) {
            return mecano.execute({
              ssh: options.ssh,
              cmd: "curl " + options.source + " -o " + options.destination
            }, function(err, executed) {
              return next(err);
            });
          } else {
            destination = fs.createWriteStream(options.destination);
            if (u.protocol === 'http:') {
              options.url = options.source;
              request(options).pipe(destination);
            } else if (u.protocol === 'ftp:') {
              if ((_ref1 = options.host) == null) {
                options.host = u.hostname;
              }
              if ((_ref2 = options.port) == null) {
                options.port = u.port;
              }
              if (u.auth) {
                _ref3 = u.auth.split(':'), user = _ref3.user, pass = _ref3.pass;
              }
              if ((_ref4 = options.user) == null) {
                options.user = user;
              }
              if ((_ref5 = options.pass) == null) {
                options.pass = pass;
              }
              ftp = new Ftp(options);
              ftp.getGetSocket(u.pathname, function(err, source) {
                if (err) {
                  return next(err);
                }
                source.pipe(destination);
                return source.resume();
              });
            } else {
              source = fs.createReadStream(u.pathname);
              source.pipe(destination);
            }
            destination.on('close', function() {
              downloaded++;
              return next();
            });
            return destination.on('error', function(err) {
              return mecano.remove(destination, function(err) {
                return next(err);
              });
            });
          }
        };
        return prepare();
      }).on('both', function(err) {
        return finish(err, downloaded);
      });
    });
  },
  /*
  
  `exec` `execute([goptions], options, callback)`
  -----------------------------------------------
  Run a command locally or with ssh if the `host` is provided. Global options is
  optional and is used in case where options is defined as an array of 
  multiple commands. Note, `opts` inherites all the properties of `goptions`.
  
  `goptions`        Global options includes:
  
  *   `parallel`    Wether the command are run in sequential, parallel 
  or limited concurrent mode. See the `node-each` documentation for more 
  details. Default to sequential (false).
        
  `options`           Include all conditions as well as:  
  
  *   `cmd`           String, Object or array; Command to execute.   
  *   `env`           Environment variables, default to `process.env`.   
  *   `cwd`           Current working directory.   
  *   `uid`           Unix user id.   
  *   `gid`           Unix group id.   
  *   `code`          Expected code(s) returned by the command, int or array of int, default to 0.  
  *   `code_skipped`  Expected code(s) returned by the command if it has no effect, executed will not be incremented, int or array of int.   
  *   `stdout`        Writable EventEmitter in which command output will be piped.   
  *   `stderr`        Writable EventEmitter in which command error will be piped.   
  *   `ssh`           Run the action on a remote server using SSH, an ssh2 instance or an configuration object used to initialize the SSH connection.   
  
  `callback`        Received parameters are:   
  
  *   `err`         Error if any.   
  *   `executed`    Number of executed commandes.   
  *   `stdout`      Stdout value(s) unless `stdout` option is provided.   
  *   `stderr`      Stderr value(s) unless `stderr` option is provided.
  */

  execute: function(options, callback) {
    var finish, isArray, result;

    result = child(mecano);
    finish = function(err, created, stdout, stderr) {
      if (callback) {
        callback(err, created, stdout, stderr);
      }
      return result.end(err, created);
    };
    isArray = Array.isArray(options);
    misc.options(options, function(err, options) {
      var escape, executed, stderrs, stdouts, stds;

      if (err) {
        return finish(err);
      }
      executed = 0;
      stdouts = [];
      stderrs = [];
      escape = function(cmd) {
        var char, esccmd, _i, _len;

        esccmd = '';
        for (_i = 0, _len = cmd.length; _i < _len; _i++) {
          char = cmd[_i];
          if (char === '$') {
            esccmd += '\\';
          }
          esccmd += char;
        }
        return esccmd;
      };
      stds = callback ? callback.length > 2 : false;
      return each(options).parallel(true).on('item', function(options, i, next) {
        var cmd, _ref, _ref1;

        if (typeof options === 'string') {
          options = {
            cmd: options
          };
        }
        if (options.cmd == null) {
          return next(new Error("Missing cmd: " + options.cmd));
        }
        if ((_ref = options.code) == null) {
          options.code = [0];
        }
        if (!Array.isArray(options.code)) {
          options.code = [options.code];
        }
        if ((_ref1 = options.code_skipped) == null) {
          options.code_skipped = [];
        }
        if (!Array.isArray(options.code_skipped)) {
          options.code_skipped = [options.code_skipped];
        }
        cmd = function() {
          var run, stderr, stdout;

          run = exec(options);
          stdout = stderr = [];
          if (options.stdout) {
            run.stdout.pipe(options.stdout);
          }
          if (stds) {
            run.stdout.on('data', function(data) {
              return stdout.push(data);
            });
          }
          if (options.stderr) {
            run.stderr.pipe(options.stderr);
          }
          if (stds) {
            run.stderr.on('data', function(data) {
              return stderr.push(data);
            });
          }
          return run.on("exit", function(code) {
            return setTimeout(function() {
              stdouts.push(stds ? stdout.join('') : void 0);
              stderrs.push(stds ? stderr.join('') : void 0);
              if (options.code.indexOf(code) === -1 && options.code_skipped.indexOf(code) === -1) {
                err = new Error("Invalid exec code " + code);
                err.code = code;
                return next(err);
              }
              if (options.code_skipped.indexOf(code) === -1) {
                executed++;
              }
              return next();
            }, 1);
          });
        };
        return conditions.all(options, next, cmd);
      }).on('both', function(err) {
        if (!isArray) {
          stdouts = stdouts[0];
        }
        if (!isArray) {
          stderrs = stderrs[0];
        }
        return finish(err, executed, stdouts, stderrs);
      });
    });
    return result;
  },
  /*
  
  `extract(options, callback)` 
  ----------------------------
  
  Extract an archive. Multiple compression types are supported. Unless 
  specified as an option, format is derived from the source extension. At the 
  moment, supported extensions are '.tgz', '.tar.gz' and '.zip'.   
  
  `options`             Command options include:   
  
  *   `source`          Archive to decompress.   
  *   `destination`     Default to the source parent directory.   
  *   `format`          One of 'tgz' or 'zip'.   
  *   `creates`         Ensure the given file is created or an error is send in the callback.   
  *   `not_if_exists`   Cancel extraction if file exists.   
  *   `ssh`             Run the action on a remote server using SSH, an ssh2 instance or an configuration object used to initialize the SSH connection.   
  
  `callback`            Received parameters are:   
  
  *   `err`             Error object if any.   
  *   `extracted`       Number of extracted archives.
  */

  extract: function(options, callback) {
    return misc.options(options, function(err, options) {
      var extracted;

      if (err) {
        return callback(err);
      }
      extracted = 0;
      return each(options).on('item', function(options, next) {
        var creates, destination, ext, extract, format, success, _ref;

        if (!options.source) {
          return next(new Error("Missing source: " + options.source));
        }
        destination = (_ref = options.destination) != null ? _ref : path.dirname(options.source);
        if (options.format != null) {
          format = options.format;
        } else {
          if (/\.(tar\.gz|tgz)$/.test(options.source)) {
            format = 'tgz';
          } else if (/\.zip$/.test(options.source)) {
            format = 'zip';
          } else {
            ext = path.extname(options.source);
            return next(new Error("Unsupported extension, got " + (JSON.stringify(ext))));
          }
        }
        extract = function() {
          var cmd;

          cmd = null;
          switch (format) {
            case 'tgz':
              cmd = "tar xzf " + options.source + " -C " + destination;
              break;
            case 'zip':
              cmd = "unzip -u " + options.source + " -d " + destination;
          }
          options.cmd = cmd;
          return exec(options, function(err, stdout, stderr) {
            if (err) {
              return next(err);
            }
            return creates();
          });
        };
        creates = function() {
          if (options.creates == null) {
            return success();
          }
          return misc.file.exists(options.ssh, options.creates, function(err, exists) {
            if (!exists) {
              return next(new Error("Failed to create '" + (path.basename(options.creates)) + "'"));
            }
            return success();
          });
        };
        success = function() {
          extracted++;
          return next();
        };
        if (typeof options.should_exist === 'undefined') {
          options.should_exist = options.source;
        }
        return conditions.all(options, next, extract);
      }).on('both', function(err) {
        return callback(err, extracted);
      });
    });
  },
  /*
  
  `git`
  -----
  
  `options`             Command options include:   
  
  *   `source`          Git source repository address.   
  *   `destination`     Directory where to clone the repository.   
  *   `revision`        Git revision, branch or tag.   
  *   `ssh`             Run the action on a remote server using SSH, an ssh2 instance or an configuration object used to initialize the SSH connection.   
  *   `stdout`          Writable EventEmitter in which command output will be piped.   
  *   `stderr`          Writable EventEmitter in which command error will be piped.
  */

  git: function(options, callback) {
    return misc.options(options, function(err, options) {
      var updated;

      if (err) {
        return callback(err);
      }
      updated = 0;
      return each(options).on('item', function(options, next) {
        var checkout, clone, log, prepare, rev, _ref;

        if ((_ref = options.revision) == null) {
          options.revision = 'HEAD';
        }
        rev = null;
        prepare = function() {
          return misc.file.exists(options.ssh, options.destination, function(err, exists) {
            var gitDir;

            if (!exists) {
              return clone();
            }
            gitDir = "" + options.destination + "/.git";
            return misc.file.exists(options.ssh, gitDir, function(err, exists) {
              if (!exists) {
                return next("Not a git repository");
              }
              return log();
            });
          });
        };
        clone = function() {
          return mecano.exec({
            ssh: options.ssh,
            cmd: "git clone " + options.source + " " + options.destination,
            cwd: path.dirname(options.destination),
            stdout: options.stdout,
            stderr: options.stderr
          }, function(err, executed, stdout, stderr) {
            if (err) {
              return next(err);
            }
            return checkout();
          });
        };
        log = function() {
          return mecano.exec({
            ssh: options.ssh,
            cmd: "git log --pretty=format:'%H' -n 1",
            cwd: options.destination,
            stdout: options.stdout,
            stderr: options.stderr
          }, function(err, executed, stdout, stderr) {
            var current;

            if (err) {
              return next(err);
            }
            current = stdout.trim();
            return mecano.exec({
              ssh: options.ssh,
              cmd: "git rev-list --max-count=1 " + options.revision,
              cwd: options.destination
            }, function(err, executed, stdout, stderr) {
              if (err) {
                return next(err);
              }
              if (stdout.trim() !== current) {
                return checkout();
              } else {
                return next();
              }
            });
          });
        };
        checkout = function() {
          return mecano.exec({
            ssh: options.ssh,
            cmd: "git checkout " + options.revision,
            cwd: options.destination,
            stdout: options.stdout,
            stderr: options.stderr
          }, function(err) {
            if (err) {
              return next(err);
            }
            updated++;
            return next();
          });
        };
        return conditions.all(options, next, prepare);
      }).on('both', function(err) {
        return callback(err, updated);
      });
    });
  },
  /*
  
  `ln` `link(options, callback)`
  ------------------------------
  Create a symbolic link and it's parent directories if they don't yet
  exist.
  
  `options`             Command options include:   
  
  *   `source`          Referenced file to be linked.   
  *   `destination`     Symbolic link to be created.   
  *   `exec`            Create an executable file with an `exec` command.   
  *   `chmod`           Default to 0755.   
  
  `callback`            Received parameters are:   
  
  *   `err`             Error object if any.   
  *   `linked`          Number of created links.
  */

  link: function(options, callback) {
    return misc.options(options, function(err, options) {
      var exec_create, exec_exists, linked, option, parents, sym_create, sym_exists;

      if (err) {
        return callback(err);
      }
      if (options.ssh) {
        return next(new Error('SSH not yet supported'));
      }
      linked = 0;
      sym_exists = function(options, callback) {
        return misc.file.exists(options.ssh, options.destination, function(err, exists) {
          if (!exists) {
            return callback(null, false);
          }
          return fs.readlink(options.destination, function(err, resolvedPath) {
            if (err) {
              return callback(err);
            }
            if (resolvedPath === options.source) {
              return callback(null, true);
            }
            return fs.unlink(options.destination, function(err) {
              if (err) {
                return callback(err);
              }
              return callback(null, false);
            });
          });
        });
      };
      sym_create = function(options, callback) {
        return fs.symlink(options.source, options.destination, function(err) {
          if (err) {
            return callback(err);
          }
          linked++;
          return callback();
        });
      };
      exec_exists = function(options, callback) {
        return misc.file.exists(options.ssh, options.destination, function(err, exists) {
          if (!exists) {
            return callback(null, false);
          }
          return misc.file.readFile(options.ssh, options.destination, function(err, content) {
            var exec_cmd;

            if (err) {
              return callback(err);
            }
            exec_cmd = /exec (.*) \$@/.exec(content)[1];
            return callback(null, exec_cmd && exec_cmd === options.source);
          });
        });
      };
      exec_create = function(options, callback) {
        var content;

        content = "#!/bin/bash\nexec " + options.source + " $@";
        return misc.file.writeFile(options.ssh, options.destination, content, function(err) {
          if (err) {
            return callback(err);
          }
          return fs.chmod(options.destination, options.chmod, function(err) {
            if (err) {
              return callback(err);
            }
            linked++;
            return callback();
          });
        });
      };
      parents = (function() {
        var _i, _len, _results;

        _results = [];
        for (_i = 0, _len = options.length; _i < _len; _i++) {
          option = options[_i];
          _results.push(path.normalize(path.dirname(option.destination)));
        }
        return _results;
      })();
      return mecano.mkdir(parents, function(err, created) {
        if (err) {
          return callback(err);
        }
        return each(options).parallel(true).on('item', function(options, next) {
          var dispatch, _ref;

          if (!options.source) {
            return next(new Error("Missing source, got " + (JSON.stringify(options.source))));
          }
          if (!options.destination) {
            return next(new Error("Missing destination, got " + (JSON.stringify(options.destination))));
          }
          if ((_ref = options.chmod) == null) {
            options.chmod = 0x1ed;
          }
          dispatch = function() {
            if (options.exec) {
              return exec_exists(options, function(err, exists) {
                if (exists) {
                  return next();
                }
                return exec_create(options, next);
              });
            } else {
              return sym_exists(options, function(err, exists) {
                if (exists) {
                  return next();
                }
                return sym_create(options, next);
              });
            }
          };
          return dispatch();
        }).on('both', function(err) {
          return callback(err, linked);
        });
      });
    });
  },
  /*
  
  `mkdir(options, callback)`
  --------------------------
  
  Recursively create a directory. The behavior is similar to the Unix command `mkdir -p`. 
  It supports an alternative syntax where options is simply the path of the directory
  to create.
  
  `options`           Command options include:   
  
  *   `source`        Path or array of paths.   
  *   `directory`     Alias for `source`
  *   `destination`   Alias for `source`
  *   `exclude`       Regular expression.   
  *   `chmod`         Default to 0755.  
  *   `cwd`           Current working directory for relative paths.   
  
  `callback`          Received parameters are:   
  
  *   `err`           Error object if any.   
  *   `created`       Number of created directories
  
  Simple usage:
  
      mecano.mkdir './some/dir', (err, created) ->
        console.log err?.message ? created
  */

  mkdir: function(options, callback) {
    var finish, result;

    result = child(mecano);
    finish = function(err, created) {
      if (callback) {
        callback(err, created);
      }
      return result.end(err, created);
    };
    misc.options(options, function(err, options) {
      var created;

      if (err) {
        return finish(err);
      }
      created = 0;
      return each(options).on('item', function(options, next) {
        var check, create, cwd, _ref, _ref1, _ref2;

        if (typeof options === 'string') {
          options = {
            source: options
          };
        }
        if ((_ref = options.source) == null) {
          options.source = options.directory;
        }
        if ((_ref1 = options.source) == null) {
          options.source = options.destination;
        }
        if (options.source == null) {
          return next(new Error('Missing source option'));
        }
        cwd = (_ref2 = options.cwd) != null ? _ref2 : process.cwd();
        options.source = path.resolve(cwd, options.source);
        check = function() {
          return misc.file.stat(options.ssh, options.source, function(err, stat) {
            if (err && err.code === 'ENOENT') {
              return create();
            }
            if (err) {
              return next(err);
            }
            if (stat.isDirectory()) {
              return next();
            }
            return next(err('Invalid source, got #{JSON.encode(options.source)}'));
          });
        };
        create = function() {
          var current, dirCreated, dirs, _ref3;

          if ((_ref3 = options.chmod) == null) {
            options.chmod = 0x1ed;
          }
          current = '';
          dirCreated = false;
          dirs = options.source.split('/');
          return each(dirs).on('item', function(dir, next) {
            if ((options.exclude != null) && options.exclude instanceof RegExp) {
              if (options.exclude.test(dir)) {
                return next();
              }
            }
            current += "/" + dir;
            return misc.file.exists(options.ssh, current, function(err, exists) {
              if (exists) {
                return next();
              }
              return misc.file.mkdir(options.ssh, current, options, function(err) {
                if (err) {
                  return next(err);
                }
                dirCreated = true;
                return next();
              });
            });
          }).on('both', function(err) {
            if (dirCreated) {
              created++;
            }
            return next(err);
          });
        };
        return conditions.all(options, next, check);
      }).on('both', function(err) {
        return finish(err, created);
      });
    });
    return result;
  },
  /*
  
  `mv` `move(options, callback)`
  --------------------------------
  
  More files and directories.
  
  `options`         Command options include:   
  
  *   `source`      File or directory to move.  
  *   `destination` Final name of the moved resource.    
  
  `callback`        Received parameters are:   
  
  *   `err`         Error object if any.   
  *   `moved`        Number of moved resources.
  
  Example
  
    mecano.mv
      source: __dirname
      desination: '/temp/my_dir'
    , (err, moved) ->
      console.log "#{moved} dir moved"
  */

  move: function(options, callback) {
    return misc.options(options, function(err, options) {
      var moved;

      if (err) {
        return callback(err);
      }
      moved = 0;
      return each(options).on('item', function(options, next) {
        var move;

        if (options.ssh) {
          return next(new Error('SSH not yet supported'));
        }
        move = function() {
          return fs.rename(options.source, options.destination, function(err) {
            if (err) {
              return next(err);
            }
            moved++;
            return next();
          });
        };
        return conditions.all(options, next, move);
      }).on('both', function(err) {
        return callback(err, moved);
      });
    });
  },
  /*
  
  `rm` `remove(options, callback)`
  --------------------------------
  
  Recursively remove files, directories and links. Internally, the function 
  use the [rimraf](https://github.com/isaacs/rimraf) library.
  
  `options`         Command options include:   
  
  *   `source`      File, directory or pattern.  
  *   `destination` Alias for "source". 
  
  `callback`        Received parameters are:   
  
  *   `err`         Error object if any.   
  *   `removed`     Number of removed sources.   
  
  Example
  
      mecano.rm './some/dir', (err, removed) ->
        console.log "#{removed} dir removed"
  
  Removing a directory unless a given file exists
  
      mecano.rm
        source: './some/dir'
        not_if_exists: './some/file'
      , (err, removed) ->
        console.log "#{removed} dir removed"
  
  Removing multiple files and directories
  
      mecano.rm [
        { source: './some/dir', not_if_exists: './some/file' }
        './some/file'
      ], (err, removed) ->
        console.log "#{removed} dirs removed"
  */

  remove: function(options, callback) {
    var finish, result;

    result = child(mecano);
    finish = function(err, removed) {
      if (callback) {
        callback(err, removed);
      }
      return result.end(err, removed);
    };
    misc.options(options, function(err, options) {
      var removed;

      if (err) {
        return finish(err);
      }
      removed = 0;
      return each(options).on('item', function(options, next) {
        var remove, _ref;

        if (typeof options === 'string') {
          options = {
            source: options
          };
        }
        if ((_ref = options.source) == null) {
          options.source = options.destination;
        }
        if (options.source == null) {
          return next(new Error("Missing source"));
        }
        remove = function() {
          if (options.ssh) {
            return misc.file.exists(options.ssh, options.source, function(err, exists) {
              if (err) {
                return next(err);
              }
              if (exists) {
                removed++;
              }
              return misc.file.remove(options.ssh, options.source, next);
            });
          } else {
            return each().files(options.source).on('item', function(file, next) {
              removed++;
              return misc.file.remove(options.ssh, file, next);
            }).on('error', function(err) {
              return next(err);
            }).on('end', function() {
              return next();
            });
          }
        };
        return conditions.all(options, next, remove);
      }).on('both', function(err) {
        return finish(err, removed);
      });
    });
    return result;
  },
  /*
  
  `render(options, callback)`
  ---------------------------
  
  Render a template file At the moment, only the 
  [ECO](http://github.com/sstephenson/eco) templating engine is integrated.   
  
  `options`           Command options include:   
  
  *   `engine`        Template engine to use, default to "eco"   
  *   `content`       Templated content, bypassed if source is provided.   
  *   `source`        File path where to extract content from.   
  *   `destination`   File path where to write content to or a callback.   
  *   `context`       Map of key values to inject into the template.   
  *   `local_source`  Treat the source as local instead of remote, only apply with "ssh" option.   
  
  `callback`          Received parameters are:   
  
  *   `err`           Error object if any.   
  *   `rendered`      Number of rendered files.   
  
  If destination is a callback, it will be called multiple times with the   
  generated content as its first argument.
  */

  render: function(options, callback) {
    return misc.options(options, function(err, options) {
      var rendered;

      if (err) {
        return callback(err);
      }
      rendered = 0;
      return each(options).on('item', function(options, next) {
        var readSource, writeContent;

        if (!(options.source || options.content)) {
          return next(new Error('Missing source or content'));
        }
        if (!options.destination) {
          return next(new Error('Missing destination'));
        }
        readSource = function() {
          var ssh;

          if (!options.source) {
            return writeContent();
          }
          ssh = options.local_source ? null : options.ssh;
          return misc.file.exists(ssh, options.source, function(err, exists) {
            if (!exists) {
              return next(new Error("Invalid source, got " + (JSON.stringify(options.source))));
            }
            return misc.file.readFile(ssh, options.source, function(err, content) {
              if (err) {
                return next(err);
              }
              options.content = content;
              return writeContent();
            });
          });
        };
        writeContent = function() {
          options.source = null;
          return mecano.write(options, function(err, written) {
            if (err) {
              return next(err);
            }
            if (written) {
              rendered++;
            }
            return next();
          });
        };
        return conditions.all(options, next, readSource);
      }).on('both', function(err) {
        return callback(err, rendered);
      });
    });
  },
  /*
  `service(options, callback)`
  ----------------------------
  
  Install a service. For now, only yum over SSH.
  
  `options`             Command options include:   
  
  *    name             Package name.
  *    startup          Run service daemon on startup.
  *    yum_name         Name used by the yum utility, default to "name".
  *    chk_name         Name used by the chkconfig utility, default to "srv_name" and "name".
  *    srv_name         Name used by the service utility, default to "name".
  *    start            Ensure the service is started, a boolean.
  *    stop             Ensure the service is stopped, a boolean.
  
  `callback`            Received parameters are:   
  
  *   `err`             Error object if any.   
  *   `modified`        Number of action taken (installed, updated, started or stoped).
  */

  service: function(options, callback) {
    return misc.options(options, function(err, options) {
      var serviced;

      if (err) {
        return callback(err);
      }
      serviced = 0;
      return each(options).on('item', function(options, next) {
        var action, chkname, finish, install, installed, modified, pkgname, srvname, started, startup_add, startup_del, startuped, stderr, updates;

        if (!options.name) {
          return next(new Error('Missing service name'));
        }
        if (!options.ssh) {
          return next(new Error('Restricted to Yum over SSH'));
        }
        if ((options.start != null) && options.start === options.stop) {
          return next(new Error('Invalid configuration, start conflict with stop'));
        }
        pkgname = options.yum_name || options.name;
        chkname = options.chk_name || options.srv_name || options.name;
        srvname = options.srv_name || options.name;
        if ((options.startup != null) && typeof options.startup !== 'string') {
          options.startup = options.startup ? '2345' : '';
        }
        modified = false;
        stderr = new EventEmitter();
        stderr.writable = true;
        stderr.write = function(data) {};
        installed = function() {
          return mecano.execute({
            ssh: options.ssh,
            cmd: "yum list installed | grep ^" + pkgname + "\\\\.",
            code_skipped: 1,
            stderr: stderr
          }, function(err, installed) {
            if (err) {
              return next(err);
            }
            if (installed) {
              return updates();
            } else {
              return install();
            }
          });
        };
        updates = function() {
          return mecano.execute({
            ssh: options.ssh,
            cmd: "yum list updates | grep ^" + pkgname + "\\\\.",
            code_skipped: 1
          }, function(err, outdated) {
            if (err) {
              return next(err);
            }
            if (outdated) {
              return install();
            } else {
              return startuped();
            }
          });
        };
        install = function() {
          return mecano.execute({
            ssh: options.ssh,
            cmd: "yum install -y " + pkgname,
            code_skipped: 1
          }, function(err, succeed) {
            if (err) {
              return next(err);
            }
            if (!succeed) {
              return next(new Error("No package " + pkgname + " available."));
            }
            if (installed) {
              modified = true;
            }
            return startuped();
          });
        };
        startuped = function() {
          if (options.startup == null) {
            return started();
          }
          return mecano.execute({
            ssh: options.ssh,
            cmd: "chkconfig --list " + chkname,
            code_skipped: 1
          }, function(err, registered, stdout, stderr) {
            var c, current_startup, level, status, _i, _len, _ref, _ref1;

            if (err) {
              return next(err);
            }
            if (/^error/.test(stderr)) {
              return next(new Error("Invalid chkconfig name " + chkname));
            }
            current_startup = '';
            if (registered) {
              _ref = stdout.split(' ').pop().trim().split('\t');
              for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                c = _ref[_i];
                _ref1 = c.split(':'), level = _ref1[0], status = _ref1[1];
                if (status === 'on') {
                  current_startup += level;
                }
              }
            }
            if (options.startup === current_startup) {
              return started();
            }
            modified = true;
            if (options.startup) {
              return startup_add();
            } else {
              return startup_del();
            }
          });
        };
        startup_add = function() {
          var cmd, i, startup_off, startup_on, _i;

          startup_on = startup_off = '';
          for (i = _i = 0; _i < 6; i = ++_i) {
            if (options.startup.indexOf(i) !== -1) {
              startup_on += i;
            } else {
              startup_off += i;
            }
          }
          cmd = "chkconfig --add " + chkname + ";";
          if (startup_on) {
            cmd += "chkconfig --level " + startup_on + " " + chkname + " on;";
          }
          if (startup_off) {
            cmd += "chkconfig --level " + startup_off + " " + chkname + " off;";
          }
          return mecano.execute({
            ssh: options.ssh,
            cmd: cmd
          }, function(err, stream) {
            if (err) {
              return next(err);
            }
            return started();
          });
        };
        startup_del = function() {
          return mecano.execute({
            ssh: options.ssh,
            cmd: "chkconfig --del " + chkname
          }, function(err, stream) {
            if (err) {
              return next(err);
            }
            return started();
          });
        };
        started = function() {
          if (!options.action) {
            return finish();
          }
          return mecano.execute({
            ssh: options.ssh,
            cmd: "service " + srvname + " status",
            code_skipped: 3
          }, function(err, started) {
            if (err) {
              return next(err);
            }
            if (started) {
              if (options.action !== 'start') {
                return action();
              }
            } else {
              if (options.action !== 'stop') {
                return action();
              }
            }
            return finish();
          });
        };
        action = function() {
          return mecano.execute({
            ssh: options.ssh,
            cmd: "service " + srvname + " " + options.action
          }, function(err, executed) {
            if (err) {
              return next(err);
            }
            return finish();
          });
        };
        finish = function() {
          if (modified) {
            serviced++;
          }
          return next();
        };
        return conditions.all(options, next, installed);
      }).on('both', function(err) {
        return callback(err, serviced);
      });
    });
  },
  /*
  
  `upload(options, callback)`
  ---------------------------
  
  Upload a file to a remote location. Options are 
  identical to the "write" function with the addition of 
  the "binary" option.
  
  `options`           Command options include:   
  
  *   `binary`        Fast upload implementation, discard all the other option and use its own stream based implementation.   
  *   `from`          Replace from after this marker, a string or a regular expression.   
  *   `to`            Replace to before this marker, a string or a regular expression.   
  *   `match`         Replace this marker, a string or a regular expression.   
  *   `replace`       The content to be inserted, used conjointly with the from, to or match options.   
  *   `content`       Text to be written.   
  *   `source`        File path from where to extract the content, do not use conjointly with content.   
  *   `destination`   File path where to write content to.   
  *   `backup`        Create a backup, append a provided string to the filename extension or a timestamp if value is not a string.   
  
  `callback`          Received parameters are:   
  
  *   `err`           Error object if any.   
  *   `rendered`      Number of rendered files.
  */

  upload: function(options, callback) {
    return misc.options(options, function(err, options) {
      var uploaded;

      if (err) {
        return callback(err);
      }
      uploaded = 0;
      return each(options).on('item', function(options, next) {
        if (options.binary) {
          return options.ssh.sftp(function(err, sftp) {
            var from, to;

            from = fs.createReadStream(options.source);
            to = sftp.createWriteStream(options.destination);
            from.pipe(to);
            from.on('error', function(err) {
              return next(err);
            });
            return from.on('end', function() {
              uploaded++;
              return next();
            });
          });
        }
        options = misc.merge(options, {
          local_source: true
        });
        return mecano.write(options, function(err, written) {
          if (written === 1) {
            uploaded++;
          }
          return next(err);
        });
      }).on('both', function(err) {
        return callback(err, uploaded);
      });
    });
  },
  /*
  
  `write(options, callback)`
  --------------------------
  
  Write a file or a portion of an existing file.
  
  `options`            Command options include:   
  
  *   `from`           Replace from after this marker, a string or a regular expression.   
  *   `to`             Replace to before this marker, a string or a regular expression.   
  *   `match`          Replace this marker, a string or a regular expression.   
  *   `replace`        The content to be inserted, used conjointly with the from, to or match options.   
  *   `content`        Text to be written, an alternative to source which reference a file.   
  *   `source`         File path from where to extract the content, do not use conjointly with content.   
  *   `destination`    File path where to write content to.   
  *   `backup`         Create a backup, append a provided string to the filename extension or a timestamp if value is not a string.   
  *   `append`         Append the content to the destination file. If destination does not exist, the file will be created. When used with the `match` and `replace` options, it will append the `replace` value at the end of the file if no match if found and if the value is a string.   
  *   `ssh`            Run the action on a remote server using SSH, an ssh2 instance or an configuration object used to initialize the SSH connection.   
  
  `callback`           Received parameters are:   
  
  *   `err`            Error object if any.   
  *   `rendered`       Number of rendered files.   
  
  Example replacing part of a file using from and to markers
  
      mecano.write
        content: 'here we are\n# from\nlets try to replace that one\n# to\nyou coquin'
        from: '# from\n'
        to: '# to'
        replace: 'my friend\n'
        destination: "#{scratch}/a_file"
      , (err, written) ->
        # here we are\n# from\nmy friend\n# to\nyou coquin
  
  Example replacing part of a file using a regular expression
  
      mecano.write
        content: 'here we are\nlets try to replace that one\nyou coquin'
        match: /(.*try) (.*)/
        replace: ['my friend, $1']
        destination: "#{scratch}/a_file"
      , (err, written) ->
        # here we are\nmy friend, lets try\nyou coquin
  
  Example replacing with the global and multiple lines options
  
      mecano.write
        content: '#A config file\n#property=30\nproperty=10\n#End of Config'
        match: /^property=.*$/mg
        replace: 'property=50'
        destination: "#{scratch}/replace"
      , (err, written) ->
        '#A config file\n#property=30\nproperty=50\n#End of Config'
  */

  write: function(options, callback) {
    var finish, result;

    result = child(mecano);
    finish = function(err, written) {
      if (callback) {
        callback(err, written);
      }
      return result.end(err, written);
    };
    misc.options(options, function(err, options) {
      var written;

      if (err) {
        return finish(err);
      }
      written = 0;
      return each(options).on('item', function(options, next) {
        var backup, content, destination, destinationHash, extractPartial, from, fullContent, readDestination, readSource, render, replacePartial, to, writeContent;

        if (!((options.source || (options.content != null)) || options.replace)) {
          return next(new Error('Missing source or content'));
        }
        if (options.source && options.content) {
          return next(new Error('Define either source or content'));
        }
        if (!options.destination) {
          return next(new Error('Missing destination'));
        }
        destination = null;
        destinationHash = null;
        content = fullContent = null;
        from = to = null;
        readSource = function() {
          var ssh, _ref;

          if (options.content != null) {
            content = options.content;
            return extractPartial();
          }
          if ((_ref = options.source) == null) {
            options.source = options.destination;
          }
          ssh = options.local_source ? null : options.ssh;
          return misc.file.exists(ssh, options.source, function(err, exists) {
            if (err) {
              return next(err);
            }
            if (!exists) {
              content = '';
              return extractPartial();
            }
            return misc.file.readFile(ssh, options.source, function(err, src) {
              if (err) {
                return next(err);
              }
              content = src;
              return extractPartial();
            });
          });
        };
        extractPartial = function() {
          if (!((options.from != null) || (options.to != null) || (options.match != null))) {
            return readDestination();
          }
          fullContent = content;
          content = options.replace;
          return readDestination();
        };
        readDestination = function() {
          if (typeof options.destination === 'function') {
            return render();
          }
          return misc.file.exists(options.ssh, options.destination, function(err, exists) {
            if (!exists) {
              return render();
            }
            return misc.file.readFile(options.ssh, options.destination, function(err, dest) {
              if (err) {
                return next(err);
              }
              destinationHash = misc.string.hash(dest);
              return render();
            });
          });
        };
        render = function() {
          if (options.context == null) {
            return replacePartial();
          }
          try {
            content = eco.render(content.toString(), options.context);
          } catch (_error) {
            err = _error;
            return next(err);
          }
          return replacePartial();
        };
        replacePartial = function() {
          if (fullContent == null) {
            return writeContent();
          }
          if (options.match) {
            if (options.match instanceof RegExp) {
              content = fullContent.replace(options.match, content);
              if (content === fullContent && options.append && typeof options.replace === 'string') {
                content = content.length === 0 || content.substr(content.length - 1) === '\n' ? '' : '\n';
                content += options.replace;
              }
            } else {
              from = fullContent.indexOf(options.match);
              to = from + options.match.length;
              content = fullContent.substr(0, from) + content + fullContent.substr(to);
            }
          } else {
            from = options.from ? fullContent.indexOf(options.from) + options.from.length : 0;
            to = options.to ? fullContent.indexOf(options.to) : fullContent.length;
            content = fullContent.substr(0, from) + content + fullContent.substr(to);
          }
          fullContent = null;
          return writeContent();
        };
        writeContent = function() {
          var _ref;

          if (destinationHash === misc.string.hash(content)) {
            return next();
          }
          if (typeof options.destination === 'function') {
            options.destination(content);
            return next();
          } else {
            if (options.append) {
              if ((_ref = options.flags) == null) {
                options.flags = 'a';
              }
            }
            return misc.file.writeFile(options.ssh, options.destination, content, options, function(err) {
              if (err) {
                return next(err);
              }
              written++;
              return backup();
            });
          }
        };
        backup = function() {
          if (!options.backup) {
            return next();
          }
          backup = options.backup;
          if (backup === true) {
            backup = "." + (Date.now());
          }
          backup = "" + options.destination + backup;
          return misc.file.writeFile(options.ssh, backup, content, function(err) {
            if (err) {
              return next(err);
            }
            return next();
          });
        };
        return conditions.all(options, next, readSource);
      }).on('both', function(err) {
        return finish(err, written);
      });
    });
    return result;
  }
};

mecano.cp = mecano.copy;

mecano.exec = mecano.execute;

mecano.ln = mecano.link;

mecano.mv = mecano.move;

mecano.rm = mecano.remove;
