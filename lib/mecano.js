// Generated by CoffeeScript 1.4.0
var conditions, each, eco, exec, fs, mecano, misc, open, path, rimraf, util, _ref;

fs = require('fs');

path = require('path');

if ((_ref = fs.exists) == null) {
  fs.exists = path.exists;
}

util = require('util');

each = require('each');

eco = require('eco');

rimraf = require('rimraf');

exec = require('child_process').exec;

open = require('open-uri');

conditions = require('./conditions');

misc = require('./misc');

/*

Mecano gather a set of functions usually used during system deployment. All the functions share a 
common API with flexible options.
*/


mecano = module.exports = {
  /*
  
    `cp` `copy(options, callback)`
    ------------------------------
  
    Copy a file.
  
    `options`         Command options include:   
  
    *   `source`      The file or directory to copy.
    *   `destination`     Where the file or directory is copied.
    *   `force`       Copy the file even if one already exists.
    *   `not_if_exists`   Equals destination if true.
    *   `chmod`       Permissions of the file or the parent directory
  
    `callback`        Received parameters are:   
  
    *   `err`         Error object if any.   
    *   `copied`      Number of files or parent directories copied.
  
    todo:
    *   deal with directories
    *   preserve permissions if `chmod` is `true`
    *   Compare files with checksum
  */

  copy: function(options, callback) {
    var copied;
    options = misc.options(options);
    copied = 0;
    return each(options).on('item', function(next, options) {
      var chmod, copy, dstStat, finish, source;
      if (!options.source) {
        return next(new Error('Missing source'));
      }
      if (!options.destination) {
        return next(new Error('Missing destination'));
      }
      if (options.not_if_exists === true) {
        options.not_if_exists = options.destination;
      }
      dstStat = null;
      source = function() {
        return fs.stat(options.source, function(err, stat) {
          if (err) {
            return next(err);
          }
          if (stat.isDirectory()) {
            return next(new Error('Source is a directory'));
          }
          return copy();
        });
      };
      copy = function(destination) {
        if (destination == null) {
          destination = options.destination;
        }
        return fs.stat(destination, function(err, stat) {
          var dirExists, fileExists, input, output;
          dstStat = stat;
          if (err && err.code !== 'ENOENT') {
            return next(err);
          }
          dirExists = !err && stat.isDirectory();
          fileExists = !err && stat.isFile();
          if (fileExists && !options.force) {
            return next(null, 0);
          }
          if (dirExists) {
            return copy(path.resolve(options.destination, path.basename(options.source)));
          }
          input = fs.createReadStream(options.source);
          output = fs.createWriteStream(destination);
          return util.pump(input, output, function(err) {
            if (err) {
              return next(err);
            }
            return chmod();
          });
        });
      };
      chmod = function() {
        if (!options.chmod || options.chmod === dstStat.mode) {
          return finish();
        }
        return fs.chmod(options.destination, options.chmod, function(err) {
          if (err) {
            return next(err);
          }
          return finish();
        });
      };
      finish = function() {
        copied++;
        return next();
      };
      return conditions.all(options, next, copy);
    }).on('both', function(err) {
      return callback(err, copied);
    });
  },
  /*
  
    `download(options, callback)`
    -----------------------------
  
    Download files using various protocols. The excellent 
    [open-uri](https://github.com/publicclass/open-uri) module provides support for HTTP(S), 
    file and FTP. All the options supported by open-uri are passed to it.
  
    Note, GIT is not yet supported but documented as a wished feature.
  
    `options`         Command options include:   
  
    *   `source`      File, HTTP URL, FTP, GIT repository. File is the default protocol if source is provided without a scheme.   
    *   `destination` Path where the file is downloaded.   
    *   `force`       Overwrite destination file if it exists.   
  
    `callback`        Received parameters are:   
  
    *   `err`         Error object if any.   
    *   `downloaded`  Number of downloaded files
  
    Basic example:
        mecano.download
          source: 'https://github.com/wdavidw/node-sigar/tarball/v0.0.1'
          destination: 'node-sigar.tgz'
        , (err, downloaded) ->
          fs.exists 'node-sigar.tgz', (exists) ->
            assert.ok exists
  */

  download: function(options, callback) {
    var downloaded;
    options = misc.options(options);
    downloaded = 0;
    return each(options).on('item', function(next, options) {
      var download, _ref1;
      if (!options.source) {
        return next(new Error("Missing source: " + options.source));
      }
      if (!options.destination) {
        return next(new Error("Missing destination: " + options.destination));
      }
      if ((_ref1 = options.force) == null) {
        options.force = false;
      }
      download = function() {
        var destination;
        destination = fs.createWriteStream(options.destination);
        open(options.source, destination);
        destination.on('close', function() {
          downloaded++;
          return next();
        });
        return destination.on('error', function(err) {
          return next(err);
        });
      };
      return fs.exists(options.destination, function(exists) {
        if (exists && !options.force) {
          return next();
        } else if (exists) {
          return rimraf(options.destination, function(err) {
            if (err) {
              return next(err);
            }
            return download();
          });
        } else {
          return download();
        }
      });
    }).on('both', function(err) {
      return callback(err, downloaded);
    });
  },
  /*
  
    `exec` `execute([goptions], options, callback)`
    -----------------------------------------------
    Run a command locally or with ssh if the `host` is provided. Global options is
    optional and is used in case where options is defined as an array of 
    multiple commands. Note, `opts` inherites all the properties of `goptions`.
  
    `goptions`        Global options includes:
  
    *   `parallel`    Wether the command are run in sequential, parallel 
    or limited concurrent mode. See the `node-each` documentation for more 
    details. Default to sequential (false).
          
    `options`         Include all conditions as well as:  
  
    *   `cmd`         String, Object or array; Command to execute.   
    *   `env`         Environment variables, default to `process.env`.   
    *   `cwd`         Current working directory.   
    *   `uid`         Unix user id.   
    *   `gid`         Unix group id.   
    *   `code`        Expected code(s) returned by the command, int or array of int, default to 0.   
    *   `host`        SSH host or IP address.   
    *   `username`    SSH host or IP address.   
    *   `stdout`      Writable EventEmitter in which command output will be piped.   
    *   `stderr`      Writable EventEmitter in which command error will be piped.   
  
    `callback`        Received parameters are:   
  
    *   `err`         Error if any.   
    *   `executed`    Number of executed commandes.   
    *   `stdout`      Stdout value(s) unless `stdout` option is provided.   
    *   `stderr`      Stderr value(s) unless `stderr` option is provided.
  */

  execute: function(goptions, options, callback) {
    var escape, executed, isArray, stderrs, stdouts;
    if (arguments.length === 2) {
      callback = options;
      options = goptions;
    }
    isArray = Array.isArray(options);
    options = misc.options(options);
    executed = 0;
    stdouts = [];
    stderrs = [];
    escape = function(cmd) {
      var char, esccmd, _i, _len;
      esccmd = '';
      for (_i = 0, _len = cmd.length; _i < _len; _i++) {
        char = cmd[_i];
        if (char === '$') {
          esccmd += '\\';
        }
        esccmd += char;
      }
      return esccmd;
    };
    return each(options).parallel(goptions.parallel).on('item', function(next, option, i) {
      var cmd, cmdOption, _ref1;
      if (typeof option === 'string') {
        option = {
          cmd: option
        };
      }
      misc.merge(true, option, goptions);
      if (option.cmd == null) {
        return next(new Error("Missing cmd: " + option.cmd));
      }
      if ((_ref1 = option.code) == null) {
        option.code = [0];
      }
      if (!Array.isArray(option.code)) {
        option.code = [option.code];
      }
      cmdOption = {};
      cmdOption.env = option.env || process.env;
      cmdOption.cwd = option.cwd || null;
      if (options.uid) {
        cmdOption.uid = option.uid;
      }
      if (options.gid) {
        cmdOption.gid = option.gid;
      }
      cmd = function() {
        var run, stderr, stdout;
        if (option.host) {
          option.cmd = escape(option.cmd);
          option.cmd = option.host + ' "' + option.cmd + '"';
          if (option.username) {
            option.cmd = option.username + '@' + option.cmd;
          }
          option.cmd = 'ssh -o StrictHostKeyChecking=no ' + option.cmd;
        }
        run = exec(option.cmd, cmdOption);
        stdout = stderr = '';
        if (option.stdout) {
          run.stdout.pipe(option.stdout);
        } else {
          run.stdout.on('data', function(data) {
            return stdout += data;
          });
        }
        if (option.stderr) {
          run.stderr.pipe(option.stderr);
        } else {
          run.stderr.on('data', function(data) {
            return stderr += data;
          });
        }
        return run.on("exit", function(code) {
          return setTimeout(function() {
            var err;
            executed++;
            stdouts.push(option.stdout ? void 0 : stdout);
            stderrs.push(option.stderr ? void 0 : stderr);
            if (option.code.indexOf(code) === -1) {
              err = new Error("Invalid exec code " + code);
              err.code = code;
              return next(err);
            }
            return next();
          }, 1);
        });
      };
      return conditions.all(option, next, cmd);
    }).on('both', function(err) {
      if (!isArray) {
        stdouts = stdouts[0];
      }
      if (!isArray) {
        stderrs = stderrs[0];
      }
      return callback(err, executed, stdouts, stderrs);
    });
  },
  /*
  
    `extract(options, callback)` 
    ----------------------------
  
    Extract an archive. Multiple compression types are supported. Unless 
    specified asan option, format is derived from the source extension. At the 
    moment, supported extensions are '.tgz', '.tar.gz' and '.zip'.   
  
    `options`             Command options include:   
  
    *   `source`          Archive to decompress.   
    *   `destination`     Default to the source parent directory.   
    *   `format`          One of 'tgz' or 'zip'.   
    *   `creates`         Ensure the given file is created or an error is send in the callback.   
    *   `not_if_exists`   Cancel extraction if file exists.   
  
    `callback`            Received parameters are:   
  
    *   `err`             Error object if any.   
    *   `extracted`       Number of extracted archives.
  */

  extract: function(options, callback) {
    var extracted;
    options = misc.options(options);
    extracted = 0;
    return each(options).on('item', function(next, options) {
      var creates, destination, ext, extract, format, success, _ref1;
      if (!options.source) {
        return next(new Error("Missing source: " + options.source));
      }
      destination = (_ref1 = options.destination) != null ? _ref1 : path.dirname(options.source);
      if (options.format != null) {
        format = options.format;
      } else {
        if (/\.(tar\.gz|tgz)$/.test(options.source)) {
          format = 'tgz';
        } else if (/\.zip$/.test(options.source)) {
          format = 'zip';
        } else {
          ext = path.extname(options.source);
          return next(new Error("Unsupported extension, got " + (JSON.stringify(ext))));
        }
      }
      extract = function() {
        var cmd;
        cmd = null;
        switch (format) {
          case 'tgz':
            cmd = "tar xzf " + options.source + " -C " + destination;
            break;
          case 'zip':
            cmd = "unzip -u " + options.source + " -d " + destination;
        }
        return exec(cmd, function(err, stdout, stderr) {
          if (err) {
            return next(err);
          }
          return creates();
        });
      };
      creates = function() {
        if (options.creates == null) {
          return success();
        }
        return fs.exists(options.creates, function(exists) {
          if (!exists) {
            return next(new Error("Failed to create '" + (path.basename(options.creates)) + "'"));
          }
          return success();
        });
      };
      success = function() {
        extracted++;
        return next();
      };
      return conditions.all(options, next, extract);
    }).on('both', function(err) {
      return callback(err, extracted);
    });
  },
  /*
    
    `git`
    -----
  
    `options`             Command options include:   
  
    *   `source`          Git source repository address.
    *   `destination`     Directory where to clone the repository.
    *   `revision`        Git revision, branch or tag.
  */

  git: function(options, callback) {
    var updated;
    options = misc.options(options);
    updated = 0;
    return each(options).on('item', function(next, options) {
      var checkout, clone, log, prepare, rev, _ref1;
      if ((_ref1 = options.revision) == null) {
        options.revision = 'HEAD';
      }
      rev = null;
      prepare = function() {
        return fs.stat(options.destination, function(err, stat) {
          var gitDir;
          if (err && err.code === 'ENOENT') {
            return clone();
          }
          if (!stat.isDirectory()) {
            return next(new Error("Destination not a directory, got " + options.destination));
          }
          gitDir = "" + options.destination + "/.git";
          return fs.stat(gitDir, function(err, stat) {
            if (err || !stat.isDirectory()) {
              return next(err);
            }
            return log();
          });
        });
      };
      clone = function() {
        return mecano.exec({
          cmd: "git clone " + options.source + " " + (path.basename(options.destination)),
          cwd: path.dirname(options.destination)
        }, function(err, executed, stdout, stderr) {
          if (err) {
            return next(err);
          }
          return checkout();
        });
      };
      log = function() {
        return mecano.exec({
          cmd: "git log --pretty=format:'%H' -n 1",
          cwd: options.destination
        }, function(err, executed, stdout, stderr) {
          var current;
          if (err) {
            return next(err);
          }
          current = stdout.trim();
          return mecano.exec({
            cmd: "git rev-list --max-count=1 " + options.revision,
            cwd: options.destination
          }, function(err, executed, stdout, stderr) {
            if (err) {
              return next(err);
            }
            if (stdout.trim() !== current) {
              return checkout();
            } else {
              return next();
            }
          });
        });
      };
      checkout = function() {
        return mecano.exec({
          cmd: "git checkout " + options.revision,
          cwd: options.destination
        }, function(err) {
          if (err) {
            return next(err);
          }
          updated++;
          return next();
        });
      };
      return conditions.all(options, next, prepare);
    }).on('both', function(err) {
      return callback(err, updated);
    });
  },
  /*
  
    `ln` `link(options, callback)`
    ------------------------------
    Create a symbolic link and it's parent directories if they don't yet
    exist.
  
    `options`             Command options include:   
  
    *   `source`          Referenced file to be linked.   
    *   `destination`     Symbolic link to be created.   
    *   `exec`            Create an executable file with an `exec` command.   
    *   `chmod`           Default to 0755.   
  
    `callback`            Received parameters are:   
  
    *   `err`             Error object if any.   
    *   `linked`          Number of created links.
  */

  link: function(options, callback) {
    var exec_create, exec_exists, linked, option, parents, sym_create, sym_exists;
    options = misc.options(options);
    linked = 0;
    sym_exists = function(option, callback) {
      return fs.exists(option.destination, function(exists) {
        if (!exists) {
          return callback(null, false);
        }
        return fs.readlink(option.destination, function(err, resolvedPath) {
          if (err) {
            return callback(err);
          }
          if (resolvedPath === option.source) {
            return callback(null, true);
          }
          return fs.unlink(option.destination, function(err) {
            if (err) {
              return callback(err);
            }
            return callback(null, false);
          });
        });
      });
    };
    sym_create = function(option, callback) {
      return fs.symlink(option.source, option.destination, function(err) {
        if (err) {
          return callback(err);
        }
        linked++;
        return callback();
      });
    };
    exec_exists = function(option, callback) {
      return fs.exists(option.destination, function(exists) {
        if (!exists) {
          return callback(null, false);
        }
        return fs.readFile(option.destination, 'ascii', function(err, content) {
          var exec_cmd;
          if (err) {
            return callback(err);
          }
          exec_cmd = /exec (.*) \$@/.exec(content)[1];
          return callback(null, exec_cmd && exec_cmd === option.source);
        });
      });
    };
    exec_create = function(option, callback) {
      var content;
      content = "#!/bin/bash\nexec " + option.source + " $@";
      return fs.writeFile(option.destination, content, function(err) {
        if (err) {
          return callback(err);
        }
        return fs.chmod(option.destination, option.chmod, function(err) {
          if (err) {
            return callback(err);
          }
          linked++;
          return callback();
        });
      });
    };
    parents = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = options.length; _i < _len; _i++) {
        option = options[_i];
        _results.push(path.normalize(path.dirname(option.destination)));
      }
      return _results;
    })();
    return mecano.mkdir(parents, function(err, created) {
      if (err) {
        return callback(err);
      }
      return each(options).parallel(true).on('item', function(next, option) {
        var dispatch, _ref1;
        if (!option.source) {
          return next(new Error("Missing source, got " + (JSON.stringify(option.source))));
        }
        if (!option.destination) {
          return next(new Error("Missing destination, got " + (JSON.stringify(option.destination))));
        }
        if ((_ref1 = option.chmod) == null) {
          option.chmod = 0x1ed;
        }
        dispatch = function() {
          if (option.exec) {
            return exec_exists(option, function(err, exists) {
              if (exists) {
                return next();
              }
              return exec_create(option, next);
            });
          } else {
            return sym_exists(option, function(err, exists) {
              if (exists) {
                return next();
              }
              return sym_create(option, next);
            });
          }
        };
        return dispatch();
      }).on('both', function(err) {
        return callback(err, linked);
      });
    });
  },
  /*
  
    `mkdir(options, callback)`
    --------------------------
  
    Recursively create a directory. The behavior is similar to the Unix command `mkdir -p`. 
    It supports an alternative syntax where options is simply the path of the directory
    to create.
  
    `options`           Command options include:   
  
    *   `source`        Path or array of paths.   
    *   `directory`     Shortcut for `source`
    *   `exclude`       Regular expression.   
    *   `chmod`         Default to 0755.  
    *   `cwd`           Current working directory for relative paths.   
  
    `callback`          Received parameters are:   
  
    *   `err`           Error object if any.   
    *   `created`       Number of created directories
  
    Simple usage:
  
        mecano.mkdir './some/dir', (err, created) ->
          console.log err?.message ? created
  */

  mkdir: function(options, callback) {
    var created;
    options = misc.options(options);
    created = 0;
    return each(options).on('item', function(next, option) {
      var check, create, cwd, _ref1;
      if (typeof option === 'string') {
        option = {
          source: option
        };
      }
      if (!(option.source != null) && (option.directory != null)) {
        option.source = option.directory;
      }
      cwd = (_ref1 = option.cwd) != null ? _ref1 : process.cwd();
      option.source = path.resolve(cwd, option.source);
      if (option.source == null) {
        return next(new Error('Missing source option'));
      }
      check = function() {
        return fs.stat(option.source, function(err, stat) {
          if (err && err.code === 'ENOENT') {
            return create();
          }
          if (err) {
            return next(err);
          }
          if (stat.isDirectory()) {
            return next();
          }
          return next(err('Invalid source, got #{JSON.encode(option.source)}'));
        });
      };
      create = function() {
        var current, dirCreated, dirs, _ref2;
        if ((_ref2 = option.chmod) == null) {
          option.chmod = 0x1ed;
        }
        current = '';
        dirCreated = false;
        dirs = option.source.split('/');
        return each(dirs).on('item', function(next, dir) {
          if ((option.exclude != null) && option.exclude instanceof RegExp) {
            if (option.exclude.test(dir)) {
              return next();
            }
          }
          current += "/" + dir;
          return fs.exists(current, function(exists) {
            if (exists) {
              return next();
            }
            return fs.mkdir(current, option.chmod, function(err) {
              if (err) {
                return next(err);
              }
              dirCreated = true;
              return next();
            });
          });
        }).on('both', function(err) {
          if (dirCreated) {
            created++;
          }
          return next(err);
        });
      };
      return check();
    }).on('both', function(err) {
      return callback(err, created);
    });
  },
  /*
  
    `rm` `remove(options, callback)`
    --------------------------------
  
    Recursively remove a file or directory. Internally, the function 
    use the [rimraf](https://github.com/isaacs/rimraf) library.
  
    `options`         Command options include:   
  
    *   `source`      File or directory.   
  
    `callback`        Received parameters are:   
  
    *   `err`         Error object if any.   
    *   `deleted`     Number of deleted sources.   
  
    Example
  
        mecano.rm './some/dir', (err, removed) ->
          console.log "#{removed} dir removed"
    
    Removing a directory unless a given file exists
  
        mecano.rm
          source: './some/dir'
          not_if_exists: './some/file'
        , (err, removed) ->
          console.log "#{removed} dir removed"
    
    Removing multiple files and directories
  
        mecano.rm [
          { source: './some/dir', not_if_exists: './some/file' }
          './some/file'
        ], (err, removed) ->
          console.log "#{removed} dirs removed"
  */

  remove: function(options, callback) {
    var deleted;
    options = misc.options(options);
    deleted = 0;
    return each(options).on('item', function(next, options) {
      if (typeof options === 'string') {
        options = {
          source: options
        };
      }
      if (options.source == null) {
        return next(new Error('Missing source: #{option.source}'));
      }
      return fs.lstat(options.source, function(err, stat) {
        var _ref1;
        if (err) {
          return next();
        }
        if ((_ref1 = options.options) == null) {
          options.options = {};
        }
        return rimraf(options.source, function(err) {
          if (err) {
            return next(err);
          }
          deleted++;
          return next();
        });
      });
    }).on('both', function(err) {
      return callback(err, deleted);
    });
  },
  /*
  
    `render(options, callback)`
    ---------------------------
    
    Render a template file At the moment, only the 
    [ECO](http://github.com/sstephenson/eco) templating engine is integrated.
  
    `options`           Command options include:   
  
    *   `engine`        Template engine to use, default to "eco"
    *   `content`       Templated content, bypassed if source is provided.
    *   `source`        File path where to extract content from.
    *   `destination`   File path where to write content to.
    *   `context`       Map of key values to inject into the template.
  
    `callback`          Received parameters are:   
  
    *   `err`           Error object if any.   
    *   `rendered`      Number of rendered files.
  */

  render: function(options, callback) {
    var rendered;
    options = misc.options(options);
    rendered = 0;
    return each(options).on('item', function(next, option) {
      var readSource, writeContent;
      if (!(option.source || option.content)) {
        return next(new Error('Missing source or content'));
      }
      if (!option.destination) {
        return next(new Error('Missing destination'));
      }
      readSource = function() {
        if (!option.source) {
          return writeContent();
        }
        return fs.exists(option.source, function(exists) {
          if (!exists) {
            return next(new Error("Invalid source, got " + (JSON.stringify(option.source))));
          }
          return fs.readFile(option.source, function(err, content) {
            if (err) {
              return next(err);
            }
            option.content = content;
            return writeContent();
          });
        });
      };
      writeContent = function() {
        var content;
        try {
          content = eco.render(option.content.toString(), option.context || {});
        } catch (err) {
          return next(err);
        }
        return fs.writeFile(option.destination, content, function(err) {
          if (err) {
            return next(err);
          }
          rendered++;
          return next();
        });
      };
      return readSource();
    }).on('both', function(err) {
      return callback(err, rendered);
    });
  }
};

mecano.cp = mecano.copy;

mecano.exec = mecano.execute;

mecano.ln = mecano.link;

mecano.rm = mecano.remove;
