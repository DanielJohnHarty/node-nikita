// Generated by CoffeeScript 1.6.3
var EventEmitter, Ftp, child, conditions, curl, each, eco, exec, fs, ldap, ldap_client, mecano, misc, path, request, url, util;

fs = require('fs');

path = require('path');

url = require('url');

util = require('util');

each = require('each');

eco = require('eco');

exec = require('superexec');

request = require('request');

Ftp = require('jsftp');

ldap = require('ldapjs');

ldap_client = require('ldapjs/lib/client/client');

EventEmitter = require('events').EventEmitter;

conditions = require('./conditions');

misc = require('./misc');

child = require('./child');

curl = require('./curl');

mecano = module.exports = {
  chmod: function(goptions, options, callback) {
    var finish, result;
    if (arguments.length === 2) {
      callback = options;
      options = goptions;
      goptions = {
        parallel: true
      };
    }
    result = child(mecano);
    finish = function(err, modified) {
      if (callback) {
        callback(err, modified);
      }
      return result.end(err, modified);
    };
    return misc.options(options, function(err, options) {
      var modified;
      if (err) {
        return finish(err);
      }
      modified = 0;
      return each(options).parallel(goptions.parallel).on('item', function(options, next) {
        var destination, mode, ssh;
        ssh = options.ssh, destination = options.destination, mode = options.mode;
        if (!destination) {
          return next(new Error("Missing destination: " + destination));
        }
        if (typeof options.log === "function") {
          options.log("Stat " + destination);
        }
        return misc.file.stat(ssh, destination, function(err, stat) {
          if (err) {
            return next(err);
          }
          if (misc.file.cmpmod(stat.mode, mode)) {
            return next();
          }
          if (typeof options.log === "function") {
            options.log("Change mode to " + mode);
          }
          return misc.file.chmod(ssh, destination, mode, function(err) {
            if (err) {
              return next(err);
            }
            modified++;
            return next();
          });
        });
      }).on('both', function(err) {
        return finish(err, modified);
      });
    });
  },
  chown: function(goptions, options, callback) {
    var finish, result;
    if (arguments.length === 2) {
      callback = options;
      options = goptions;
      goptions = {
        parallel: true
      };
    }
    result = child(mecano);
    finish = function(err, modified) {
      if (callback) {
        callback(err, modified);
      }
      return result.end(err, modified);
    };
    return misc.options(options, function(err, options) {
      var modified;
      if (err) {
        return finish(err);
      }
      modified = 0;
      return each(options).parallel(goptions.parallel).on('item', function(options, next) {
        var destination, gid, ssh, uid;
        ssh = options.ssh, destination = options.destination, uid = options.uid, gid = options.gid;
        if (!destination) {
          return next(new Error("Missing destination: " + destination));
        }
        if (!(uid && gid)) {
          return next();
        }
        if (typeof options.log === "function") {
          options.log("Stat " + destination);
        }
        return misc.file.stat(ssh, destination, function(err, stat) {
          if (err) {
            return next(err);
          }
          if (stat.uid === uid && stat.gid === gid) {
            return next();
          }
          if (stat.uid !== uid) {
            if (typeof options.log === "function") {
              options.log("Change uid from " + stat.uid + " to " + uid);
            }
          }
          if (stat.gid !== gid) {
            if (typeof options.log === "function") {
              options.log("Change gid from " + stat.gid + " to " + gid);
            }
          }
          return misc.file.chown(ssh, destination, uid, gid, function(err) {
            if (err) {
              return next()(err);
            }
            modified++;
            return next();
          });
        });
      }).on('both', function(err) {
        return finish(err, modified);
      });
    });
  },
  copy: function(goptions, options, callback) {
    if (arguments.length === 2) {
      callback = options;
      options = goptions;
      goptions = {
        parallel: true
      };
    }
    return misc.options(options, function(err, options) {
      var copied;
      if (err) {
        return callback(err);
      }
      copied = 0;
      return each(options).parallel(goptions.parallel).on('item', function(options, next) {
        if (!options.source) {
          return next(new Error('Missing source'));
        }
        if (!options.destination) {
          return next(new Error('Missing destination'));
        }
        if (options.not_if_exists === true) {
          options.not_if_exists = options.destination;
        }
        return conditions.all(options, next, function() {
          var copy, directory, dstStat, modified, srcStat;
          modified = false;
          srcStat = null;
          dstStat = null;
          if (typeof options.log === "function") {
            options.log("Stat source file");
          }
          misc.file.stat(options.ssh, options.source, function(err, stat) {
            if (err) {
              return next(err);
            }
            srcStat = stat;
            if (typeof options.log === "function") {
              options.log("Stat destination file");
            }
            return misc.file.stat(options.ssh, options.destination, function(err, stat) {
              var sourceEndWithSlash;
              if (err && err.code !== 'ENOENT') {
                return next(err);
              }
              dstStat = stat;
              sourceEndWithSlash = options.source.lastIndexOf('/') === options.source.length - 1;
              if (srcStat.isDirectory() && dstStat && !sourceEndWithSlash) {
                options.destination = path.resolve(options.destination, path.basename(options.source));
              }
              if (srcStat.isDirectory()) {
                return directory(options.source, next);
              } else {
                return copy(options.source, next);
              }
            });
          });
          directory = function(dir, callback) {
            if (typeof options.log === "function") {
              options.log("Source is a directory");
            }
            return each().files("" + dir + "/**").on('item', function(file, next) {
              return copy(file, next);
            }).on('both', callback);
          };
          return copy = function(source, callback) {
            var destination, do_chmod, do_chown, do_copy_dir, do_copy_file, do_end;
            if (srcStat.isDirectory()) {
              destination = path.resolve(options.destination, path.relative(options.source, source));
            } else if (!srcStat.isDirectory() && (dstStat != null ? dstStat.isDirectory() : void 0)) {
              destination = path.resolve(options.destination, path.basename(source));
            } else {
              destination = options.destination;
            }
            misc.file.stat(options.ssh, source, function(err, stat) {
              if (err) {
                return callback(err);
              }
              if (stat.isDirectory()) {
                return do_copy_dir(source, destination);
              } else {
                return do_copy_file(source, destination);
              }
            });
            do_copy_dir = function(source, destination) {
              if (source === options.source) {
                return callback();
              }
              if (typeof options.log === "function") {
                options.log("Create directory " + destination);
              }
              return misc.file.mkdir(options.ssh, destination, function(err) {
                if ((err != null ? err.code : void 0) === 'EEXIST') {
                  return callback();
                }
                if (err) {
                  return callback(err);
                }
                modified = true;
                return do_end();
              });
            };
            do_copy_file = function(source, destination) {
              return misc.file.compare(options.ssh, [source, destination], function(err, md5) {
                var s;
                if (err && err.message.indexOf('Does not exist') !== 0) {
                  return callback(err);
                }
                if (md5) {
                  return do_chown(destination);
                }
                s = function(ssh, callback) {
                  if (!ssh) {
                    return callback(null, fs);
                  } else {
                    return options.ssh.sftp(callback);
                  }
                };
                return s(options.ssh, function(err, fs) {
                  var rs, ws;
                  if (typeof options.log === "function") {
                    options.log("Copy file from " + source + " into " + destination);
                  }
                  rs = fs.createReadStream(source);
                  ws = rs.pipe(fs.createWriteStream(destination));
                  ws.on('close', function() {
                    if (fs.end) {
                      fs.end();
                    }
                    modified = true;
                    return do_chown(destination);
                  });
                  return ws.on('error', callback);
                });
              });
            };
            do_chown = function(destination) {
              if (!options.uid && !options.gid) {
                return do_chmod();
              }
              return mecano.chown({
                ssh: options.ssh,
                log: options.log,
                destination: destination,
                uid: options.uid,
                gid: options.gid
              }, function(err, chowned) {
                if (err) {
                  return callback(err);
                }
                if (chowned) {
                  modified = chowned;
                }
                return do_chmod();
              });
            };
            do_chmod = function(destination) {
              if (!options.mode) {
                return do_end();
              }
              return mecano.chmod({
                ssh: options.ssh,
                log: options.log,
                destination: options.destination,
                mode: options.mode
              }, function(err, chmoded) {
                if (err) {
                  return callback(err);
                }
                if (chmoded) {
                  modified = chmoded;
                }
                return do_end();
              });
            };
            return do_end = function() {
              if (modified) {
                copied++;
              }
              return callback();
            };
          };
        });
      }).on('both', function(err) {
        return callback(err, copied);
      });
    });
  },
  download: function(goptions, options, callback) {
    var finish, result;
    if (arguments.length === 2) {
      callback = options;
      options = goptions;
      goptions = {
        parallel: true
      };
    }
    result = child(mecano);
    finish = function(err, downloaded) {
      if (callback) {
        callback(err, downloaded);
      }
      return result.end(err, downloaded);
    };
    return misc.options(options, function(err, options) {
      var downloaded;
      if (err) {
        return finish(err);
      }
      downloaded = 0;
      return each(options).parallel(goptions.parallel).on('item', function(options, next) {
        var checksum, destination, download, md5sum, prepare, source, stageDestination, unstage;
        destination = options.destination, source = options.source, md5sum = options.md5sum;
        if (!source) {
          return next(new Error("Missing source: " + source));
        }
        if (!destination) {
          return next(new Error("Missing destination: " + destination));
        }
        if (options.force == null) {
          options.force = false;
        }
        stageDestination = "" + destination + "." + (Date.now()) + (Math.round(Math.random() * 1000));
        prepare = function() {
          if (typeof options.log === "function") {
            options.log("Check if destination exists");
          }
          return misc.file.exists(options.ssh, destination, function(err, exists) {
            if (options.force) {
              return download();
            } else if (exists && md5sum) {
              return misc.file.hash(options.ssh, destination, 'md5', function(err, hash) {
                if (err) {
                  return next(err);
                }
                if (hash === md5sum) {
                  return next();
                }
                return misc.file.unlink(options.ssh, destination, function(err) {
                  if (err) {
                    return next(err);
                  }
                  return download();
                });
              });
            } else if (exists) {
              return download();
            } else {
              return download();
            }
          });
        };
        download = function() {
          var cmd, ftp, pass, rs, u, user, ws, _ref;
          if (typeof options.log === "function") {
            options.log("Download the source");
          }
          u = url.parse(source);
          if (options.ssh) {
            if (u.protocol === 'http:') {
              cmd = "curl " + source + " -o " + stageDestination;
              cmd += " -s";
              if (options.proxy) {
                cmd += " -x " + options.proxy;
              }
              return mecano.execute({
                ssh: options.ssh,
                cmd: cmd,
                log: options.log,
                stdout: options.stdout,
                stderr: options.stderr
              }, function(err, executed, stdout, stderr) {
                if (err) {
                  return next(curl.error(err));
                }
                return checksum();
              });
            } else if (u.protocol === 'ftp:') {
              return next(new Error('FTP download not supported over SSH'));
            } else {
              return options.ssh.sftp(function(err, sftp) {
                var rs, ws;
                if (err) {
                  return next(err);
                }
                rs = sftp.createReadStream(u.pathname);
                ws = rs.pipe(fs.createWriteStream(stageDestination));
                ws.on('close', function() {
                  return checksum();
                });
                return ws.on('error', next);
              });
            }
          } else {
            ws = fs.createWriteStream(stageDestination);
            if (u.protocol === 'http:') {
              options.url = source;
              request(options).pipe(ws);
            } else if (u.protocol === 'ftp:') {
              if (options.host == null) {
                options.host = u.hostname;
              }
              if (options.port == null) {
                options.port = u.port;
              }
              if (u.auth) {
                _ref = u.auth.split(':'), user = _ref.user, pass = _ref.pass;
              }
              if (options.user == null) {
                options.user = user;
              }
              if (options.pass == null) {
                options.pass = pass;
              }
              ftp = new Ftp(options);
              ftp.getGetSocket(u.pathname, function(err, rs) {
                if (err) {
                  return next(err);
                }
                rs.pipe(ws);
                return rs.resume();
              });
            } else {
              rs = fs.createReadStream(u.pathname);
              rs.pipe(ws);
            }
            ws.on('close', function() {
              return checksum();
            });
            return ws.on('error', function(err) {
              return mecano.remove(ws, function(err) {
                return next(err);
              });
            });
          }
        };
        checksum = function() {
          if (!md5sum) {
            return unstage();
          }
          if (typeof options.log === "function") {
            options.log("Compare the downloaded file with the user-provided checksum");
          }
          return misc.file.hash(options.ssh, stageDestination, 'md5', function(err, hash) {
            if (hash === md5sum) {
              return unstage();
            }
            return misc.file.remove(options.ssh, stageDestination, function(err) {
              if (err) {
                return next(err);
              }
              return next(new Error("Invalid checksum, found \"" + hash + "\" instead of \"" + md5sum + "\""));
            });
          });
        };
        unstage = function() {
          if (typeof options.log === "function") {
            options.log("Move the downloaded file");
          }
          return mecano.move({
            ssh: options.ssh,
            source: stageDestination,
            destination: destination,
            source_md5: md5sum
          }, function(err, moved) {
            if (err) {
              return next(err);
            }
            if (moved) {
              downloaded++;
            }
            return next();
          });
        };
        return prepare();
      }).on('both', function(err) {
        return finish(err, downloaded);
      });
    });
  },
  execute: function(goptions, options, callback) {
    var finish, isArray, result;
    if (arguments.length === 2) {
      callback = options;
      options = goptions;
      goptions = {
        parallel: true
      };
    }
    result = child(mecano);
    finish = function(err, created, stdout, stderr) {
      if (callback) {
        callback(err, created, stdout, stderr);
      }
      return result.end(err, created);
    };
    isArray = Array.isArray(options);
    misc.options(options, function(err, options) {
      var escape, executed, stderrs, stdouts, stds;
      if (err) {
        return finish(err);
      }
      executed = 0;
      stdouts = [];
      stderrs = [];
      escape = function(cmd) {
        var char, esccmd, _i, _len;
        esccmd = '';
        for (_i = 0, _len = cmd.length; _i < _len; _i++) {
          char = cmd[_i];
          if (char === '$') {
            esccmd += '\\';
          }
          esccmd += char;
        }
        return esccmd;
      };
      stds = callback ? callback.length > 2 : false;
      return each(options).parallel(goptions.parallel).on('item', function(options, i, next) {
        var cmd;
        if (typeof options === 'string') {
          options = {
            cmd: options
          };
        }
        if (options.cmd == null) {
          return next(new Error("Missing cmd: " + options.cmd));
        }
        if (options.code == null) {
          options.code = [0];
        }
        if (!Array.isArray(options.code)) {
          options.code = [options.code];
        }
        if (options.code_skipped == null) {
          options.code_skipped = [];
        }
        if (!Array.isArray(options.code_skipped)) {
          options.code_skipped = [options.code_skipped];
        }
        cmd = function() {
          var run, stderr, stdout;
          if (typeof options.log === "function") {
            options.log("Execute: " + options.cmd);
          }
          run = exec(options);
          stdout = stderr = [];
          if (options.stdout) {
            run.stdout.pipe(options.stdout, {
              end: false
            });
          }
          if (stds) {
            run.stdout.on('data', function(data) {
              return stdout.push(data);
            });
          }
          if (options.stderr) {
            run.stderr.pipe(options.stderr, {
              end: false
            });
          }
          if (stds) {
            run.stderr.on('data', function(data) {
              return stderr.push(data);
            });
          }
          return run.on("exit", function(code) {
            return setTimeout(function() {
              stdouts.push(stds ? stdout.join('') : void 0);
              stderrs.push(stds ? stderr.join('') : void 0);
              if (options.stdout) {
                run.stdout.unpipe(options.stdout);
              }
              if (options.stderr) {
                run.stderr.unpipe(options.stderr);
              }
              if (options.code.indexOf(code) === -1 && options.code_skipped.indexOf(code) === -1) {
                err = new Error("Invalid exec code " + code);
                err.code = code;
                return next(err);
              }
              if (options.code_skipped.indexOf(code) === -1) {
                executed++;
              }
              return next();
            }, 1);
          });
        };
        return conditions.all(options, next, cmd);
      }).on('both', function(err) {
        if (!isArray) {
          stdouts = stdouts[0];
        }
        if (!isArray) {
          stderrs = stderrs[0];
        }
        return finish(err, executed, stdouts, stderrs);
      });
    });
    return result;
  },
  extract: function(goptions, options, callback) {
    if (arguments.length === 2) {
      callback = options;
      options = goptions;
      goptions = {
        parallel: true
      };
    }
    return misc.options(options, function(err, options) {
      var extracted;
      if (err) {
        return callback(err);
      }
      extracted = 0;
      return each(options).parallel(goptions.parallel).on('item', function(options, next) {
        var creates, destination, ext, extract, format, success, _ref;
        if (!options.source) {
          return next(new Error("Missing source: " + options.source));
        }
        destination = (_ref = options.destination) != null ? _ref : path.dirname(options.source);
        if (options.format != null) {
          format = options.format;
        } else {
          if (/\.(tar\.gz|tgz)$/.test(options.source)) {
            format = 'tgz';
          } else if (/\.zip$/.test(options.source)) {
            format = 'zip';
          } else {
            ext = path.extname(options.source);
            return next(new Error("Unsupported extension, got " + (JSON.stringify(ext))));
          }
        }
        extract = function() {
          var cmd;
          cmd = null;
          switch (format) {
            case 'tgz':
              cmd = "tar xzf " + options.source + " -C " + destination;
              break;
            case 'zip':
              cmd = "unzip -u " + options.source + " -d " + destination;
          }
          options.cmd = cmd;
          return exec(options, function(err, stdout, stderr) {
            if (err) {
              return next(err);
            }
            return creates();
          });
        };
        creates = function() {
          if (options.creates == null) {
            return success();
          }
          return misc.file.exists(options.ssh, options.creates, function(err, exists) {
            if (!exists) {
              return next(new Error("Failed to create '" + (path.basename(options.creates)) + "'"));
            }
            return success();
          });
        };
        success = function() {
          extracted++;
          return next();
        };
        if (typeof options.should_exist === 'undefined') {
          options.should_exist = options.source;
        }
        return conditions.all(options, next, extract);
      }).on('both', function(err) {
        return callback(err, extracted);
      });
    });
  },
  git: function(goptions, options, callback) {
    if (arguments.length === 2) {
      callback = options;
      options = goptions;
      goptions = {
        parallel: true
      };
    }
    return misc.options(options, function(err, options) {
      var updated;
      if (err) {
        return callback(err);
      }
      updated = 0;
      return each(options).parallel(goptions.parallel).on('item', function(options, next) {
        var checkout, clone, log, prepare, rev;
        if (options.revision == null) {
          options.revision = 'HEAD';
        }
        rev = null;
        prepare = function() {
          return misc.file.exists(options.ssh, options.destination, function(err, exists) {
            var gitDir;
            if (err) {
              return next(err);
            }
            if (!exists) {
              return clone();
            }
            gitDir = "" + options.destination + "/.git";
            return misc.file.exists(options.ssh, gitDir, function(err, exists) {
              if (!exists) {
                return next(new Error("Not a git repository"));
              }
              return log();
            });
          });
        };
        clone = function() {
          return mecano.exec({
            ssh: options.ssh,
            cmd: "git clone " + options.source + " " + options.destination,
            cwd: path.dirname(options.destination),
            log: options.log,
            stdout: options.stdout,
            stderr: options.stderr
          }, function(err, executed, stdout, stderr) {
            if (err) {
              return next(err);
            }
            return checkout();
          });
        };
        log = function() {
          return mecano.exec({
            ssh: options.ssh,
            cmd: "git log --pretty=format:'%H' -n 1",
            cwd: options.destination,
            log: options.log,
            stdout: options.stdout,
            stderr: options.stderr
          }, function(err, executed, stdout, stderr) {
            var current;
            if (err) {
              return next(err);
            }
            current = stdout.trim();
            return mecano.exec({
              ssh: options.ssh,
              cmd: "git rev-list --max-count=1 " + options.revision,
              cwd: options.destination,
              log: options.log,
              stdout: options.stdout,
              stderr: options.stderr
            }, function(err, executed, stdout, stderr) {
              if (err) {
                return next(err);
              }
              if (stdout.trim() !== current) {
                return checkout();
              } else {
                return next();
              }
            });
          });
        };
        checkout = function() {
          return mecano.exec({
            ssh: options.ssh,
            cmd: "git checkout " + options.revision,
            cwd: options.destination,
            log: options.log,
            stdout: options.stdout,
            stderr: options.stderr
          }, function(err) {
            if (err) {
              return next(err);
            }
            updated++;
            return next();
          });
        };
        return conditions.all(options, next, prepare);
      }).on('both', function(err) {
        return callback(err, updated);
      });
    });
  },
  ini: function(goptions, options, callback) {
    var clean, finish, result;
    if (arguments.length === 2) {
      callback = options;
      options = goptions;
      goptions = {
        parallel: true
      };
    }
    clean = function(content, undefinedOnly) {
      var k, v;
      for (k in content) {
        v = content[k];
        if (v && typeof v === 'object') {
          content[k] = clean(v, undefinedOnly);
          continue;
        }
        if (typeof v === 'undefined') {
          delete content[k];
        }
        if (!undefinedOnly && v === null) {
          delete content[k];
        }
      }
      return content;
    };
    result = child(mecano);
    finish = function(err, written) {
      if (callback) {
        callback(err, written);
      }
      return result.end(err, written);
    };
    misc.options(options, function(err, options) {
      var written;
      if (err) {
        return finish(err);
      }
      written = 0;
      return each(options).parallel(goptions.parallel).on('item', function(options, next) {
        var content, destination, get, merge, ssh, write;
        merge = options.merge, destination = options.destination, content = options.content, ssh = options.ssh;
        if (!content) {
          return next(new Error('Missing content'));
        }
        if (!destination) {
          return next(new Error('Missing destination'));
        }
        get = function() {
          if (!merge) {
            return write();
          }
          return misc.file.exists(ssh, destination, function(err, exists) {
            if (err) {
              return next(err);
            }
            if (!exists) {
              return write();
            }
            return misc.file.readFile(ssh, destination, 'ascii', function(err, c) {
              var parse;
              if (err && err.code !== 'ENOENT') {
                return next(err);
              }
              content = clean(content, true);
              parse = options.parse || misc.ini.parse;
              content = misc.merge(parse(c), content);
              return write();
            });
          });
        };
        write = function() {
          var stringify;
          clean(content);
          stringify = options.stringify || misc.ini.stringify;
          options.content = stringify(content, options);
          return mecano.write(options, function(err, w) {
            written += w;
            return next(err);
          });
        };
        return get();
      }).on('both', function(err) {
        return finish(err, written);
      });
    });
    return result;
  },
  krb5_ktadd: function(goptions, options, callback) {
    if (arguments.length === 2) {
      callback = options;
      options = goptions;
      goptions = {
        parallel: true
      };
    }
    return misc.options(options, function(err, options) {
      var executed;
      if (err) {
        return callback(err);
      }
      executed = 0;
      return each(options).parallel(goptions.parallel).on('item', function(options, next) {
        var do_chmod, do_chown, do_end, do_get, do_ktadd, modified;
        modified = false;
        do_get = function() {
          if (!options.keytab) {
            return do_end();
          }
          return mecano.execute({
            cmd: "klist -k " + options.keytab,
            ssh: options.ssh,
            log: options.log,
            stdout: options.stdout,
            stderr: options.stderr,
            code_skipped: 1
          }, function(err, exists, stdout, stderr) {
            var keytab, kvno, line, match, principal, _, _i, _len, _ref;
            if (err) {
              return next(err);
            }
            if (!exists) {
              return do_ktadd();
            }
            keytab = {};
            _ref = stdout.split('\n');
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              line = _ref[_i];
              if (match = /^\s*(\d+)\s*(.*)\s*$/.exec(line)) {
                _ = match[0], kvno = match[1], principal = match[2];
                keytab[principal] = kvno;
              }
            }
            if (keytab[options.principal] == null) {
              return do_ktadd();
            }
            return mecano.execute({
              cmd: misc.kadmin(options, "getprinc " + options.principal),
              ssh: options.ssh,
              log: options.log,
              stdout: options.stdout,
              stderr: options.stderr
            }, function(err, exists, stdout, stderr) {
              var vno, _j, _len1, _ref1;
              if (err) {
                return err;
              }
              if (-1 !== stdout.indexOf('does not exist')) {
                return do_ktadd();
              }
              vno = null;
              _ref1 = stdout.split('\n');
              for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
                line = _ref1[_j];
                if (match = /Key: vno (\d+)/.exec(line)) {
                  _ = match[0], vno = match[1];
                  break;
                }
              }
              if (keytab[principal] === vno) {
                return do_chown();
              }
              return do_ktadd();
            });
          });
        };
        do_ktadd = function() {
          return mecano.execute({
            cmd: misc.kadmin(options, "ktadd -k " + options.keytab + " " + options.principal),
            ssh: options.ssh,
            log: options.log,
            stdout: options.stdout,
            stderr: options.stderr
          }, function(err, ktadded) {
            if (err) {
              return next(err);
            }
            modified = true;
            return do_chown();
          });
        };
        do_chown = function() {
          if (!options.keytab || (!options.uid && !options.gid)) {
            return do_chmod();
          }
          return mecano.chown({
            ssh: options.ssh,
            log: options.log,
            destination: options.keytab,
            uid: options.uid,
            gid: options.gid
          }, function(err, chowned) {
            if (err) {
              return next(err);
            }
            if (chowned) {
              modified = chowned;
            }
            return do_chmod();
          });
        };
        do_chmod = function() {
          if (!options.keytab || !options.mode) {
            return do_end();
          }
          return mecano.chmod({
            ssh: options.ssh,
            log: options.log,
            destination: options.keytab,
            mode: options.mode
          }, function(err, chmoded) {
            if (err) {
              return next(err);
            }
            if (chmoded) {
              modified = chmoded;
            }
            return do_end();
          });
        };
        do_end = function() {
          if (modified) {
            executed++;
          }
          return next();
        };
        return conditions.all(options, next, do_get);
      }).on('both', function(err) {
        return callback(err, executed);
      });
    });
  },
  krb5_addprinc: function(goptions, options, callback) {
    if (arguments.length === 2) {
      callback = options;
      options = goptions;
      goptions = {
        parallel: true
      };
    }
    return misc.options(options, function(err, options) {
      var executed;
      if (err) {
        return callback(err);
      }
      executed = 0;
      return each(options).parallel(goptions.parallel).on('item', function(options, next) {
        var do_end, do_kadmin, do_keytab, modified;
        if (!options.principal) {
          return next(new Error('Property principal is required'));
        }
        if (!options.password && !options.randkey) {
          return next(new Error('Password or randkey missing'));
        }
        modified = false;
        do_kadmin = function() {
          var cmd;
          cmd = misc.kadmin(options, options.password ? "addprinc -pw " + options.password + " " + options.principal : "addprinc -randkey " + options.principal);
          return mecano.execute({
            cmd: cmd,
            ssh: options.ssh,
            log: options.log,
            stdout: options.stdout,
            stderr: options.stderr
          }, function(err, _, stdout) {
            if (err) {
              return next(err);
            }
            if (-1 === stdout.indexOf('already exists')) {
              modified = true;
            }
            return do_keytab();
          });
        };
        do_keytab = function() {
          return mecano.krb5_ktadd(options, function(err, ktadded) {
            if (ktadded) {
              modified = true;
            }
            return do_end();
          });
        };
        do_end = function() {
          if (modified) {
            executed++;
          }
          return next();
        };
        return conditions.all(options, next, do_kadmin);
      }).on('both', function(err) {
        return callback(err, executed);
      });
    });
  },
  krb5_delprinc: function(goptions, options, callback) {
    if (arguments.length === 2) {
      callback = options;
      options = goptions;
      goptions = {
        parallel: true
      };
    }
    return misc.options(options, function(err, options) {
      var executed;
      if (err) {
        return callback(err);
      }
      executed = 0;
      return each(options).parallel(goptions.parallel).on('item', function(options, next) {
        var do_delprinc, do_end, do_keytab, modified;
        if (!options.principal) {
          return next(new Error('Property principal is required'));
        }
        modified = true;
        do_delprinc = function() {
          return mecano.execute({
            cmd: misc.kadmin(options, "delprinc -force " + options.principal),
            ssh: options.ssh,
            log: options.log,
            stdout: options.stdout,
            stderr: options.stderr
          }, function(err, _, stdout) {
            if (err) {
              return next(err);
            }
            if (-1 === stdout.indexOf('does not exist')) {
              modified = true;
            }
            return do_keytab();
          });
        };
        do_keytab = function() {
          if (!options.keytab) {
            return do_end();
          }
          return mecano.remove({
            ssh: options.ssh,
            destination: options.keytab
          }, function(err, removed) {
            if (err) {
              return next(err);
            }
            if (removed) {
              modified++;
            }
            return do_end();
          });
        };
        do_end = function() {
          if (modified) {
            executed++;
          }
          return next();
        };
        return conditions.all(options, next, do_delprinc);
      }).on('both', function(err) {
        return callback(err, executed);
      });
    });
  },
  ldap_acl: function(goptions, options, callback) {
    var finish, result;
    if (arguments.length === 2) {
      callback = options;
      options = goptions;
      goptions = {
        parallel: true
      };
    }
    result = child(mecano);
    finish = function(err, modified) {
      if (callback) {
        callback(err, modified);
      }
      return result.end(err, modified);
    };
    misc.options(options, function(err, options) {
      var modified;
      if (err) {
        return finish(err);
      }
      modified = 0;
      return each(options).parallel(goptions.parallel).on('item', function(options, next) {
        if (options.acls == null) {
          options.acls = [{}];
        }
        return conditions.all(options, next, function() {
          var updated;
          updated = false;
          return each(options.acls).parallel(false).on('item', function(acl, next) {
            var b, client, connect, diff, end, i, parse, save, search, stringify, unbind, _i, _len, _ref;
            if (acl.before == null) {
              acl.before = options.before;
            }
            if (acl.to == null) {
              acl.to = options.to;
            }
            if (acl.by == null) {
              acl.by = options.by;
            }
            client = null;
            acl.to = acl.to.trim();
            _ref = acl.by;
            for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
              b = _ref[i];
              acl.by[i] = b.trim();
            }
            connect = function() {
              if (options.ldap instanceof ldap_client) {
                client = options.ldap;
                return search();
              }
              if (typeof options.log === "function") {
                options.log('Open and bind connection');
              }
              client = ldap.createClient({
                url: options.url
              });
              return client.bind(options.binddn, options.passwd, function(err) {
                if (err) {
                  return end(err);
                }
                return search();
              });
            };
            search = function() {
              if (typeof options.log === "function") {
                options.log('Search attribute olcAccess');
              }
              return client.search(options.name, {
                scope: 'base',
                attributes: ['olcAccess']
              }, function(err, search) {
                var olcAccess;
                if (err) {
                  return unbind(err);
                }
                olcAccess = null;
                search.on('searchEntry', function(entry) {
                  if (typeof options.log === "function") {
                    options.log("Found " + (JSON.stringify(entry.object)));
                  }
                  olcAccess = entry.object.olcAccess || [];
                  if (!Array.isArray(olcAccess)) {
                    return olcAccess = [olcAccess];
                  }
                });
                return search.on('end', function() {
                  if (typeof options.log === "function") {
                    options.log("Attribute olcAccess was " + (JSON.stringify(olcAccess)));
                  }
                  return parse(olcAccess);
                });
              });
            };
            parse = function(_olcAccess) {
              var access, buf, buftype, bys, c, matches, olcAccess, to, _j, _k, _len1, _len2;
              olcAccess = [];
              for (i = _j = 0, _len1 = _olcAccess.length; _j < _len1; i = ++_j) {
                access = _olcAccess[i];
                to = '';
                bys = [];
                buftype = 0;
                buf = '';
                for (i = _k = 0, _len2 = access.length; _k < _len2; i = ++_k) {
                  c = access[i];
                  buf += c;
                  if (buftype === 0) {
                    if (/to$/.test(buf)) {
                      buf = '';
                      buftype = 1;
                    }
                  }
                  if (buftype === 1) {
                    if (matches = /^(.*)by$/.exec(buf)) {
                      to = matches[1].trim();
                      buf = '';
                      buftype = 2;
                    }
                  }
                  if (buftype === 2) {
                    if (matches = /^(.*)by$/.exec(buf)) {
                      bys.push(matches[1].trim());
                      buf = '';
                    } else if (i + 1 === access.length) {
                      bys.push(buf.trim());
                    }
                  }
                }
                olcAccess.push({
                  to: to,
                  by: bys
                });
              }
              return diff(olcAccess);
            };
            diff = function(olcAccess) {
              var aby, access, fby, found, oby, toAlreadyExist, _j, _k, _l, _len1, _len2, _len3, _len4, _len5, _m, _n, _ref1, _ref2;
              toAlreadyExist = false;
              for (i = _j = 0, _len1 = olcAccess.length; _j < _len1; i = ++_j) {
                access = olcAccess[i];
                if (acl.to !== access.to) {
                  continue;
                }
                toAlreadyExist = true;
                fby = !options.overwrite ? access.by : [];
                _ref1 = acl.by;
                for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
                  oby = _ref1[_k];
                  found = false;
                  _ref2 = access.by;
                  for (_l = 0, _len3 = _ref2.length; _l < _len3; _l++) {
                    aby = _ref2[_l];
                    if (oby === aby) {
                      found = true;
                      break;
                    }
                  }
                  if (!found) {
                    updated = true;
                    fby.push(oby);
                  }
                }
                olcAccess[i].by = fby;
              }
              if (!toAlreadyExist) {
                updated = true;
                if (acl.before) {
                  found = null;
                  for (i = _m = 0, _len4 = olcAccess.length; _m < _len4; i = ++_m) {
                    access = olcAccess[i];
                    if (access.to === acl.before) {
                      found = i;
                    }
                  }
                  olcAccess.splice(found - 1, 0, {
                    to: acl.to,
                    by: acl.by
                  });
                } else if (acl.after) {
                  found = false;
                  for (i = _n = 0, _len5 = olcAccess.length; _n < _len5; i = ++_n) {
                    access = olcAccess[i];
                    if (access.to === options.after) {
                      found = i;
                    }
                  }
                  olcAccess.splice(found, 0, {
                    to: acl.to,
                    by: acl.by
                  });
                } else {
                  olcAccess.push({
                    to: acl.to,
                    by: acl.by
                  });
                }
              }
              if (updated) {
                return stringify(olcAccess);
              } else {
                return unbind();
              }
            };
            stringify = function(olcAccess) {
              var access, bie, value, _j, _k, _len1, _len2, _ref1;
              for (i = _j = 0, _len1 = olcAccess.length; _j < _len1; i = ++_j) {
                access = olcAccess[i];
                value = "{" + i + "}to " + access.to;
                _ref1 = access.by;
                for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
                  bie = _ref1[_k];
                  value += " by " + bie;
                }
                olcAccess[i] = value;
              }
              return save(olcAccess);
            };
            save = function(olcAccess) {
              var change;
              change = new ldap.Change({
                operation: 'replace',
                modification: {
                  olcAccess: olcAccess
                }
              });
              return client.modify(options.name, change, function(err) {
                return unbind(err);
              });
            };
            unbind = function(err) {
              if (typeof options.log === "function") {
                options.log('Unbind connection');
              }
              if (options.ldap instanceof ldap_client && !options.unbind) {
                return end(err);
              }
              return client.unbind(function(e) {
                if (e) {
                  return next(e);
                }
                return end(err);
              });
            };
            end = function(err) {
              return next(err);
            };
            return connect();
          }).on('both', function(err) {
            if (updated && !err) {
              modified += 1;
            }
            return finish(err, modified);
          });
        });
      }).on('both', function(err) {
        return finish(err, modified);
      });
    });
    return result;
  },
  ldap_index: function(goptions, options, callback) {
    var finish, result;
    if (arguments.length === 2) {
      callback = options;
      options = goptions;
      goptions = {
        parallel: true
      };
    }
    result = child(mecano);
    finish = function(err, created) {
      if (callback) {
        callback(err, created);
      }
      return result.end(err, created);
    };
    misc.options(options, function(err, options) {
      var modified;
      if (err) {
        return finish(err);
      }
      modified = 0;
      return each(options).parallel(goptions.parallel).on('item', function(options, next) {
        var client, connect, diff, end, get, parse, replace, stringifiy, unbind, updated;
        client = null;
        updated = false;
        connect = function() {
          if (options.ldap instanceof ldap_client) {
            client = options.ldap;
            return get();
          }
          client = ldap.createClient({
            url: options.url
          });
          return client.bind(options.binddn, options.passwd, function(err) {
            if (err) {
              return end(err);
            }
            return get();
          });
        };
        get = function() {
          return client.search('olcDatabase={2}bdb,cn=config', {
            scope: 'base',
            attributes: ['olcDbIndex']
          }, function(err, search) {
            var olcDbIndex;
            olcDbIndex = null;
            search.on('searchEntry', function(entry) {
              return olcDbIndex = entry.object.olcDbIndex;
            });
            return search.on('end', function() {
              return parse(olcDbIndex);
            });
          });
        };
        parse = function(arIndex) {
          var index, indexes, k, v, _i, _len, _ref;
          indexes = {};
          for (_i = 0, _len = arIndex.length; _i < _len; _i++) {
            index = arIndex[_i];
            _ref = index.split(' '), k = _ref[0], v = _ref[1];
            indexes[k] = v;
          }
          return diff(indexes);
        };
        diff = function(orgp) {
          var i, newp, nkl, okl, _i, _ref;
          if (!options.overwrite) {
            newp = misc.merge({}, orgp, options.indexes);
          } else {
            newp = options.indexes;
          }
          okl = Object.keys(orgp).sort();
          nkl = Object.keys(newp).sort();
          for (i = _i = 0, _ref = Math.min(okl.length, nkl.length); 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
            if (i === okl.length || i === nkl.length || okl[i] !== nkl[i] || orgp[okl[i]] !== newp[nkl[i]]) {
              updated = true;
              break;
            }
          }
          if (updated) {
            return stringifiy(newp);
          } else {
            return unbind();
          }
        };
        stringifiy = function(perms) {
          var indexes, k, v;
          indexes = [];
          for (k in perms) {
            v = perms[k];
            indexes.push("" + k + " " + v);
          }
          return replace(indexes);
        };
        replace = function(indexes) {
          var change;
          change = new ldap.Change({
            operation: 'replace',
            modification: {
              olcDbIndex: indexes
            }
          });
          return client.modify(options.name, change, function(err) {
            return unbind(err);
          });
        };
        unbind = function(err) {
          if (options.ldap instanceof ldap_client && !options.unbind) {
            return end(err);
          }
          return client.unbind(function(e) {
            if (e) {
              return next(e);
            }
            return end(err);
          });
        };
        end = function(err) {
          if (updated && !err) {
            modified += 1;
          }
          return next(err);
        };
        return conditions.all(options, next, connect);
      }).on('both', function(err) {
        return finish(err, modified);
      });
    });
    return result;
  },
  ldap_schema: function(goptions, options, callback) {
    var finish, result;
    if (arguments.length === 2) {
      callback = options;
      options = goptions;
      goptions = {
        parallel: true
      };
    }
    result = child(mecano);
    finish = function(err, created) {
      if (callback) {
        callback(err, created);
      }
      return result.end(err, created);
    };
    misc.options(options, function(err, options) {
      var modified;
      if (err) {
        return finish(err);
      }
      modified = 0;
      return each(options).parallel(goptions.parallel).on('item', function(options, next) {
        var clean, conf, configure, dir, generate, ldif, register, registered, rename, schema, tempdir, write;
        if (!options.name) {
          return next(new Error("Missing name"));
        }
        if (!options.schema) {
          return next(new Error("Missing schema"));
        }
        options.schema = options.schema.trim();
        tempdir = options.tempdir || ("/tmp/mecano_ldap_schema_" + (Date.now()));
        schema = "" + tempdir + "/" + options.name + ".schema";
        conf = "" + tempdir + "/schema.conf";
        ldif = "" + tempdir + "/ldif";
        registered = function() {
          var binddn, cmd, passwd;
          binddn = options.binddn ? "-D " + options.binddn : '';
          passwd = options.passwd ? "-w " + options.passwd : '';
          cmd = "ldapsearch " + binddn + " " + passwd + " -b \"cn=schema,cn=config\" | grep -E cn=\\{[0-9]+\\}" + options.name + ",cn=schema,cn=config";
          if (typeof options.log === "function") {
            options.log("Check if schema is registered: " + cmd);
          }
          return mecano.execute({
            cmd: cmd,
            code: 0,
            code_skipped: 1,
            ssh: options.ssh,
            log: options.log,
            stdout: options.stdout,
            stderr: options.stderr
          }, function(err, registered, stdout) {
            if (err) {
              return next(err);
            }
            if (registered) {
              return next();
            }
            return dir();
          });
        };
        dir = function() {
          if (typeof options.log === "function") {
            options.log('Create ldif directory');
          }
          return mecano.mkdir({
            destination: ldif,
            ssh: options.ssh
          }, function(err, executed) {
            if (err) {
              return next(err);
            }
            return write();
          });
        };
        write = function() {
          if (typeof options.log === "function") {
            options.log('Copy schema');
          }
          return mecano.copy({
            source: options.schema,
            destination: schema,
            ssh: options.ssh
          }, function(err, copied) {
            if (err) {
              return next(err);
            }
            if (typeof options.log === "function") {
              options.log('Prepare configuration');
            }
            return mecano.write({
              content: "include " + schema,
              destination: conf,
              ssh: options.ssh
            }, function(err) {
              if (err) {
                return next(err);
              }
              return generate();
            });
          });
        };
        generate = function() {
          if (typeof options.log === "function") {
            options.log('Generate configuration');
          }
          return mecano.execute({
            cmd: "slaptest -f " + conf + " -F " + ldif,
            ssh: options.ssh,
            log: options.log,
            stdout: options.stdout,
            stderr: options.stderr
          }, function(err, executed) {
            if (err) {
              return next(err);
            }
            return rename();
          });
        };
        rename = function() {
          if (typeof options.log === "function") {
            options.log('Rename configuration');
          }
          return mecano.move({
            source: "" + ldif + "/cn=config/cn=schema/cn={0}" + options.name + ".ldif",
            destination: "" + ldif + "/cn=config/cn=schema/cn=" + options.name + ".ldif",
            force: true,
            ssh: options.ssh
          }, function(err, moved) {
            if (err) {
              return next(err);
            }
            if (!moved) {
              return new Error('No generated schema');
            }
            return configure();
          });
        };
        configure = function() {
          if (typeof options.log === "function") {
            options.log('Prepare ldif');
          }
          return mecano.write({
            destination: "" + ldif + "/cn=config/cn=schema/cn=" + options.name + ".ldif",
            write: [
              {
                match: /^dn: cn.*$/mg,
                replace: "dn: cn=" + options.name + ",cn=schema,cn=config"
              }, {
                match: /^cn: {\d+}(.*)$/mg,
                replace: 'cn: $1'
              }, {
                match: /^structuralObjectClass.*/mg,
                replace: ''
              }, {
                match: /^entryUUID.*/mg,
                replace: ''
              }, {
                match: /^creatorsName.*/mg,
                replace: ''
              }, {
                match: /^createTimestamp.*/mg,
                replace: ''
              }, {
                match: /^entryCSN.*/mg,
                replace: ''
              }, {
                match: /^modifiersName.*/mg,
                replace: ''
              }, {
                match: /^modifyTimestamp.*/mg,
                replace: ''
              }
            ],
            ssh: options.ssh
          }, function(err, written) {
            if (err) {
              return next(err);
            }
            return register();
          });
        };
        register = function() {
          var binddn, cmd, passwd, uri;
          uri = options.uri ? "-L " + options.uri : '';
          binddn = options.binddn ? "-D " + options.binddn : '';
          passwd = options.passwd ? "-w " + options.passwd : '';
          cmd = "ldapadd " + uri + " " + binddn + " " + passwd + " -f " + ldif + "/cn=config/cn=schema/cn=" + options.name + ".ldif";
          if (typeof options.log === "function") {
            options.log("Add schema: " + cmd);
          }
          return mecano.execute({
            cmd: cmd,
            ssh: options.ssh,
            log: options.log,
            stdout: options.stdout,
            stderr: options.stderr
          }, function(err, executed) {
            if (err) {
              return next(err);
            }
            modified++;
            return clean();
          });
        };
        clean = function() {
          if (typeof options.log === "function") {
            options.log('Clean up');
          }
          return mecano.remove({
            destination: tempdir,
            ssh: options.ssh
          }, function(err, removed) {
            return next(err);
          });
        };
        return conditions.all(options, next, registered);
      }).on('both', function(err) {
        return finish(err, modified);
      });
    });
    return result;
  },
  link: function(goptions, options, callback) {
    var finish, result;
    if (arguments.length === 2) {
      callback = options;
      options = goptions;
      goptions = {
        parallel: true
      };
    }
    result = child(mecano);
    finish = function(err, created) {
      if (callback) {
        callback(err, created);
      }
      return result.end(err, created);
    };
    misc.options(options, function(err, options) {
      var exec_create, exec_exists, linked, sym_create, sym_exists;
      if (err) {
        return finish(err);
      }
      linked = 0;
      sym_exists = function(options, callback) {
        return misc.file.exists(options.ssh, options.destination, function(err, exists) {
          if (!exists) {
            return callback(null, false);
          }
          return misc.file.readlink(options.ssh, options.destination, function(err, resolvedPath) {
            if (err) {
              return callback(err);
            }
            if (resolvedPath === options.source) {
              return callback(null, true);
            }
            return misc.file.unlink(options.ssh, options.destination, function(err) {
              if (err) {
                return callback(err);
              }
              return callback(null, false);
            });
          });
        });
      };
      sym_create = function(options, callback) {
        return misc.file.symlink(options.ssh, options.source, options.destination, function(err) {
          if (err) {
            return callback(err);
          }
          linked++;
          return callback();
        });
      };
      exec_exists = function(options, callback) {
        return misc.file.exists(options.ssh, options.destination, function(err, exists) {
          if (!exists) {
            return callback(null, false);
          }
          return misc.file.readFile(options.ssh, options.destination, 'utf8', function(err, content) {
            var exec_cmd;
            if (err) {
              return callback(err);
            }
            exec_cmd = /exec (.*) \$@/.exec(content)[1];
            return callback(null, exec_cmd && exec_cmd === options.source);
          });
        });
      };
      exec_create = function(options, callback) {
        var content;
        content = "#!/bin/bash\nexec " + options.source + " $@";
        return misc.file.writeFile(options.ssh, options.destination, content, function(err) {
          if (err) {
            return callback(err);
          }
          return misc.file.chmod(options.ssh, options.destination, options.mode, function(err) {
            if (err) {
              return callback(err);
            }
            linked++;
            return callback();
          });
        });
      };
      return each(options).parallel(goptions.parallel).on('item', function(options, next) {
        var do_dispatch, do_mkdir;
        if (!options.source) {
          return next(new Error("Missing source, got " + (JSON.stringify(options.source))));
        }
        if (!options.destination) {
          return next(new Error("Missing destination, got " + (JSON.stringify(options.destination))));
        }
        if (options.mode == null) {
          options.mode = 0x1ed;
        }
        do_mkdir = function() {
          return mecano.mkdir({
            ssh: options.ssh,
            destination: path.dirname(options.destination)
          }, function(err, created) {
            if (err && err.code !== 'EEXIST') {
              return callback(err);
            }
            return do_dispatch();
          });
        };
        do_dispatch = function() {
          if (options.exec) {
            return exec_exists(options, function(err, exists) {
              if (exists) {
                return next();
              }
              return exec_create(options, next);
            });
          } else {
            return sym_exists(options, function(err, exists) {
              if (exists) {
                return next();
              }
              return sym_create(options, next);
            });
          }
        };
        return do_mkdir();
      }).on('both', function(err) {
        return callback(err, linked);
      });
    });
    return result;
  },
  mkdir: function(goptions, options, callback) {
    var finish, result;
    if (arguments.length === 2) {
      callback = options;
      options = goptions;
      goptions = {
        parallel: true
      };
    }
    result = child(mecano);
    finish = function(err, created) {
      if (callback) {
        callback(err, created);
      }
      return result.end(err, created);
    };
    misc.options(options, function(err, options) {
      var created;
      if (err) {
        return finish(err);
      }
      created = 0;
      return each(options).parallel(goptions.parallel).on('item', function(options, next) {
        var cwd, _ref;
        if (typeof options === 'string') {
          options = {
            directory: options
          };
        }
        if (options.directory == null) {
          options.directory = options.source;
        }
        if (options.directory == null) {
          options.directory = options.destination;
        }
        if (options.directory == null) {
          return next(new Error('Missing directory option'));
        }
        if (typeof options.log === "function") {
          options.log("Create directory " + options.directory);
        }
        cwd = (_ref = options.cwd) != null ? _ref : process.cwd();
        if (!Array.isArray(options.directory)) {
          options.directory = [options.directory];
        }
        return conditions.all(options, next, function() {
          var mode;
          mode = options.mode || 0x1ed;
          return each(options.directory).on('item', function(directory, next) {
            var do_create, do_stats, do_update;
            do_stats = function() {
              var directories, dirs, end, i;
              end = false;
              dirs = [];
              directory = path.resolve(cwd, directory);
              directories = directory.split('/');
              directories.shift();
              directories = (function() {
                var _i, _ref1, _results;
                _results = [];
                for (i = _i = 0, _ref1 = directories.length; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
                  _results.push('/' + directories.slice(0, directories.length - i).join('/'));
                }
                return _results;
              })();
              return each(directories).on('item', function(directory, i, next) {
                if (end) {
                  return next();
                }
                return misc.file.stat(options.ssh, directory, function(err, stat) {
                  if ((err != null ? err.code : void 0) === 'ENOENT') {
                    directory.stat = stat;
                    dirs.push(directory);
                    if (i === directories.length - 1) {
                      return do_create(dirs);
                    } else {
                      return next();
                    }
                  }
                  if (stat != null ? stat.isDirectory() : void 0) {
                    end = true;
                    if (i === 0) {
                      return do_update(stat);
                    } else {
                      return do_create(dirs);
                    }
                  }
                  if (err) {
                    return next(err);
                  } else {
                    return next(new Error('Not a directory: #{JSON.encode(directory)}'));
                  }
                });
              }).on('both', function(err) {
                if (err) {
                  return next(err);
                }
              });
            };
            do_create = function(directories) {
              return each(directories.reverse()).on('item', function(directory, next) {
                if ((options.exclude != null) && options.exclude instanceof RegExp) {
                  if (options.exclude.test(path.basename(directory))) {
                    return next();
                  }
                }
                return misc.file.mkdir(options.ssh, directory, options, function(err) {
                  var modified;
                  if (err) {
                    return next(err);
                  }
                  modified = true;
                  return next();
                });
              }).on('both', function(err) {
                created++;
                return next(err);
              });
            };
            do_update = function(stat) {
              var do_chmod, do_chown, do_end, modified;
              modified = false;
              do_chown = function() {
                return mecano.chown({
                  ssh: options.ssh,
                  destination: directory,
                  uid: options.uid,
                  gid: options.gid
                }, function(err, owned) {
                  if (owned) {
                    modified = true;
                  }
                  return do_chmod();
                });
              };
              do_chmod = function() {
                if (!mode) {
                  return do_end();
                }
                if (misc.file.cmpmod(stat.mode, mode)) {
                  return do_end();
                }
                return misc.file.chmod(options.ssh, directory, mode, function(err) {
                  modified = true;
                  return do_end();
                });
              };
              do_end = function() {
                if (modified) {
                  created++;
                }
                return next();
              };
              return do_chown();
            };
            return do_stats();
          }).on('both', function(err) {
            return next(err);
          });
        });
      }).on('both', function(err) {
        return finish(err, created);
      });
    });
    return result;
  },
  move: function(goptions, options, callback) {
    if (arguments.length === 2) {
      callback = options;
      options = goptions;
      goptions = {
        parallel: true
      };
    }
    return misc.options(options, function(err, options) {
      var moved;
      if (err) {
        return callback(err);
      }
      moved = 0;
      return each(options).parallel(goptions.parallel).on('item', function(options, next) {
        var chkhash, dsthash, exists, move, remove_dest, remove_src, srchash;
        exists = function() {
          return misc.file.stat(options.ssh, options.destination, function(err, stat) {
            if ((err != null ? err.code : void 0) === 'ENOENT') {
              return move();
            }
            if (err) {
              return next(err);
            }
            if (options.force) {
              return remove_dest();
            } else {
              return srchash();
            }
          });
        };
        srchash = function() {
          if (options.source_md5) {
            return dsthash();
          }
          return misc.file.hash(options.ssh, options.source, 'md5', function(err, hash) {
            if (err) {
              return next(err);
            }
            options.source_md5 = hash;
            return dsthash();
          });
        };
        dsthash = function() {
          if (options.destination_md5) {
            return chkhash();
          }
          return misc.file.hash(options.ssh, options.destination, 'md5', function(err, hash) {
            if (err) {
              return next(err);
            }
            options.destination_md5 = hash;
            return chkhash();
          });
        };
        chkhash = function() {
          if (options.source_md5 === options.destination_md5) {
            return remove_src();
          } else {
            return remove_dest();
          }
        };
        remove_dest = function() {
          return mecano.remove({
            ssh: options.ssh,
            destination: options.destination
          }, function(err, removed) {
            if (err) {
              return next(err);
            }
            return move();
          });
        };
        move = function() {
          return misc.file.rename(options.ssh, options.source, options.destination, function(err) {
            if (err) {
              return next(err);
            }
            moved++;
            return next();
          });
        };
        remove_src = function() {
          return mecano.remove({
            ssh: options.ssh,
            destination: options.source
          }, function(err, removed) {
            return next(err);
          });
        };
        return conditions.all(options, next, exists);
      }).on('both', function(err) {
        return callback(err, moved);
      });
    });
  },
  remove: function(goptions, options, callback) {
    var finish, result;
    if (arguments.length === 2) {
      callback = options;
      options = goptions;
      goptions = {
        parallel: true
      };
    }
    result = child(mecano);
    finish = function(err, removed) {
      if (callback) {
        callback(err, removed);
      }
      return result.end(err, removed);
    };
    misc.options(options, function(err, options) {
      var removed;
      if (err) {
        return finish(err);
      }
      removed = 0;
      return each(options).parallel(goptions.parallel).on('item', function(options, next) {
        var remove;
        if (typeof options === 'string') {
          options = {
            source: options
          };
        }
        if (options.source == null) {
          options.source = options.destination;
        }
        if (options.source == null) {
          return next(new Error("Missing source"));
        }
        remove = function() {
          if (options.ssh) {
            return misc.file.exists(options.ssh, options.source, function(err, exists) {
              if (err) {
                return next(err);
              }
              if (exists) {
                removed++;
              }
              return misc.file.remove(options.ssh, options.source, next);
            });
          } else {
            return each().files(options.source).on('item', function(file, next) {
              removed++;
              return misc.file.remove(options.ssh, file, next);
            }).on('error', function(err) {
              return next(err);
            }).on('end', function() {
              return next();
            });
          }
        };
        return conditions.all(options, next, remove);
      }).on('both', function(err) {
        return finish(err, removed);
      });
    });
    return result;
  },
  render: function(goptions, options, callback) {
    if (arguments.length === 2) {
      callback = options;
      options = goptions;
      goptions = {
        parallel: true
      };
    }
    return misc.options(options, function(err, options) {
      var rendered;
      if (err) {
        return callback(err);
      }
      rendered = 0;
      return each(options).parallel(goptions.parallel).on('item', function(options, next) {
        var readSource, writeContent;
        if (!(options.source || options.content)) {
          return next(new Error('Missing source or content'));
        }
        if (!options.destination) {
          return next(new Error('Missing destination'));
        }
        readSource = function() {
          var ssh;
          if (!options.source) {
            return writeContent();
          }
          ssh = options.local_source ? null : options.ssh;
          return misc.file.exists(ssh, options.source, function(err, exists) {
            if (!exists) {
              return next(new Error("Invalid source, got " + (JSON.stringify(options.source))));
            }
            return misc.file.readFile(ssh, options.source, 'utf8', function(err, content) {
              if (err) {
                return next(err);
              }
              options.content = content;
              return writeContent();
            });
          });
        };
        writeContent = function() {
          options.source = null;
          return mecano.write(options, function(err, written) {
            if (err) {
              return next(err);
            }
            if (written) {
              rendered++;
            }
            return next();
          });
        };
        return conditions.all(options, next, readSource);
      }).on('both', function(err) {
        return callback(err, rendered);
      });
    });
  },
  service: function(goptions, options, callback) {
    var installed, updates;
    if (arguments.length === 2) {
      callback = options;
      options = goptions;
      goptions = {
        parallel: 1
      };
    }
    installed = updates = null;
    return misc.options(options, function(err, options) {
      var serviced;
      if (err) {
        return callback(err);
      }
      serviced = 0;
      return each(options).parallel(goptions.parallel).on('item', function(options, next) {
        var action, chkinstalled, chkname, chkupdates, finish, install, modified, pkgname, srvname, started, startup_add, startup_del, startuped;
        if (!options.name) {
          return next(new Error('Missing service name'));
        }
        if (!options.ssh) {
          return next(new Error('Restricted to Yum over SSH'));
        }
        pkgname = options.yum_name || options.name;
        chkname = options.chk_name || options.srv_name || options.name;
        srvname = options.srv_name || options.name;
        if ((options.startup != null) && typeof options.startup !== 'string') {
          options.startup = options.startup ? '2345' : '';
        }
        modified = false;
        if (installed == null) {
          installed = options.installed;
        }
        if (updates == null) {
          updates = options.updates;
        }
        chkinstalled = function() {
          var cache, decide;
          cache = function() {
            var c;
            if (typeof options.log === "function") {
              options.log("List installed packages");
            }
            c = options.cache ? '-C' : '';
            return mecano.execute({
              ssh: options.ssh,
              cmd: "yum -C list installed",
              code_skipped: 1,
              log: options.log,
              stdout: options.stdout,
              stderr: options.stderr
            }, function(err, executed, stdout) {
              var pkg, start, _i, _len;
              if (err) {
                return next(err);
              }
              stdout = stdout.split('\n');
              start = false;
              installed = [];
              for (_i = 0, _len = stdout.length; _i < _len; _i++) {
                pkg = stdout[_i];
                if (pkg.trim() === 'Installed Packages') {
                  start = true;
                }
                if (!start) {
                  continue;
                }
                if (pkg = /^([^\. ]+?)\./.exec(pkg)) {
                  installed.push(pkg[1]);
                }
              }
              return decide();
            });
          };
          decide = function() {
            if (installed.indexOf(pkgname) !== -1) {
              return chkupdates();
            } else {
              return install();
            }
          };
          if (installed) {
            return decide();
          } else {
            return cache();
          }
        };
        chkupdates = function() {
          var cache, decide;
          cache = function() {
            var c;
            if (typeof options.log === "function") {
              options.log("List available updates");
            }
            c = options.cache ? '-C' : '';
            return mecano.execute({
              ssh: options.ssh,
              cmd: "yum " + c + " list updates",
              code_skipped: 1,
              log: options.log,
              stdout: options.stdout,
              stderr: options.stderr
            }, function(err, executed, stdout) {
              var pkg, start, _i, _len;
              if (err) {
                return next(err);
              }
              stdout = stdout.split('\n');
              start = false;
              updates = [];
              for (_i = 0, _len = stdout.length; _i < _len; _i++) {
                pkg = stdout[_i];
                if (pkg.trim() === 'Updated Packages') {
                  start = true;
                }
                if (!start) {
                  continue;
                }
                if (pkg = /^([^\. ]+?)\./.exec(pkg)) {
                  updates.push(pkg[1]);
                }
              }
              return decide();
            });
          };
          decide = function() {
            if (updates.indexOf(pkgname) !== -1) {
              return install();
            } else {
              return startuped();
            }
          };
          if (updates) {
            return decide();
          } else {
            return cache();
          }
        };
        install = function() {
          if (typeof options.log === "function") {
            options.log("Install the package " + pkgname);
          }
          return mecano.execute({
            ssh: options.ssh,
            cmd: "yum install -y " + pkgname,
            code_skipped: 1,
            log: options.log,
            stdout: options.stdout,
            stderr: options.stderr
          }, function(err, succeed) {
            var installedIndex, updatesIndex;
            if (err) {
              return next(err);
            }
            installedIndex = installed.indexOf(pkgname);
            if (installedIndex === -1) {
              installed.push(pkgname);
            }
            if (updates) {
              updatesIndex = updates.indexOf(pkgname);
              if (updatesIndex !== -1) {
                updates.splice(updatesIndex, 1);
              }
            }
            if (!succeed) {
              return next(new Error("No package " + pkgname + " available."));
            }
            if (installedIndex !== -1) {
              modified = true;
            }
            return startuped();
          });
        };
        startuped = function() {
          if (options.startup == null) {
            return started();
          }
          if (typeof options.log === "function") {
            options.log("List startup services");
          }
          return mecano.execute({
            ssh: options.ssh,
            cmd: "chkconfig --list " + chkname,
            code_skipped: 1,
            log: options.log,
            stdout: options.stdout,
            stderr: options.stderr
          }, function(err, registered, stdout, stderr) {
            var c, current_startup, level, status, _i, _len, _ref, _ref1;
            if (err) {
              return next(err);
            }
            if (/^error/.test(stderr)) {
              return next(new Error("Invalid chkconfig name " + chkname));
            }
            current_startup = '';
            if (registered) {
              _ref = stdout.split(' ').pop().trim().split('\t');
              for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                c = _ref[_i];
                _ref1 = c.split(':'), level = _ref1[0], status = _ref1[1];
                if (['on', 'marche'].indexOf(status) > -1) {
                  current_startup += level;
                }
              }
            }
            if (options.startup === current_startup) {
              return started();
            }
            modified = true;
            if (options.startup != null) {
              return startup_add();
            } else {
              return startup_del();
            }
          });
        };
        startup_add = function() {
          var cmd, i, startup_off, startup_on, _i;
          if (typeof options.log === "function") {
            options.log("Add startup service");
          }
          startup_on = startup_off = '';
          for (i = _i = 0; _i < 6; i = ++_i) {
            if (options.startup.indexOf(i) !== -1) {
              startup_on += i;
            } else {
              startup_off += i;
            }
          }
          cmd = "chkconfig --add " + chkname + ";";
          if (startup_on) {
            cmd += "chkconfig --level " + startup_on + " " + chkname + " on;";
          }
          if (startup_off) {
            cmd += "chkconfig --level " + startup_off + " " + chkname + " off;";
          }
          return mecano.execute({
            ssh: options.ssh,
            cmd: cmd,
            log: options.log,
            stdout: options.stdout,
            stderr: options.stderr
          }, function(err) {
            if (err) {
              return next(err);
            }
            return started();
          });
        };
        startup_del = function() {
          if (typeof options.log === "function") {
            options.log("Remove startup service");
          }
          return mecano.execute({
            ssh: options.ssh,
            cmd: "chkconfig --del " + chkname,
            log: options.log,
            stdout: options.stdout,
            stderr: options.stderr
          }, function(err) {
            if (err) {
              return next(err);
            }
            return started();
          });
        };
        started = function() {
          if (options.action !== 'start' && options.action !== 'stop') {
            return action();
          }
          if (typeof options.log === "function") {
            options.log("Check if service is started");
          }
          return mecano.execute({
            ssh: options.ssh,
            cmd: "service " + srvname + " status",
            code_skipped: 3,
            log: options.log,
            stdout: options.stdout,
            stderr: options.stderr
          }, function(err, started) {
            if (err) {
              return next(err);
            }
            if (started) {
              if (options.action !== 'start') {
                return action();
              }
            } else {
              if (options.action !== 'stop') {
                return action();
              }
            }
            return finish();
          });
        };
        action = function() {
          if (!options.action) {
            return finish();
          }
          if (typeof options.log === "function") {
            options.log("Start/stop the service");
          }
          return mecano.execute({
            ssh: options.ssh,
            cmd: "service " + srvname + " " + options.action,
            log: options.log,
            stdout: options.stdout,
            stderr: options.stderr
          }, function(err, executed) {
            if (err) {
              return next(err);
            }
            modified = true;
            return finish();
          });
        };
        finish = function() {
          if (modified) {
            serviced++;
          }
          return next();
        };
        return conditions.all(options, next, chkinstalled);
      }).on('both', function(err) {
        return callback(err, serviced, installed, updates);
      });
    });
  },
  touch: function(goptions, options, callback) {
    var finish, result;
    if (arguments.length === 2) {
      callback = options;
      options = goptions;
      goptions = {
        parallel: true
      };
    }
    result = child(mecano);
    finish = function(err, modified) {
      if (callback) {
        callback(err, modified);
      }
      return result.end(err, modified);
    };
    return misc.options(options, function(err, options) {
      var modified;
      if (err) {
        return finish(err);
      }
      modified = 0;
      return each(options).on('item', function(options, next) {
        var destination, mode, ssh;
        ssh = options.ssh, destination = options.destination, mode = options.mode;
        if (!destination) {
          return next(new Error("Missing destination: " + destination));
        }
        return misc.file.exists(ssh, destination, function(err, exists) {
          if (err) {
            return next(err);
          }
          if (exists) {
            return next;
          }
          options.source = null;
          options.content = '';
          return mecano.write(options, function(err, written) {
            if (err) {
              return next(err);
            }
            modified++;
            return next();
          });
        });
      }).on('both', function(err) {
        return finish(err, modified);
      });
    });
  },
  upload: function(goptions, options, callback) {
    var finish, result;
    if (arguments.length === 2) {
      callback = options;
      options = goptions;
      goptions = {
        parallel: true
      };
    }
    result = child(mecano);
    finish = function(err, uploaded) {
      if (callback) {
        callback(err, uploaded);
      }
      return result.end(err, uploaded);
    };
    misc.options(options, function(err, options) {
      var uploaded;
      if (err) {
        return finish(err);
      }
      uploaded = 0;
      return each(options).parallel(goptions.parallel).on('item', function(options, next) {
        return conditions.all(options, next, function() {
          var do_end, do_exists, do_md5, do_sha1, do_upload, get_checksum;
          if (options.binary) {
            get_checksum = function(path, digest, callback) {
              return mecano.execute({
                ssh: options.ssh,
                cmd: "openssl " + digest + " " + path,
                log: options.log,
                stdout: options.stdout,
                stderr: options.stderr
              }, function(err, executed, stdout, stderr) {
                if (err) {
                  return callback(err);
                }
                return callback(null, /[ ](.*)$/.exec(stdout.trim())[1]);
              });
            };
            do_exists = function() {
              if (typeof options.log === "function") {
                options.log("Check if " + options.destination + " exists remotely");
              }
              return misc.file.exists(options.ssh, options.destination, function(err, exists) {
                if (err) {
                  return next(err);
                }
                if (!exists) {
                  return do_upload();
                }
                if (!(options.md5 || options.sha1)) {
                  return do_upload();
                }
                if (typeof options.log === "function") {
                  options.log("Make sure destination checksum is valid");
                }
                switch (false) {
                  case options.md5 == null:
                    return get_checksum(options.destination, 'md5', function(err, md5) {
                      if (err) {
                        return next(err);
                      }
                      if (md5 === options.md5) {
                        return next();
                      } else {
                        return do_upload();
                      }
                    });
                  case options.sha1 == null:
                    return get_checksum(options.destination, 'sha1', function(err, sha1) {
                      if (err) {
                        return next(err);
                      }
                      if (sha1 === options.sha1) {
                        return next();
                      } else {
                        return do_upload();
                      }
                    });
                }
              });
            };
            do_upload = function() {
              if (typeof options.log === "function") {
                options.log("Upload " + options.source);
              }
              return options.ssh.sftp(function(err, sftp) {
                var from, l, to;
                from = fs.createReadStream(options.source);
                to = sftp.createWriteStream(options.destination);
                l = 0;
                from.pipe(to);
                from.on('error', next);
                to.on('error', next);
                return to.on('close', function() {
                  uploaded++;
                  return do_md5();
                });
              });
            };
            do_md5 = function() {
              if (!options.md5) {
                return do_sha1();
              }
              if (typeof options.log === "function") {
                options.log("Check md5 for '" + options.destination + "'");
              }
              return get_checksum(options.destination, 'md5', function(err, md5) {
                if (md5 !== options.md5) {
                  return next(new Error("Invalid md5 checksum"));
                }
                return do_sha1();
              });
            };
            do_sha1 = function() {
              if (!options.sha1) {
                return do_end();
              }
              if (typeof options.log === "function") {
                options.log("Check sha1 for '" + options.destination + "'");
              }
              return get_checksum(options.destination, 'sha1', function(err, sha1) {
                if (sha1 !== options.sha1) {
                  return next(new Error("Invalid sha1 checksum"));
                }
                return do_end();
              });
            };
            do_end = function() {
              if (typeof options.log === "function") {
                options.log("Upload succeed in " + options.destination);
              }
              return next();
            };
            return do_exists();
          }
          options = misc.merge(options, {
            local_source: true
          });
          return mecano.write(options, function(err, written) {
            if (written === 1) {
              uploaded++;
            }
            return next(err);
          });
        });
      }).on('both', function(err) {
        return finish(err, uploaded);
      });
    });
    return result;
  },
  write: function(goptions, options, callback) {
    var finish, result;
    if (arguments.length === 2) {
      callback = options;
      options = goptions;
      goptions = {
        parallel: true
      };
    }
    result = child(mecano);
    finish = function(err, written) {
      if (callback) {
        callback(err, written);
      }
      return result.end(err, written);
    };
    misc.options(options, function(err, options) {
      var written;
      if (err) {
        return finish(err);
      }
      written = 0;
      return each(options).parallel(goptions.parallel).on('item', function(options, next) {
        var append, backup, between, content, destination, destinationHash, do_changeOwnership, do_changePermissions, do_end, from, modified, readDestination, readSource, render, replacePartial, to, write, writeContent, _ref;
        modified = false;
        if (!((options.source || (options.content != null)) || options.replace || ((_ref = options.write) != null ? _ref.length : void 0))) {
          return next(new Error('Missing source or content'));
        }
        if (options.source && options.content) {
          return next(new Error('Define either source or content'));
        }
        if (!options.destination) {
          return next(new Error('Missing destination'));
        }
        destination = null;
        destinationHash = null;
        content = null;
        from = to = between = null;
        append = options.append;
        write = options.write;
        if (write == null) {
          write = [];
        }
        if ((options.from != null) || (options.to != null) || (options.match != null)) {
          write.push({
            from: options.from,
            to: options.to,
            match: options.match,
            replace: options.replace,
            append: options.append
          });
        }
        readSource = function() {
          var source, ssh;
          if (options.content != null) {
            content = options.content;
            if (typeof content === 'number') {
              content = "" + content;
            }
            return readDestination();
          }
          source = options.source || options.destination;
          ssh = options.local_source ? null : options.ssh;
          return misc.file.exists(ssh, source, function(err, exists) {
            if (err) {
              return next(err);
            }
            if (!exists) {
              if (options.source) {
                return next(new Error("Source does not exist: \"" + options.source + "\""));
              }
              content = '';
              return readDestination();
            }
            return misc.file.readFile(ssh, source, 'utf8', function(err, src) {
              if (err) {
                return next(err);
              }
              content = src;
              return readDestination();
            });
          });
        };
        readDestination = function() {
          var exists, mkdir, read;
          if (typeof options.destination === 'function') {
            return render();
          }
          exists = function() {
            return misc.file.exists(options.ssh, options.destination, function(err, exists) {
              if (err) {
                return next(err);
              }
              if (exists) {
                return read();
              } else {
                return mkdir();
              }
            });
          };
          mkdir = function() {
            return mecano.mkdir({
              ssh: options.ssh,
              destination: path.dirname(options.destination),
              uid: options.uid,
              gid: options.gid,
              mode: options.mode,
              not_if_exists: path.dirname(options.destination)
            }, function(err, created) {
              if (err) {
                return next(err);
              }
              return render();
            });
          };
          read = function() {
            return misc.file.readFile(options.ssh, options.destination, 'utf8', function(err, dest) {
              if (err) {
                return next(err);
              }
              destinationHash = misc.string.hash(dest);
              return render();
            });
          };
          return exists();
        };
        render = function() {
          if (options.context == null) {
            return replacePartial();
          }
          try {
            content = eco.render(content.toString(), options.context);
          } catch (_error) {
            err = _error;
            if (typeof err === 'string') {
              err = new Error(err);
            }
            return next(err);
          }
          return replacePartial();
        };
        replacePartial = function() {
          var linebreak, opts, orgContent, pos, posoffset, res, _i, _len;
          if (!write.length) {
            return writeContent();
          }
          for (_i = 0, _len = write.length; _i < _len; _i++) {
            opts = write[_i];
            if (opts.match) {
              if (opts.match instanceof RegExp) {
                if (opts.match.test(content)) {
                  content = content.replace(opts.match, opts.replace);
                  append = false;
                } else if (opts.append && typeof opts.replace === 'string') {
                  if (typeof opts.append === "string") {
                    opts.append = new RegExp("^.*" + opts.append + ".*$", 'mg');
                  }
                  if (opts.append instanceof RegExp) {
                    posoffset = 0;
                    orgContent = content;
                    while ((res = opts.append.exec(orgContent)) !== null) {
                      pos = posoffset + res.index + res[0].length;
                      content = content.slice(0, pos) + '\n' + opts.replace + content.slice(pos);
                      posoffset += opts.replace.length + 1;
                      if (!opts.append.global) {
                        break;
                      }
                    }
                    append = false;
                  } else {
                    linebreak = content.length === 0 || content.substr(content.length - 1) === '\n' ? '' : '\n';
                    content = content + linebreak + opts.replace;
                    append = false;
                  }
                } else {
                  continue;
                }
              } else {
                from = content.indexOf(opts.match);
                to = from + opts.match.length;
                content = content.substr(0, from) + opts.replace + content.substr(to);
              }
            } else {
              from = opts.from ? content.indexOf(opts.from) + opts.from.length : 0;
              to = opts.to ? content.indexOf(opts.to) : content.length;
              content = content.substr(0, from) + opts.replace + content.substr(to);
            }
          }
          return writeContent();
        };
        writeContent = function() {
          if (destinationHash === misc.string.hash(content)) {
            return do_changeOwnership();
          }
          if (typeof options.destination === 'function') {
            options.destination(content);
            return do_end();
          } else {
            if (append) {
              if (options.flags == null) {
                options.flags = 'a';
              }
            }
            return misc.file.writeFile(options.ssh, options.destination, content, options, function(err) {
              if (err) {
                return next(err);
              }
              modified = true;
              return backup();
            });
          }
        };
        backup = function() {
          if (!options.backup) {
            return do_end();
          }
          backup = options.backup;
          if (backup === true) {
            backup = "." + (Date.now());
          }
          backup = "" + options.destination + backup;
          return misc.file.writeFile(options.ssh, backup, content, function(err) {
            if (err) {
              return next(err);
            }
            return do_end();
          });
        };
        do_changeOwnership = function() {
          if (!((options.uid != null) && (options.gid != null))) {
            return do_changePermissions();
          }
          return mecano.chown({
            ssh: options.ssh,
            destination: options.destination,
            uid: options.uid,
            gid: options.gid,
            log: options.log,
            stdout: options.stdout,
            stderr: options.stderr
          }, function(err, chowned) {
            if (err) {
              return next(err);
            }
            if (chowned) {
              modified = true;
            }
            return do_changePermissions();
          });
        };
        do_changePermissions = function() {
          if (options.mode == null) {
            return do_end();
          }
          return mecano.chmod({
            ssh: options.ssh,
            destination: options.destination,
            mode: options.mode,
            log: options.log,
            stdout: options.stdout,
            stderr: options.stderr
          }, function(err, chmoded) {
            if (err) {
              return next(err);
            }
            if (chmoded) {
              modified = true;
            }
            return do_end();
          });
        };
        do_end = function() {
          if (modified) {
            written++;
          }
          return next();
        };
        return conditions.all(options, next, readSource);
      }).on('both', function(err) {
        return finish(err, written);
      });
    });
    return result;
  }
};

mecano.cp = mecano.copy;

mecano.exec = mecano.execute;

mecano.ln = mecano.link;

mecano.mv = mecano.move;

mecano.rm = mecano.remove;
