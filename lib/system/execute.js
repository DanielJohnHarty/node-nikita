// Generated by CoffeeScript 1.12.4
var exec, misc, path, string;

module.exports = function(options, callback) {
  var current_username, result;
  options.log({
    message: "Entering execute",
    level: 'DEBUG',
    module: 'nikita/lib/system/execute'
  });
  if (typeof options.argument === 'string') {
    options.cmd = options.argument;
  }
  if (options.code == null) {
    options.code = [0];
  }
  if (!Array.isArray(options.code)) {
    options.code = [options.code];
  }
  if (options.code_skipped == null) {
    options.code_skipped = [];
  }
  if (!Array.isArray(options.code_skipped)) {
    options.code_skipped = [options.code_skipped];
  }
  if (options.stdin_log == null) {
    options.stdin_log = true;
  }
  if (options.stdout_log == null) {
    options.stdout_log = true;
  }
  if (options.stderr_log == null) {
    options.stderr_log = true;
  }
  if (options.stdout_callback === void 0) {
    options.stdout_callback = true;
  }
  if (options.stderr_callback === void 0) {
    options.stderr_callback = true;
  }
  if (typeof options.cmd === 'function') {
    options.cmd = options.cmd.call(this, options);
  }
  if (options.bash === true) {
    options.bash = 'bash';
  }
  if (options.arch_chroot === true) {
    options.arch_chroot = 'arch-chroot';
  }
  if (options.cmd && options.trap) {
    options.cmd = "set -e\n" + options.cmd;
  }
  options.cmd_original = "" + options.cmd;
  if (options.cmd == null) {
    throw Error("Missing cmd: " + options.cmd);
  }
  if (['bash', 'arch_chroot'].filter(function(k) {
    return options[k];
  }).length > 1) {
    throw Error("Incompatible options: bash, arch_chroot");
  }
  if (options.arch_chroot && !options.rootdir) {
    throw Error("Required Option: \"rootdir\" with \"arch_chroot\"");
  }
  result = {
    stdout: null,
    stderr: null,
    code: null
  };
  current_username = options.ssh ? options.ssh.config.username : /^win/.test(process.platform) ? process.env['USERPROFILE'].split(path.sep)[2] : process.env['USER'];
  this.call(function() {
    if (!options.sudo) {
      return;
    }
    if (current_username === 'root') {
      return options.sudo = false;
    }
    if (!['bash', 'arch_chroot'].some(function(k) {
      return options[k];
    })) {
      return options.bash = 'bash';
    }
  });
  this.call({
    shy: true
  }, function(_, callback) {
    var obj;
    if (!options.uid) {
      return callback(null, false);
    }
    if (current_username === 'root') {
      return callback(null, false);
    }
    if (!/\d/.test("" + options.uid)) {
      return callback(null, options.uid !== current_username);
    }
    return this.system.execute((
      obj = {},
      obj["awk -v val=" + options.uid + " -F "] = " '$3==val{print $1}' /etc/passwd`",
      obj
    ), function(err, _, stdout) {
      if (!err) {
        options.uid = stdout.trim();
      }
      if (!(options.bash || options.arch_chroot)) {
        options.bash = 'bash';
      }
      return callback(err, options.uid !== current_username);
    });
  });
  this.call({
    "if": function() {
      return options.bash;
    }
  }, function() {
    var cmd;
    cmd = options.cmd;
    if (typeof options.target !== 'string') {
      options.target = "/tmp/nikita_" + (string.hash(options.cmd));
    }
    options.log({
      message: 'Writing bash script to #{JSON.stringify options.target}',
      level: 'INFO'
    });
    options.cmd = options.bash + " " + options.target;
    if (options.uid) {
      options.cmd = "su - " + options.uid + " -c '" + options.cmd + "'";
    }
    return this.file({
      target: options.target,
      content: cmd,
      uid: options.uid,
      shy: true
    });
  });
  this.call({
    "if": function() {
      return options.arch_chroot;
    }
  }, function() {
    var cmd;
    cmd = options.cmd;
    if (typeof options.target !== 'string') {
      options.target = "/var/tmp/nikita_" + (string.hash(options.cmd));
    }
    options.log({
      message: "Writing arch-chroot script to " + (JSON.stringify(options.target)),
      level: 'INFO'
    });
    options.cmd = "arch-chroot " + options.rootdir + " bash " + options.target;
    return this.file({
      target: "" + (path.join(options.rootdir, options.target)),
      content: "" + cmd,
      mode: options.mode,
      shy: true,
      eof: true
    });
  });
  this.call(function() {
    if (!options.sudo) {
      return;
    }
    if (options.sudo) {
      return options.cmd = "sudo " + options.cmd;
    }
  });
  this.call(function(_, callback) {
    var child, stderr_stream_open, stdout_stream_open;
    if (options.stdin_log) {
      options.log({
        message: options.cmd_original,
        type: 'stdin',
        level: 'INFO',
        module: 'nikita/lib/system/execute'
      });
    }
    child = exec(options);
    result.stdout = [];
    result.stderr = [];
    if (options.stdout) {
      child.stdout.pipe(options.stdout, {
        end: false
      });
    }
    if (options.stderr) {
      child.stderr.pipe(options.stderr, {
        end: false
      });
    }
    stdout_stream_open = stderr_stream_open = false;
    if (options.stdout_callback || options.stdout_log) {
      child.stdout.on('data', function(data) {
        if (options.stdout_log) {
          stdout_stream_open = true;
        }
        if (options.stdout_log) {
          options.log({
            message: data,
            type: 'stdout_stream',
            module: 'nikita/lib/system/execute'
          });
        }
        if (options.stdout_callback) {
          if (Array.isArray(result.stdout)) {
            return result.stdout.push(data);
          } else {
            return console.log('stdout coming after child exit');
          }
        }
      });
    }
    if (options.stderr_callback || options.stderr_log) {
      child.stderr.on('data', function(data) {
        if (options.stderr_log) {
          stderr_stream_open = true;
        }
        if (options.stderr_log) {
          options.log({
            message: data,
            type: 'stderr_stream',
            module: 'nikita/lib/system/execute'
          });
        }
        if (options.stderr_callback) {
          if (Array.isArray(result.stderr)) {
            return result.stderr.push(data);
          } else {
            return console.log('stderr coming after child exit');
          }
        }
      });
    }
    return child.on("exit", function(code) {
      result.code = code;
      return setTimeout(function() {
        var err, status;
        if (stdout_stream_open && options.stdout_log) {
          options.log({
            message: null,
            type: 'stdout_stream',
            module: 'nikita/lib/system/execute'
          });
        }
        if (stderr_stream_open && options.stderr_log) {
          options.log({
            message: null,
            type: 'stderr_stream',
            module: 'nikita/lib/system/execute'
          });
        }
        result.stdout = result.stdout.map(function(d) {
          return d.toString();
        }).join('');
        if (options.trim || options.stdout_trim) {
          result.stdout = result.stdout.trim();
        }
        result.stderr = result.stderr.map(function(d) {
          return d.toString();
        }).join('');
        if (options.trim || options.stderr_trim) {
          result.stderr = result.stderr.trim();
        }
        if (result.stdout && result.stdout !== '' && options.stdout_log) {
          options.log({
            message: result.stdout,
            type: 'stdout',
            module: 'nikita/lib/system/execute'
          });
        }
        if (result.stderr && result.stderr !== '' && options.stderr_log) {
          options.log({
            message: result.stderr,
            type: 'stderr',
            module: 'nikita/lib/system/execute'
          });
        }
        if (options.stdout) {
          child.stdout.unpipe(options.stdout);
        }
        if (options.stderr) {
          child.stderr.unpipe(options.stderr);
        }
        if (options.code.indexOf(code) === -1 && options.code_skipped.indexOf(code) === -1) {
          err = new Error("Invalid Exit Code: " + code);
          err.code = code;
          return callback(err, null);
        }
        if (options.code_skipped.indexOf(code) === -1) {
          status = true;
        } else {
          options.log({
            message: "Skip exit code \"" + code + "\"",
            level: 'INFO',
            module: 'nikita/lib/system/execute'
          });
        }
        return callback(null, status);
      }, 1);
    });
  });
  return this.then(function(err1, status) {
    this.system.remove({
      "if": !options.dirty && options.target,
      target: options.target,
      always: true
    });
    return this.then(function(err2) {
      return callback(err1 || err2, status, result.stdout, result.stderr, result.code);
    });
  });
};

path = require('path');

exec = require('ssh2-exec');

misc = require('../misc');

string = require('../misc/string');
