// Generated by CoffeeScript 1.12.5
var each, fs, glob, misc, path;

module.exports = function(options) {
  options.log({
    message: "Entering copy",
    level: 'DEBUG',
    module: 'nikita/lib/system/copy'
  });
  if (options.uid == null) {
    options.uid = false;
  }
  if (typeof options.uid === 'string' && !isNaN(parseInt(options.uid))) {
    options.uid = parseInt(options.uid);
  }
  if (options.gid == null) {
    options.gid = false;
  }
  if (typeof options.gid === 'string' && !isNaN(parseInt(options.uid))) {
    options.gid = parseInt(options.gid);
  }
  if (options.preserve == null) {
    options.preserve = false;
  }
  if (!options.source) {
    throw Error('Missing source');
  }
  if (!options.target) {
    throw Error('Missing target');
  }
  this.call(function(_, callback) {
    if (options.source_stats) {
      options.log({
        message: "Source Stats: using short circuit",
        level: 'DEBUG',
        module: 'nikita/lib/system/copy'
      });
      return callback();
    }
    options.log({
      message: "Stats source file " + options.source,
      level: 'DEBUG',
      module: 'nikita/lib/system/copy'
    });
    return fs.stat(options.ssh, options.source, (function(_this) {
      return function(err, stats) {
        if (err) {
          return callback(err);
        }
        if (!err) {
          options.source_stats = stats;
        }
        return callback();
      };
    })(this));
  });
  this.call(function(_, callback) {
    if (options.target_stats) {
      options.log({
        message: "Target Stats: using short circuit",
        level: 'DEBUG',
        module: 'nikita/lib/system/copy'
      });
      return callback();
    }
    options.log({
      message: "Stats target file " + options.target,
      level: 'DEBUG',
      module: 'nikita/lib/system/copy'
    });
    return fs.stat(options.ssh, options.target, (function(_this) {
      return function(err, stats) {
        if (err && err.code !== 'ENOENT') {
          return callback(err);
        }
        options.target_stats = stats;
        return callback();
      };
    })(this));
  });
  this.call(function(_, callback) {
    var sourceEndWithSlash;
    if (!options.source_stats.isDirectory()) {
      return callback();
    }
    sourceEndWithSlash = options.source.lastIndexOf('/') === options.source.length - 1;
    if (options.target_stats && !sourceEndWithSlash) {
      options.target = path.resolve(options.target, path.basename(options.source));
    }
    options.log({
      message: "Source is a directory",
      level: 'INFO',
      module: 'nikita/lib/system/copy'
    });
    this.call(function(_, callback) {
      return glob(options.ssh, options.source + "/**", {
        dot: true
      }, (function(_this) {
        return function(err, sources) {
          var fn, i, len, source;
          if (err) {
            return callback(err);
          }
          fn = function(source) {
            var target;
            target = path.resolve(options.target, path.relative(options.source, source));
            return _this.call(function(_, callback) {
              return fs.stat(options.ssh, source, (function(_this) {
                return function(err, source_stats) {
                  var gid, mode, uid;
                  uid = options.uid;
                  if (options.preserve) {
                    if (uid == null) {
                      uid = source_stats.uid;
                    }
                  }
                  gid = options.gid;
                  if (options.preserve) {
                    if (gid == null) {
                      gid = source_stats.gid;
                    }
                  }
                  mode = options.mode;
                  if (options.preserve) {
                    if (mode == null) {
                      mode = source_stats.mode;
                    }
                  }
                  if (source_stats.isDirectory()) {
                    _this.system.mkdir({
                      target: target,
                      uid: uid,
                      gid: gid,
                      mode: mode
                    });
                  } else {
                    _this.system.copy({
                      target: target,
                      source: source,
                      source_stat: source_stats,
                      uid: uid,
                      gid: gid,
                      mode: mode
                    });
                  }
                  return _this.then(callback);
                };
              })(this));
            });
          };
          for (i = 0, len = sources.length; i < len; i++) {
            source = sources[i];
            fn(source);
          }
          return _this.then(callback);
        };
      })(this));
    });
    return this.then(function(err, status) {
      return callback(err, status, true);
    });
  }, function(err, status, end) {
    if (!err && end) {
      return this.end();
    }
  });
  this.call(function() {
    if (!(options.target_stats && options.target_stats.isDirectory())) {
      return;
    }
    return options.target = path.resolve(options.target, path.basename(options.source));
  });
  this.call((function(_this) {
    return function(_, callback) {
      return misc.file.compare(options.ssh, [options.source, options.target], function(err, md5) {
        if (err && err.message.indexOf('Does not exist') !== 0) {
          return callback(err);
        }
        if (md5) {
          return callback(null, false);
        }
        options.log({
          message: "Copy file from " + options.source + " into " + options.target,
          level: 'WARN',
          module: 'nikita/lib/system/copy'
        });
        return misc.file.copyFile(options.ssh, options.source, options.target, function(err) {
          return callback(err, true);
        });
      });
    };
  })(this), function(err, status) {
    return options.log({
      message: "File " + options.source + " copied",
      level: 'DEBUG',
      module: 'nikita/lib/system/copy'
    });
  });
  return this.call(function() {
    if (options.preserve) {
      if (options.uid == null) {
        options.uid = options.source_stats.uid;
      }
    }
    if (options.preserve) {
      if (options.gid == null) {
        options.gid = options.source_stats.gid;
      }
    }
    if (options.preserve) {
      if (options.mode == null) {
        options.mode = options.source_stats.mode;
      }
    }
    this.system.chown({
      target: options.target,
      stat: options.target_stats,
      uid: options.uid,
      gid: options.gid,
      "if": (options.uid != null) || (options.gid != null)
    });
    return this.system.chmod({
      target: options.target,
      stat: options.target_stats,
      mode: options.mode,
      "if": options.mode != null
    });
  });
};

fs = require('ssh2-fs');

path = require('path');

each = require('each');

misc = require('../misc');

glob = require('../misc/glob');
