// Generated by CoffeeScript 2.0.0
// # `nikita.system.copy(options, [callback])`

// Copy a file. The behavior is similar to the one of the `cp`
// Unix utility. Copying a file over an existing file will
// overwrite it.

// ## Options

// * `gid`   
//   Group name or id who owns the file.   
// * `mode`   
//   Permissions of the file or the parent directory.   
// * `preserve`   
//   Preserve file ownerships and permissions, default to "false".
// * `source`   
//   The file or directory to copy.   
// * `source_stats`   
//   Short-circuit to prevent source stat retrieval if already at our disposal.   
// * `target`   
//   Where the file or directory is copied.   
// * `target_stats`   
//   Short-circuit to prevent target stat retrieval if already at our disposal.   
// * `uid`   
//   User name or id who owns the file.   

// ## Callback Parameters

// * `err`   
//   Error object if any.   
// * `status`   
//   Value is "true" if copied file was created or modified.   

// ## Todo

// * Apply permissions to directories
// * Handle symlinks
// * Handle globing
// * Preserve permissions if `mode` is `true`

// ## Example

// ```js
// require('nikita').system.copy({
//   source: '/etc/passwd',
//   target: '/etc/passwd.bck',
//   uid: 'my_user'
//   gid: 'my_group'
//   mode: '0755'
// }, function(err, status){
//   console.log(err ? err.message : 'File was copied: ' + status);
// });
// ```

// ## Source Code
var each, fs, glob, misc, path;

module.exports = function(options) {
  options.log({
    message: "Entering copy",
    level: 'DEBUG',
    module: 'nikita/lib/system/copy'
  });
  // Validate parameters.
  if (options.uid == null) {
    options.uid = false;
  }
  if (typeof options.uid === 'string' && !isNaN(parseInt(options.uid))) {
    options.uid = parseInt(options.uid);
  }
  if (options.gid == null) {
    options.gid = false;
  }
  if (typeof options.gid === 'string' && !isNaN(parseInt(options.uid))) {
    options.gid = parseInt(options.gid);
  }
  if (options.preserve == null) {
    options.preserve = false;
  }
  if (!options.source) {
    throw Error('Missing source');
  }
  if (!options.target) {
    throw Error('Missing target');
  }
  // Retrieve stats information about the source unless provided through the "source_stats" option.
  this.call(function(_, callback) {
    if (options.source_stats) {
      options.log({
        message: "Source Stats: using short circuit",
        level: 'DEBUG',
        module: 'nikita/lib/system/copy'
      });
      return callback();
    }
    options.log({
      message: `Stats source file ${options.source}`,
      level: 'DEBUG',
      module: 'nikita/lib/system/copy'
    });
    return fs.stat(options.ssh, options.source, (err, stats) => {
      if (err) {
        return callback(err);
      }
      if (!err) {
        options.source_stats = stats;
      }
      return callback();
    });
  });
  // Retrieve stat information about the traget unless provided through the "target_stats" option.
  this.call(function(_, callback) {
    if (options.target_stats) {
      options.log({
        message: "Target Stats: using short circuit",
        level: 'DEBUG',
        module: 'nikita/lib/system/copy'
      });
      return callback();
    }
    options.log({
      message: `Stats target file ${options.target}`,
      level: 'DEBUG',
      module: 'nikita/lib/system/copy'
    });
    return fs.stat(options.ssh, options.target, (err, stats) => {
      if (err && err.code !== 'ENOENT') {
        // Note, target file doesnt necessarily exist
        return callback(err);
      }
      options.target_stats = stats;
      return callback();
    });
  });
  // Stop here if source is a directory. We traverse all its children
  // Recursively, calling either `system.mkdir` or `system.copy`.

  // Like with the Unix `cp` command, ending slash matters if the target directory 
  // exists. Let's consider a source directory "/tmp/a_source" and a target directory
  // "/tmp/a_target". Without an ending slash , the directory "/tmp/a_source" is 
  // copied into "/tmp/a_target/a_source". With an ending slash, all the files
  // present inside "/tmp/a_source" are copied inside "/tmp/a_target".
  this.call(function(_, callback) {
    var sourceEndWithSlash;
    if (!options.source_stats.isDirectory()) {
      return callback();
    }
    sourceEndWithSlash = options.source.lastIndexOf('/') === options.source.length - 1;
    if (options.target_stats && !sourceEndWithSlash) {
      options.target = path.resolve(options.target, path.basename(options.source));
    }
    options.log({
      message: "Source is a directory",
      level: 'INFO',
      module: 'nikita/lib/system/copy'
    });
    this.call(function(_, callback) {
      return glob(options.ssh, `${options.source}/**`, {
        dot: true
      }, (err, sources) => {
        var fn, i, len, source;
        if (err) {
          return callback(err);
        }
        fn = (source) => {
          var target;
          target = path.resolve(options.target, path.relative(options.source, source));
          return this.call(function(_, callback) {
            return fs.stat(options.ssh, source, (err, source_stats) => {
              var gid, mode, uid;
              uid = options.uid;
              if (options.preserve) {
                if (uid == null) {
                  uid = source_stats.uid;
                }
              }
              gid = options.gid;
              if (options.preserve) {
                if (gid == null) {
                  gid = source_stats.gid;
                }
              }
              mode = options.mode;
              if (options.preserve) {
                if (mode == null) {
                  mode = source_stats.mode;
                }
              }
              if (source_stats.isDirectory()) {
                this.system.mkdir({
                  target: target,
                  uid: uid,
                  gid: gid,
                  mode: mode
                });
              } else {
                this.system.copy({
                  target: target,
                  source: source,
                  source_stat: source_stats,
                  uid: uid,
                  gid: gid,
                  mode: mode
                });
              }
              return this.then(callback);
            });
          });
        };
        for (i = 0, len = sources.length; i < len; i++) {
          source = sources[i];
          fn(source);
        }
        return this.then(callback);
      });
    });
    return this.then(function(err, status) {
      return callback(err, status, true);
    });
  }, function(err, status, end) {
    if (!err && end) {
      return this.end();
    }
  });
  // If source is a file and target is a directory, then transform
  // target into a file.
  this.call(function() {
    if (!(options.target_stats && options.target_stats.isDirectory())) {
      return;
    }
    return options.target = path.resolve(options.target, path.basename(options.source));
  });
  // Copy the file if content doesn't match.
  this.call((_, callback) => {
    // Copy a file
    return misc.file.compare(options.ssh, [options.source, options.target], function(err, md5) {
      if (err && err.message.indexOf('Does not exist') !== 0) {
        // Destination may not exists
        return callback(err);
      }
      if (md5) {
        // Files are the same, we can skip copying
        return callback(null, false);
      }
      options.log({
        message: `Copy file from ${options.source} into ${options.target}`,
        level: 'WARN',
        module: 'nikita/lib/system/copy'
      });
      return misc.file.copyFile(options.ssh, options.source, options.target, function(err) {
        return callback(err, true);
      });
    });
  }, function(err, status) {
    return options.log({
      message: `File ${options.source} copied`,
      level: 'DEBUG',
      module: 'nikita/lib/system/copy'
    });
  });
  // File ownership and permissions
  return this.call(function() {
    if (options.preserve) {
      if (options.uid == null) {
        options.uid = options.source_stats.uid;
      }
    }
    if (options.preserve) {
      if (options.gid == null) {
        options.gid = options.source_stats.gid;
      }
    }
    if (options.preserve) {
      if (options.mode == null) {
        options.mode = options.source_stats.mode;
      }
    }
    this.system.chown({
      target: options.target,
      stat: options.target_stats,
      uid: options.uid,
      gid: options.gid,
      if: (options.uid != null) || (options.gid != null)
    });
    return this.system.chmod({
      target: options.target,
      stat: options.target_stats,
      mode: options.mode,
      if: options.mode != null
    });
  });
};

// ## Dependencies
fs = require('ssh2-fs');

path = require('path');

each = require('each');

misc = require('../misc');

glob = require('../misc/glob');
