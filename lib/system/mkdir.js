// Generated by CoffeeScript 2.0.3
// # `nikita.system.mkdir(options, [callback])`

// Recursively create a directory. The behavior is similar to the Unix command
// `mkdir -p`. It supports an alternative syntax where options is simply the path
// of the directory to create.

// ## Options

// * `cwd`   
//   Current working directory for relative paths.   
// * `uid`   
//   Unix user id.   
// * `gid`   
//   Unix group id.   
// * `mode`   
//   Default to "0755".   
// * `directory`   
//   Path or array of paths.   
// * `target`   
//   Alias for `directory`.   
// * `exclude`   
//   Regular expression.   
// * `parent` (boolean|object)   
//   Create parent directory with provided attributes if an object or default 
//   system options if "true", supported attributes include 'mode', 'uid', 'gid', 
//   'size', 'atime', and 'mtime'.   
// * `source`   
//   Alias for `directory`.   

// ## Callback Parameters

// * `err`   
//   Error object if any.   
// * `status`   
//   Value is "true" if directory was created or modified.   

// ## Simple usage

// ```js
// require('nikita').system.mkdir('./some/dir', function(err, status){
//   console.log(err ? err.message : "Directory created: " + status);
// });
// ```

// ## Advanced usage

// ```js
// require('nikita').system.mkdir({
//   ssh: ssh,
//   target: './some/dir',
//   uid: 'a_user',
//   gid: 'a_group'
//   mode: 0o0777 // or '777'
// }, function(err, status){
//   console.log(err ? err.message : 'Directory created: ' + status);
// });
// ```

// ## Source Code
var each, fs, misc, path, uid_gid, wrap;

module.exports = function(options, callback) {
  var modified;
  options.log({
    message: "Entering mkdir",
    level: 'DEBUG',
    module: 'nikita/lib/system/mkdir'
  });
  modified = false;
  if (options.argument != null) {
    // Validate parameters
    // options = { directory: options } if typeof options is 'string'
    options.target = options.argument;
  }
  if (options.directory == null) {
    options.directory = options.target;
  }
  if (options.directory == null) {
    options.directory = options.source;
  }
  if (options.directory == null) {
    return callback(Error('Missing target option'));
  }
  if (!options.ssh && (options.cwd === true || !options.cwd)) {
    options.cwd = process.cwd();
  }
  if (!Array.isArray(options.directory)) {
    options.directory = [options.directory];
  }
  if (options.parent === true) {
    options.parent = {};
  }
  return each(options.directory).call((directory, callback) => {
    var do_create, do_create_parent, do_stats, do_update;
    // first, we need to find which directory need to be created
    // options.log message: "Creating directory '#{directory}'", level: 'DEBUG', module: 'nikita/lib/system/mkdir'
    do_stats = function() {
      var directories, dirs, end, i, p;
      end = false;
      dirs = [];
      p = options.ssh ? path.posix : path;
      directory = options.cwd ? p.resolve(options.cwd, directory) : p.normalize(directory); // path.resolve also normalize
      // Create directory and its parent directories
      directories = directory.split('/');
      directories.shift(); // first element is empty with absolute path
      if (directories[directories.length - 1] === '') {
        directories.pop();
      }
      directories = (function() {
        var j, ref, results;
        results = [];
        for (i = j = 0, ref = directories.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
          results.push('/' + directories.slice(0, directories.length - i).join('/'));
        }
        return results;
      })();
      return each(directories).call(function(directory, i, next) {
        if (end) {
          return next();
        }
        options.log({
          message: `Stat '${directory}'`,
          level: 'DEBUG',
          module: 'nikita/lib/system/mkdir'
        });
        return fs.stat(options.ssh, directory, function(err, stat) {
          if ((err != null ? err.code : void 0) === 'ENOENT') { // if the directory is not yet created
            directory.stat = stat;
            dirs.push(directory);
            if (i === directories.length - 1) {
              return do_create_parent(dirs);
            } else {
              return next();
            }
          }
          if (stat != null ? stat.isDirectory() : void 0) {
            end = true;
            if (i === 0) {
              return do_update(stat);
            } else {
              return do_create_parent(dirs);
            }
          }
          if (err) {
            return next(err); // a file or symlink exists at this location
          } else {
            return next(Error(`Not a directory: ${JSON.stringify(directory)}`));
          }
        });
      }).next(callback);
    };
    do_create_parent = function(directories) {
      if (!(options.uid || options.guid)) {
        return do_create(directories);
      }
      return uid_gid(options, function(err) {
        if (err) {
          return next(err);
        }
        return do_create(directories);
      });
    };
    do_create = function(directories) {
      return each(directories.reverse()).call(function(directory, i, callback) {
        var attr, j, len, opts, ref, ref1, val;
        // Directory name contains variables
        // eg /\${/ on './var/cache/${user}' creates './var/cache/'
        if ((options.exclude != null) && options.exclude instanceof RegExp) {
          if (options.exclude.test(path.basename(directory))) {
            return callback();
          }
        }
        options.log({
          message: `Create directory "${directory}"`,
          level: 'DEBUG',
          module: 'nikita/lib/system/mkdir' // unless directory is options.directory
        });
        opts = {};
        ref = ['mode', 'uid', 'gid', 'size', 'atime', 'mtime'];
        for (j = 0, len = ref.length; j < len; j++) {
          attr = ref[j];
          val = i === directories.length - 1 ? options[attr] : (ref1 = options.parent) != null ? ref1[attr] : void 0;
          if (val != null) {
            opts[attr] = val;
          }
        }
        return fs.mkdir(options.ssh, directory, opts, function(err) {
          if (err) {
            return callback(err);
          }
          options.log({
            message: `Directory "${directory}" created `,
            level: 'INFO',
            module: 'nikita/lib/system/mkdir'
          });
          modified = true;
          return callback();
        }, 1000);
      }).next(function(err) {
        if (err) {
          return callback(err);
        }
        return callback();
      });
    };
    do_update = (stat) => {
      options.log({
        message: "Directory already exists",
        level: 'INFO',
        module: 'nikita/lib/system/mkdir'
      });
      this.system.chown({
        target: directory,
        stat: stat,
        uid: options.uid,
        gid: options.gid,
        if: (options.uid != null) || (options.gid != null)
      });
      this.system.chmod({
        target: directory,
        stat: stat,
        mode: options.mode,
        if: options.mode != null
      });
      return this.next(function(err, moded) {
        if (err) {
          return callback(err);
        }
        if (moded) {
          modified = true;
        }
        return callback();
      });
    };
    return do_stats();
  }).next(function(err) {
    return callback(err, modified);
  });
};

// ## Dependencies
fs = require('ssh2-fs');

path = require('path');

each = require('each');

misc = require('../misc');

wrap = require('../misc/wrap');

uid_gid = require('../misc/uid_gid');
