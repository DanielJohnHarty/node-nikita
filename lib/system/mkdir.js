// Generated by CoffeeScript 2.2.4
// # `nikita.system.mkdir(options, [callback])`

// Recursively create a directory. The behavior is similar to the Unix command
// `mkdir -p`. It supports an alternative syntax where options is simply the path
// of the directory to create.

// ## Options

// * `cwd`   
//   Current working directory for relative paths.   
// * `uid`   
//   Unix user id.   
// * `gid`   
//   Unix group id.   
// * `mode`   
//   Default to "0755".   
// * `directory`   
//   Path or array of paths.   
// * `target`   
//   Alias for `directory`.   
// * `exclude`   
//   Regular expression.   
// * `parent` (boolean|object)   
//   Create parent directory with provided attributes if an object or default 
//   system options if "true", supported attributes include 'mode', 'uid', 'gid', 
//   'size', 'atime', and 'mtime'.   
// * `source`   
//   Alias for `directory`.   

// ## Callback Parameters

// * `err`   
//   Error object if any.   
// * `status`   
//   Value is "true" if directory was created or modified.   

// ## Simple usage

// ```js
// require('nikita').system.mkdir('./some/dir', function(err, status){
//   console.info(err ? err.message : "Directory created: " + status);
// });
// ```

// ## Advanced usage

// ```js
// require('nikita').system.mkdir({
//   ssh: ssh,
//   target: './some/dir',
//   uid: 'a_user',
//   gid: 'a_group'
//   mode: 0o0777 // or '777'
// }, function(err, status){
//   console.info(err ? err.message : 'Directory created: ' + status);
// });
// ```

// ## Source Code
var each, misc, path, wrap;

module.exports = function(options, callback) {
  var directory, j, len, p, ref, ssh, state;
  options.log({
    message: "Entering mkdir",
    level: 'DEBUG',
    module: 'nikita/lib/system/mkdir'
  });
  // SSH connection
  ssh = this.ssh(options.ssh);
  p = ssh ? path.posix : path;
  if (options.argument != null) {
    // Validate options
    options.target = options.argument;
  }
  if (options.directory == null) {
    options.directory = options.target;
  }
  if (options.directory == null) {
    options.directory = options.source;
  }
  if (options.directory == null) {
    return callback(Error('Missing target option'));
  }
  if (!ssh && (options.cwd === true || !options.cwd)) {
    options.cwd = process.cwd();
  }
  if (!Array.isArray(options.directory)) {
    options.directory = [options.directory];
  }
  if (options.parent === true) {
    options.parent = {};
  }
  if (ssh) {
    ref = options.directory;
    for (j = 0, len = ref.length; j < len; j++) {
      directory = ref[j];
      if (!p.isAbsolute(directory)) {
        throw Error(`Target path not absolute with SSH: ${JSON.stringify(directory)}`);
      }
    }
  }
  // State
  state = false;
  return each(options.directory).call((directory, callback) => {
    var do_create, do_create_parent, do_stats, do_update;
    // first, we need to find which directory need to be created
    // options.log message: "Creating directory '#{directory}'", level: 'DEBUG', module: 'nikita/lib/system/mkdir'
    do_stats = () => {
      var directories, dirs, end, i;
      end = false;
      dirs = [];
      directory = options.cwd ? p.resolve(options.cwd, directory) : p.normalize(directory); // path.resolve also normalize
      // Create directory and its parent directories
      directories = directory.split('/');
      directories.shift(); // first element is empty with absolute path
      if (directories[directories.length - 1] === '') {
        directories.pop();
      }
      directories = (function() {
        var k, ref1, results;
        results = [];
        for (i = k = 0, ref1 = directories.length; (0 <= ref1 ? k < ref1 : k > ref1); i = 0 <= ref1 ? ++k : --k) {
          results.push('/' + directories.slice(0, directories.length - i).join('/'));
        }
        return results;
      })();
      return each(directories).call((directory, i, next) => {
        options.log({
          message: `Stat '${directory}'`,
          level: 'DEBUG',
          module: 'nikita/lib/system/mkdir'
        });
        return this.fs.stat({
          ssh: options.ssh,
          target: directory
        }, function(err, stat) {
          if ((err != null ? err.code : void 0) === 'ENOENT') { // if the directory is not yet created
            directory.stat = stat;
            dirs.push(directory);
            if (i === directories.length - 1) {
              return do_create_parent(dirs);
            } else {
              return next();
            }
          }
          if (stat != null ? stat.isDirectory() : void 0) {
            end = true;
            if (i === 0) {
              return do_update(stat);
            } else {
              return do_create_parent(dirs);
            }
          }
          if (err) {
            return next(err); // a file or symlink exists at this location
          } else {
            return next(Error(`Not a directory: ${JSON.stringify(directory)}`));
          }
        });
      }).next(callback);
    };
    do_create_parent = (directories) => {
      return this.system.uid_gid({
        uid: options.uid,
        gid: options.gid
      }, function(err, status, {uid, gid}) {
        options.uid = uid;
        options.gid = gid;
        return do_create(directories);
      });
    };
    do_create = (directories) => {
      return each(directories.reverse()).call((directory, i, callback) => {
        var attr, k, len1, opts, ref1, ref2, val;
        // Directory name contains variables
        // eg /\${/ on './var/cache/${user}' creates './var/cache/'
        if ((options.exclude != null) && options.exclude instanceof RegExp) {
          if (options.exclude.test(path.basename(directory))) {
            return callback();
          }
        }
        options.log({
          message: `Create directory "${directory}"`,
          level: 'DEBUG',
          module: 'nikita/lib/system/mkdir' // unless directory is options.directory
        });
        opts = {};
        ref1 = ['mode', 'uid', 'gid', 'size', 'atime', 'mtime'];
        for (k = 0, len1 = ref1.length; k < len1; k++) {
          attr = ref1[k];
          val = i === directories.length - 1 ? options[attr] : (ref2 = options.parent) != null ? ref2[attr] : void 0;
          if (val != null) {
            opts[attr] = val;
          }
        }
        return this.fs.mkdir({
          ssh: options.ssh,
          target: directory
        }, opts, function(err) {
          if (err) {
            return callback(err);
          }
          options.log({
            message: `Directory "${directory}" created `,
            level: 'INFO',
            module: 'nikita/lib/system/mkdir'
          });
          state = true;
          return callback();
        });
      }).next(function(err) {
        if (err) {
          return callback(err);
        }
        return callback();
      });
    };
    do_update = (stat) => {
      options.log({
        message: "Directory already exists",
        level: 'INFO',
        module: 'nikita/lib/system/mkdir'
      });
      this.system.chown({
        target: directory,
        stat: stat,
        uid: options.uid,
        gid: options.gid,
        if: (options.uid != null) || (options.gid != null)
      });
      this.system.chmod({
        target: directory,
        stat: stat,
        mode: options.mode,
        if: options.mode != null
      });
      return this.next(function(err, moded) {
        if (err) {
          return callback(err);
        }
        if (moded) {
          state = true;
        }
        return callback();
      });
    };
    return do_stats();
  }).next(function(err) {
    return callback(err, state);
  });
};

// ## Dependencies
path = require('path').posix;

each = require('each');

misc = require('../misc');

wrap = require('../misc/wrap');
