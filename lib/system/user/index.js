// Generated by CoffeeScript 2.0.2
// # `nikita.system.user.add(options, [callback])`

// Create or modify a Unix user.

// If the user home is provided, its parent directory will be created with root 
// ownerships and 0644 permissions unless it already exists.

// ## Options

// * `arch_chroot` (boolean|string)   
//   Run this command inside a root directory with the arc-chroot command or any
//   provided string, require the "rootdir" option if activated.
// * `rootdir` (string)   
//   Path to the mount point corresponding to the root directory, required if
//   the "arch_chroot" option is activated.
// * `comment`   
//   Short description of the login.
// * `expiredate`   
//   The date on which the user account is disabled.
// * `gid`   
//   Group name or number of the user´s initial login group.
// * `groups`   
//   List of supplementary groups which the user is also a member of.
// * `home`   
//   Value for the user´s login directory, default to the login name appended to "BASE_DIR".
// * `inactive`   
//   The number of days after a password has expired before the account will be
//   disabled.
// * `name`   
//   Login name of the user.
// * `no_home_ownership` (boolean)   
//   Disable ownership on home directory which default to the "uid" and "gid"
//   options, default is "false".
// * `password`   
//   The unencrypted password.
// * `password_sync`   
//   Synchronize password, default is "true".
// * `shell`   
//   Path to the user shell, set to "/sbin/nologin" if "false", "/bin/bash" if
//   true or default to the system shell value in "/etc/default/useradd", by
//   default "/bin/bash".
// * `skel`   
//   The skeleton directory, which contains files and directories to be copied in
//   the user´s home directory, when the home directory is created by useradd.
// * `system`   
//   Create a system account, such user are not created with a home by default,
//   set the "home" option if we it to be created.
// * `uid`   
//   Numerical value of the user´s ID, must not exist.

// ## Callback parameters

// * `err`   
//   Error object if any.
// * `status`   
//   Value is "true" if user was created or modified.

// ## Example

// ```coffee
// require('nikita').user({
//   name: 'a_user',
//   system: true,
//   uid: 490,
//   gid: 10,
//   comment: 'A System User'
// }, function(err, created){
//   console.log(err ? err.message : 'User created: ' + !!created);
// })
// ```

// The result of the above action can be viewed with the command
// `cat /etc/passwd | grep myself` producing an output similar to
// "a\_user:x:490:490:A System User:/home/a\_user:/bin/bash". You can also check
// you are a member of the "wheel" group (gid of "10") with the command
// `id a\_user` producing an output similar to 
// "uid=490(hive) gid=10(wheel) groups=10(wheel)".

// ## Source Code
var fs, misc, path, string, uid_gid;

module.exports = function(options) {
  var groups_info, modified, user_info;
  options.log({
    message: "Entering user",
    level: 'DEBUG',
    module: 'nikita/lib/system/user/add'
  });
  if (options.argument != null) {
    options.name = options.argument;
  }
  if (!options.name) {
    throw Error("Option 'name' is required");
  }
  if (options.shell === false) {
    options.shell = "/sbin/nologin";
  }
  if (options.shell === true) {
    options.shell = "/bin/bash";
  }
  if (options.system == null) {
    options.system = false;
  }
  if (options.gid == null) {
    options.gid = null;
  }
  if (options.password_sync == null) {
    options.password_sync = true;
  }
  if (typeof options.groups === 'string') {
    options.groups = options.groups.split(',');
  }
  if (typeof options.shell === "function" ? options.shell(typeof options.shell !== 'string') : void 0) {
    throw Error(`Invalid option 'shell': ${JSON.strinfigy(options.shell)}`);
  }
  modified = false;
  user_info = groups_info = null;
  this.call(function(_, callback) {
    // Note, we shall be able to remove the call to "uid_gid"
    // because it itself call "uid_gid.passwd" and "uid_gid.group"
    // which are called below
    return uid_gid(options, callback);
  });
  this.call(function(_, callback) {
    options.log({
      message: `Get user information for ${options.name}`,
      level: 'DEBUG',
      module: 'nikita/lib/system/user/add'
    });
    options.store.cache_passwd = void 0; // Clear cache if any
    return uid_gid.passwd(options.ssh, options.store, function(err, users) {
      if (err) {
        return callback(err);
      }
      options.log({
        message: `Got ${JSON.stringify(users[options.name])}`,
        level: 'INFO',
        module: 'nikita/lib/system/user/add'
      });
      user_info = users[options.name];
      return callback();
    });
  });
  this.call({
    // Get group information if
    // * user already exists
    // * we need to compare groups membership
    if: function() {
      return user_info && options.groups;
    }
  }, function(_, callback) {
    options.store.cache_group = null; // Clear cache if any
    return uid_gid.group(options.ssh, options.store, function(err, groups) {
      if (err) {
        return callback(err);
      }
      groups_info = groups;
      return callback();
    });
  });
  this.call({
    if: options.home
  }, function() {
    return this.system.mkdir({
      unless_exists: path.dirname(options.home),
      target: path.dirname(options.home),
      uid: 0,
      gid: 0,
      mode: 0o0644 // Same as '/home'
    });
  });
  this.call({
    unless: (function() {
      return user_info;
    })
  }, function() {
    var cmd;
    cmd = 'useradd';
    if (options.system) {
      cmd += " -r";
    }
    if (!options.home) {
      cmd += " -M";
    }
    if (options.home) {
      cmd += " -m";
    }
    if (options.home) {
      cmd += ` -d ${options.home}`;
    }
    if (options.shell) {
      cmd += ` -s ${options.shell}`;
    }
    if (options.comment) {
      cmd += ` -c ${string.escapeshellarg(options.comment)}`;
    }
    if (options.uid) {
      cmd += ` -u ${options.uid}`;
    }
    if (options.gid) {
      cmd += ` -g ${options.gid}`;
    }
    if (options.expiredate) {
      cmd += ` -e ${options.expiredate}`;
    }
    if (options.inactive) {
      cmd += ` -f ${options.inactive}`;
    }
    if (options.groups) {
      cmd += ` -G ${options.groups.join(',')}`;
    }
    if (options.skel) {
      cmd += ` -k ${options.skel}`;
    }
    cmd += ` ${options.name}\n`;
    if (options.home) {
      cmd += `chown ${options.name}. ${options.home}`;
    }
    return this.system.execute({
      cmd: cmd,
      code_skipped: 9,
      arch_chroot: options.arch_chroot,
      rootdir: options.rootdir,
      sudo: options.sudo
    }, function(err, status, stdout) {
      if (err) {
        throw err;
      }
      return options.log({
        message: "User defined elsewhere than '/etc/passwd', exit code is 9",
        level: 'WARN',
        module: 'nikita/lib/system/user/add'
      });
    });
  });
  // @system.chown
  //   if: options.home?
  //   if_exists: options.home
  //   unless: options.no_home_ownership
  //   target: options.home
  //   uid: options.uid
  //   gid: options.gid
  this.call({
    if: (function() {
      return user_info;
    })
  }, function() {
    var changed, cmd, group, i, j, k, len, len1, ref, ref1;
    changed = [];
    ref = ['uid', 'home', 'shell', 'comment', 'gid'];
    for (i = 0, len = ref.length; i < len; i++) {
      k = ref[i];
      if ((options[k] != null) && user_info[k] !== options[k]) {
        changed.push(k);
      }
    }
    if (options.groups) {
      ref1 = options.groups;
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        group = ref1[j];
        if (!groups_info[group]) {
          throw Error(`Group does not exist: ${group}`);
        }
        if (groups_info[group].user_list.indexOf(options.name) === -1) {
          changed.push('groups');
        }
      }
    }
    options.log(changed.length ? {
      message: `User ${options.name} modified`,
      level: 'WARN',
      module: 'nikita/lib/system/user/add'
    } : {
      message: `User ${options.name} not modified`,
      level: 'DEBUG',
      module: 'nikita/lib/system/user/add'
    });
    cmd = 'usermod';
    if (options.home) {
      cmd += ` -d ${options.home}`;
    }
    if (options.shell) {
      cmd += ` -s ${options.shell}`;
    }
    if (options.comment != null) {
      cmd += ` -c ${string.escapeshellarg(options.comment)}`;
    }
    if (options.gid) {
      cmd += ` -g ${options.gid}`;
    }
    if (options.groups) {
      cmd += ` -G ${options.groups.join(',')}`;
    }
    if (options.uid) {
      cmd += ` -u ${options.uid}`;
    }
    cmd += ` ${options.name}`;
    this.system.execute({
      cmd: cmd,
      if: changed.length,
      arch_chroot: options.arch_chroot,
      rootdir: options.rootdir,
      sudo: options.sudo
    }, function(err) {
      if ((err != null ? err.code : void 0) === 8) {
        throw Error(`User ${options.name} is logged in`);
      }
    });
    return this.system.chown({
      if: options.home && (options.uid || options.gid),
      if_exists: options.home,
      unless: options.no_home_ownership,
      target: options.home,
      uid: options.uid,
      gid: options.gid
    });
  });
  return this.call(function() {
    // TODO, detect changes in password
    // echo #{options.password} | passwd --stdin #{options.name}
    return this.system.execute({
      cmd: `hash=$(echo ${options.password} | openssl passwd -1 -stdin)\nusermod --pass="$hash" ${options.name}`,
      if: options.password_sync && options.password,
      arch_chroot: options.arch_chroot,
      rootdir: options.rootdir,
      sudo: options.sudo
    }, function(err, modified) {
      if (err) {
        throw err;
      }
      if (modified) {
        return options.log({
          message: "Password modified",
          level: 'WARN',
          module: 'nikita/lib/system/user/add'
        });
      }
    });
  });
};

// ## Dependencies
path = require('path');

fs = require('ssh2-fs');

misc = require('../../misc');

string = require('../../misc/string');

uid_gid = require('../../misc/uid_gid');
