// Generated by CoffeeScript 2.3.1
// # `nikita.system.info.disks`

// Expose disk information. Internally, it parse the result of the "df" command. 
// The properties "total", "used" and "available" are expressed in bytes.

// ## Options

// There are no required options.

// - `output` ([string])   
//   The list of properties to be returned; valid properties are 'source',
//   'fstype', 'itotal', 'iused', 'iavail', 'ipcent', 'size', 'used', 'avail',
//   'pcent' and 'target'; default to all of them.

// ## Callback

// The following properties are available:

// - `filesystem` (string)   
//   The source of the mount point, usually a device; alias of the "source"
//   property of the `df` command.
// - `total` (integer)   
//   Total space available in bytes; derivated from the "itotal" output property of
//   the `df` command.
// - `used` (integer)   
//   Total space used in bytes; derivated from the "iused" output property of
//   the `df` command.
// - `available` (integer)   
//   Total space available in bytes; derivated from the "iavail" output property of
//   the `df` command.
// - `available_pourcent` (string)   
//   Total space available in pourcentage; alias of the "ipcent" output
//   property of the `df` command.
// - `mountpoint` (string)
//   The mount point location; alias of the "target" output property of the `df`
//   command.

// Additionnaly, the `df` property export the low level information obtained from
// the `df` command:

// - `disks[].df.source` (string)   
//   The source of the mount point, usually a device; correspond to the
//   "Filesystem" header of the `df` command.
// - `disks[].df.fstype` (string)   
//   File system type; correspond to the "Type" header of the `df` command.
// - `disks[].df.itotal` (integer)   
//   Total number of inodes, in bytes; correspond to the "Inodes" header of the
//   `df` command.
// - `disks[].df.iused` (integer)   
//   Number of used inodes, in bytes; correspond to the "IUsed" header of the `df`
//   command.
// - `disks[].df.iavail` (integer)   
//   Number of available inodes, in bytes; correspond to the "IFree" header of the
//   `df` command.
// - `disks[].df.ipcent` (string)   
//   Percentage of iused divided by itotal; correspond to the "IUse%" header of the
//   `df` command.
// - `disks[].df.size` (integer)   
//   The total space available, measured in 1kB units; correspond to the
//   "1K-blocks" header of the `df` command.
// - `disks[].df.used` (integer)   
//   Number of used blocks; correspond to the "Used" header of the `df` command.
// - `disks[].df.avail` (integer)   
//   Number of available blocks; correspond to the
//   "Avail" header of the `df` command.
// - `disks[].df.pcent` (float)   
//   Percentage of used divided by size; correspond to the
//   "Use%" header of the `df` command.
// - `disks[].df.target` (string)   
//   The mount point; correspond to the
//   "Mounted on" header of the `df` command.

// Note that if you add The Used and Available columns you don't get the total size
// shown; this is because of blocks that are reserved for root as shown in the
// output of `dumpe2fs` as "Reserved block count:". Those blocks can only be used by
// root, the idea behind this is that if a user fills up the filesystem, critical
// stuff still works and root can fix the problem.

// ## Example

// ```js
// require('nikita')
// .system.info.disks(function(err, {disks}){
//   if(err) throw err;
//   disks.forEach(function(disk){
//     console.log('File system:', disk.filesystem)
//     console.log('Total space:', disk.total)
//     console.log('Used space:', disk.used)
//     console.log('Available space:', disk.available)
//     console.log('Available space (pourcent):', disk.available_pourcent)
//     console.log('Mountpoint:', disk.mountpoint)
//   })
// })
// ```

// Here is how the output may look like:

// ```json
// [ { filesystem: '/dev/sda1',
//     total: '8255928',
//     used: '1683700',
//     available: '6152852',
//     available_pourcent: '22%',
//     mountpoint: '/' },
//   { filesystem: 'tmpfs',
//     total: '961240',
//     used: '0',
//     available: '961240',
//     available_pourcent: '0%',
//     mountpoint: '/dev/shm' } ]
// ```

// ## Source Code
var string;

module.exports = function(options, callback) {
  if (options.output == null) {
    options.output = ['source', 'fstype', 'itotal', 'iused', 'iavail', 'ipcent', 'size', 'used', 'avail', 'pcent', 'target'];
  }
  return this.system.execute({
    header: 'Disk',
    cmd: `df --output='${options.output.join(',')}'`
  }, function(err, {stdout}) {
    var disk, disks, i, line, property;
    if (err) {
      return callback(err);
    }
    disks = (function() {
      var j, k, len, len1, ref, ref1, results;
      ref = string.lines(stdout);
      results = [];
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        line = ref[i];
        if (i === 0) {
          continue;
        }
        if (/^\s*$/.test(line)) {
          continue;
        }
        line = line.split(/\s+/);
        disk = {
          df: {}
        };
        ref1 = options.output;
        for (i = k = 0, len1 = ref1.length; k < len1; i = ++k) {
          property = ref1[i];
          disk.df[property] = line[i];
        }
        disk.filesystem = disk.df.source;
        disk.total = disk.df.itotal * 1024;
        disk.used = disk.df.iused * 1024;
        disk.available = disk.df.avail * 1024;
        disk.available_pourcent = disk.df.pcent;
        disk.mountpoint = disk.df.target;
        results.push(disk);
      }
      return results;
    })();
    return callback(null, {
      disks: disks
    });
  });
};

// ## Dependencies
string = require('../../misc/string');
