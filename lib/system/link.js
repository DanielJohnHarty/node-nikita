// Generated by CoffeeScript 2.0.3
// # `nikita.system.link(options, [callback])`

// Create a symbolic link and it's parent directories if they don't yet
// exist.

// Note, it is valid for the "source" file to not exist.

// ## Options

// * `source`   
//   Referenced file to be linked.   
// * `target`   
//   Symbolic link to be created.   
// * `exec`   
//   Create an executable file with an `exec` command.   
// * `mode`   
//   Default to `0o0755`.   

// ## Callback Parameters

// * `err`   
//   Error object if any.   
// * `status`   
//   Value is "true" if link was created or modified.   

// ## Example

// ```js
// require('nikita').system.link({
//   source: __dirname,
//   target: '/tmp/a_link'
// }, function(err, status){
//   console.log(err ? err.message : 'Link created: ' + status);
// });
// ```

// ## Source Code
var fs, path;

module.exports = function(options, callback) {
  var do_dispatch, do_end, do_mkdir, exec_create, exec_exists, linked, ssh, sym_create, sym_exists;
  options.log({
    message: "Entering link",
    level: 'DEBUG',
    module: 'nikita/lib/system/link'
  });
  // SSH connection
  ssh = this.ssh(options.ssh);
  linked = 0;
  sym_exists = function(options, callback) {
    return fs.readlink(ssh, options.target, function(err, resolvedPath) {
      if (err) {
        return callback(null, false);
      }
      if (resolvedPath === options.source) {
        return callback(null, true);
      }
      return fs.unlink(ssh, options.target, function(err) {
        if (err) {
          return callback(err);
        }
        return callback(null, false);
      });
    });
  };
  sym_create = function(options, callback) {
    return fs.symlink(ssh, options.source, options.target, function(err) {
      if (err) {
        return callback(err);
      }
      linked++;
      return callback();
    });
  };
  exec_exists = function(options, callback) {
    return fs.exists(ssh, options.target, function(err, exists) {
      if (!exists) {
        return callback(null, false);
      }
      return fs.readFile(ssh, options.target, 'utf8', function(err, content) {
        var exec_cmd;
        if (err) {
          return callback(err);
        }
        exec_cmd = /exec (.*) \$@/.exec(content)[1];
        return callback(null, exec_cmd && exec_cmd === options.source);
      });
    });
  };
  exec_create = function(options, callback) {
    var content;
    content = `#!/bin/bash\nexec ${options.source} $@`;
    return fs.writeFile(ssh, options.target, content, function(err) {
      if (err) {
        return callback(err);
      }
      return fs.chmod(ssh, options.target, options.mode, function(err) {
        if (err) {
          return callback(err);
        }
        linked++;
        return callback();
      });
    });
  };
  if (!options.source) {
    return callback(Error(`Missing source, got ${JSON.stringify(options.source)}`));
  }
  if (!options.target) {
    return callback(Error(`Missing target, got ${JSON.stringify(options.target)}`));
  }
  if (options.mode == null) {
    options.mode = 0o0755;
  }
  do_mkdir = () => {
    return this.system.mkdir({
      ssh: ssh,
      target: path.dirname(options.target)
    }, function(err, created) {
      if (err && err.code !== 'EEXIST') {
        // It is possible to have collision if to symlink
        // have the same parent directory
        return callback(err);
      }
      return do_dispatch();
    });
  };
  do_dispatch = function() {
    if (options.exec) {
      return exec_exists(options, function(err, exists) {
        if (exists) {
          return do_end();
        }
        return exec_create(options, do_end);
      });
    } else {
      return sym_exists(options, function(err, exists) {
        if (exists) {
          return do_end();
        }
        return sym_create(options, do_end);
      });
    }
  };
  do_end = function() {
    return callback(null, linked);
  };
  return do_mkdir();
};

// ## Dependencies
fs = require('ssh2-fs');

path = require('path');
