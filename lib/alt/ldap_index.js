// Generated by CoffeeScript 2.0.2
// # `nikita.ldap.index(options, [goptions], callback)`

// Create new [index](index) for the OpenLDAP server.   

// This implementation currently doesn't execute remote SSH commands. Instead, it
// connects directly to the LDAP database and thus requires a specific port to be
// accessible.   

// ## Options

// *   `indexes`   
//     Object with keys mapping to indexed attributes and values mapping to indices
//     ("pres", "approx", "eq", "sub" and 'special').   
// *   `url`   
//     Specify URI referring to the ldap server, alternative to providing an
//     [ldapjs client] instance.   
// *   `binddn`   
//     Distinguished Name to bind to the LDAP directory, alternative to providing
//     an [ldapjs client] instance.   
// *   `passwd`   
//     Password for simple authentication, alternative to providing an
//     [ldapjs client] instance.   
// *   `ldap`   
//     Instance of an pldapjs client][ldapclt], alternative to providing the `url`,
//     `binddn` and `passwd` connection properties.   
// *   `unbind`   
//     Close the ldap connection, default to false if connection is an
//     [ldapjs client][ldapclt] instance.   
// *   `name`   
//     Distinguish name storing the "olcAccess" property, using the database adress
//     (eg: "olcDatabase={2}bdb,cn=config").   
// *   `overwrite`   
//     Overwrite existing "olcAccess", default is to merge.   

// ## Example

// ```js
// require('nikita/alt/ldap.index')({
//   url: 'ldap://openldap.server/',
//   binddn: 'cn=admin,cn=config',
//   passwd: 'password',
//   name: 'olcDatabase={2}bdb,cn=config',
//   indexes: {
//     krbPrincipalName: 'sub,eq'
//   }
// }, function(err, modified){
//   console.log(err ? err.message : "Index modified: " + !!modified);
// });
// ```
var ldap, misc, wrap;

module.exports = function(goptions, options, callback) {
  return wrap(arguments, function(options, next) {
    var client, connect, do_diff, end, get, parse, replace, stringifiy, unbind, updated;
    client = null;
    updated = false;
    connect = function() {
      var ref, ref1, ref2;
      // if options.ldap instanceof ldap.client
      if (((ref = options.ldap) != null ? (ref1 = ref.url) != null ? (ref2 = ref1.protocol) != null ? ref2.indexOf('ldap') : void 0 : void 0 : void 0) === 0) {
        client = options.ldap;
        return get();
      }
      // Open and bind connection
      client = ldap.createClient({
        url: options.url
      });
      return client.bind(options.binddn, options.passwd, function(err) {
        if (err) {
          return end(err);
        }
        return get();
      });
    };
    get = function() {
      return client.search('olcDatabase={2}bdb,cn=config', {
        scope: 'base',
        attributes: ['olcDbIndex']
      }, function(err, search) {
        var olcDbIndex;
        olcDbIndex = null;
        search.on('searchEntry', function(entry) {
          return olcDbIndex = entry.object.olcDbIndex;
        });
        return search.on('end', function() {
          return parse(olcDbIndex);
        });
      });
    };
    parse = function(arIndex) {
      var index, indexes, j, k, len, v;
      indexes = {};
      for (j = 0, len = arIndex.length; j < len; j++) {
        index = arIndex[j];
        [k, v] = index.split(' ');
        indexes[k] = v;
      }
      return do_diff(indexes);
    };
    do_diff = function(orgp) {
      var i, j, newp, nkl, okl, ref;
      if (!options.overwrite) {
        newp = misc.merge({}, orgp, options.indexes);
      } else {
        newp = options.indexes;
      }
      okl = Object.keys(orgp).sort();
      nkl = Object.keys(newp).sort();
      for (i = j = 0, ref = Math.min(okl.length, nkl.length); 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        if (i === okl.length || i === nkl.length || okl[i] !== nkl[i] || orgp[okl[i]] !== newp[nkl[i]]) {
          updated = true;
          break;
        }
      }
      if (updated) {
        return stringifiy(newp);
      } else {
        return unbind();
      }
    };
    stringifiy = function(perms) {
      var indexes, k, v;
      indexes = [];
      for (k in perms) {
        v = perms[k];
        indexes.push(`${k} ${v}`);
      }
      return replace(indexes);
    };
    replace = function(indexes) {
      var change;
      change = new ldap.Change({
        operation: 'replace',
        modification: {
          olcDbIndex: indexes
        }
      });
      return client.modify(options.name, change, function(err) {
        return unbind(err);
      });
    };
    unbind = function(err) {
      var ref, ref1, ref2;
      if (((ref = options.ldap) != null ? (ref1 = ref.url) != null ? (ref2 = ref1.protocol) != null ? ref2.indexOf('ldap') : void 0 : void 0 : void 0) === 0 && !options.unbind) {
        // return end err if options.ldap instanceof ldap.client and not options.unbind
        return end(err);
      }
      return client.unbind(function(e) {
        if (e) {
          return next(e);
        }
        return end(err);
      });
    };
    end = function(err) {
      return next(err, updated);
    };
    return connect();
  });
};

// ## Dependencies
ldap = require('ldapjs');

misc = require('../misc');

wrap = require('../misc/wrap');

// [index]: http://www.zytrax.com/books/ldap/apa/indeces.html
