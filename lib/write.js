// Generated by CoffeeScript 1.8.0
var chmod, chown, diff, each, eco, fs, misc, mkdir, nunjucks, pad, path, quote, string, wrap;

module.exports = function(goptions, options, callback) {
  return wrap(arguments, function(options, next) {
    var append, between, content, destination, destinationHash, do_backup, do_diff, do_end, do_eof, do_ownership, do_permissions, do_read_destination, do_read_source, do_render, do_replace_partial, do_write, from, modified, to, w, write, _i, _len, _ref;
    modified = false;
    if (!((options.source || (options.content != null)) || options.replace || ((_ref = options.write) != null ? _ref.length : void 0))) {
      return next(new Error('Missing source or content'));
    }
    if (options.source && options.content) {
      return next(new Error('Define either source or content'));
    }
    if (!options.destination) {
      return next(new Error('Missing destination'));
    }
    if (options.content && Buffer.isBuffer(options.content)) {
      options.content = options.content.toString();
    }
    if (options.diff == null) {
      options.diff = options.diff || !!options.stdout;
    }
    if (options.engine == null) {
      options.engine = 'eco';
    }
    switch (options.eof) {
      case 'unix':
        options.eof = "\n";
        break;
      case 'mac':
        options.eof = "\r";
        break;
      case 'windows':
        options.eof = "\r\n";
        break;
      case 'unicode':
        options.eof = "\u2028";
    }
    destination = null;
    destinationHash = null;
    content = null;
    from = to = between = null;
    append = options.append;
    write = options.write;
    if (write == null) {
      write = [];
    }
    if ((options.from != null) || (options.to != null) || (options.match != null) || (options.replace != null) || (options.before != null)) {
      write.push({
        from: options.from,
        to: options.to,
        match: options.match,
        replace: options.replace,
        append: options.append,
        before: options.before
      });
    }
    for (_i = 0, _len = write.length; _i < _len; _i++) {
      w = write[_i];
      if ((w.from == null) && (w.to == null) && (w.match == null) && (w.replace != null)) {
        w.match = w.replace;
      }
    }
    do_read_source = function() {
      var source, ssh;
      if (options.content != null) {
        content = options.content;
        if (typeof content === 'number') {
          content = "" + content;
        }
        return do_read_destination();
      }
      source = options.source || options.destination;
      if (typeof options.log === "function") {
        options.log("Mecano `write`: force local source is \"" + (options.local_source ? 'true' : 'false') + "\"");
      }
      if (typeof options.log === "function") {
        options.log("Mecano `write`: source is \"" + options.source + "\"");
      }
      ssh = options.local_source ? null : options.ssh;
      return fs.exists(ssh, source, function(err, exists) {
        if (err) {
          return next(err);
        }
        if (!exists) {
          if (options.source) {
            return next(new Error("Source does not exist: " + (JSON.stringify(options.source))));
          }
          content = '';
          return do_read_destination();
        }
        if (typeof options.log === "function") {
          options.log("Mecano `write`: read source");
        }
        return fs.readFile(ssh, source, 'utf8', function(err, src) {
          if (err) {
            return next(err);
          }
          content = src;
          return do_read_destination();
        });
      });
    };
    do_read_destination = function() {
      var do_mkdir, do_read, exists;
      if (typeof options.destination === 'function') {
        return do_render();
      }
      if (typeof options.log === "function") {
        options.log("Mecano `write`: destination is \"" + options.destination + "\"");
      }
      exists = function() {
        if (typeof options.log === "function") {
          options.log("Mecano `write`: stat destination");
        }
        return fs.stat(options.ssh, options.destination, function(err, stat) {
          if ((err != null ? err.code : void 0) === 'ENOENT') {
            return do_mkdir();
          }
          if (err) {
            return next(err);
          }
          if (stat.isDirectory()) {
            options.destination = "" + options.destination + "/" + (path.basename(options.source));
            return fs.stat(options.ssh, options.destination, function(err, stat) {
              if ((err != null ? err.code : void 0) === 'ENOENT') {
                return do_render();
              }
              if (err) {
                return next(err);
              }
              if (!stat.isFile()) {
                return next(new Error("Destination is not a file: " + options.destination));
              }
              return do_read();
            });
          } else {
            return do_read();
          }
        });
      };
      do_mkdir = function() {
        if (typeof options.log === "function") {
          options.log("Mecano `write`: mkdir");
        }
        return mkdir({
          ssh: options.ssh,
          destination: path.dirname(options.destination),
          uid: options.uid,
          gid: options.gid,
          mode: options.mode,
          not_if_exists: path.dirname(options.destination)
        }, function(err, created) {
          if (err) {
            return next(err);
          }
          return do_render();
        });
      };
      do_read = function() {
        if (typeof options.log === "function") {
          options.log("Mecano `write`: read destination");
        }
        return fs.readFile(options.ssh, options.destination, 'utf8', function(err, dest) {
          if (err) {
            return next(err);
          }
          if (options.diff) {
            destination = dest;
          }
          destinationHash = string.hash(dest);
          return do_render();
        });
      };
      return exists();
    };
    do_render = function() {
      var err;
      if (options.context == null) {
        return do_replace_partial();
      }
      if (typeof options.log === "function") {
        options.log("Mecano `write`: rendering with " + options.engine);
      }
      try {
        switch (options.engine) {
          case 'nunjunks':
            content = nunjucks.renderString(content.toString(), options.context);
            break;
          case 'eco':
            content = eco.render(content.toString(), options.context);
            break;
          default:
            return next(Error("Invalid engine: " + options.engine));
        }
        if (options.skip_empty_lines != null) {
          content = content.replace(/(\r\n|[\n\r\u0085\u2028\u2029])\s*(\r\n|[\n\r\u0085\u2028\u2029])/g, "$1");
        }
      } catch (_error) {
        err = _error;
        if (typeof err === 'string') {
          err = new Error(err);
        }
        return next(err);
      }
      return do_replace_partial();
    };
    do_replace_partial = function() {
      var before, linebreak, opts, orgContent, pos, posoffset, res, _j, _len1;
      if (!write.length) {
        return do_eof();
      }
      if (typeof options.log === "function") {
        options.log("Mecano `write`: replace");
      }
      for (_j = 0, _len1 = write.length; _j < _len1; _j++) {
        opts = write[_j];
        if (opts.match) {
          if (typeof opts.match === 'string') {
            opts.match = RegExp(quote(opts.match), 'mg');
          }
          if (opts.match instanceof RegExp) {
            if (opts.match.test(content)) {
              content = content.replace(opts.match, opts.replace);
              append = false;
            } else if (opts.before && typeof opts.replace === 'string') {
              if (typeof opts.before === "string") {
                opts.before = new RegExp("^.*" + opts.before + ".*$", 'mg');
              }
              if (opts.before instanceof RegExp) {
                posoffset = 0;
                orgContent = content;
                while ((res = opts.before.exec(orgContent)) !== null) {
                  pos = posoffset + res.index;
                  content = content.slice(0, pos) + opts.replace + '\n' + content.slice(pos);
                  posoffset += opts.replace.length + 1;
                  if (!opts.before.global) {
                    break;
                  }
                }
                before = false;
              } else {
                linebreak = content.length === 0 || content.substr(content.length - 1) === '\n' ? '' : '\n';
                content = opts.replace + linebreak + content;
                append = false;
              }
            } else if (opts.append && typeof opts.replace === 'string') {
              if (typeof opts.append === "string") {
                opts.append = new RegExp("^.*" + opts.append + ".*$", 'mg');
              }
              if (opts.append instanceof RegExp) {
                posoffset = 0;
                orgContent = content;
                while ((res = opts.append.exec(orgContent)) !== null) {
                  pos = posoffset + res.index + res[0].length;
                  content = content.slice(0, pos) + '\n' + opts.replace + content.slice(pos);
                  posoffset += opts.replace.length + 1;
                  if (!opts.append.global) {
                    break;
                  }
                }
                append = false;
              } else {
                linebreak = content.length === 0 || content.substr(content.length - 1) === '\n' ? '' : '\n';
                content = content + linebreak + opts.replace;
                append = false;
              }
            } else {
              continue;
            }
          } else {
            return next(new Error("Invalid match option"));
          }
        } else if (opts.before === true) {

        } else {
          from = opts.from ? content.indexOf(opts.from) + opts.from.length : 0;
          to = opts.to ? content.indexOf(opts.to) : content.length;
          content = content.substr(0, from) + opts.replace + content.substr(to);
        }
      }
      return do_eof();
    };
    do_eof = function() {
      var char, i, _j, _len1;
      if (options.eof == null) {
        return do_diff();
      }
      if (typeof options.log === "function") {
        options.log("Mecano `write`: add eof");
      }
      if (options.eof === true) {
        for (i = _j = 0, _len1 = content.length; _j < _len1; i = ++_j) {
          char = content[i];
          if (char === '\r') {
            options.eof = content[i + 1] === '\n' ? '\r\n' : char;
            break;
          }
          if (char === '\n' || char === '\u2028') {
            options.eof = char;
            break;
          }
        }
        if (options.eof === true) {
          options.eof = '\n';
        }
      }
      if (!string.endsWith(content, options.eof)) {
        content += options.eof;
      }
      return do_diff();
    };
    do_diff = function() {
      var count_added, count_removed, line, lines, ls, padsize, _j, _k, _l, _len1, _len2, _len3;
      if (destinationHash === string.hash(content)) {
        return do_ownership();
      }
      if (typeof options.log === "function") {
        options.log("Mecano `write`: file content has changed");
      }
      if (options.diff) {
        lines = diff.diffLines(destination, content);
        if (typeof options.diff === 'function') {
          options.diff(lines);
        }
        if (options.stdout) {
          count_added = count_removed = 0;
          padsize = Math.ceil(lines.length / 10);
          for (_j = 0, _len1 = lines.length; _j < _len1; _j++) {
            line = lines[_j];
            if (line.value === null) {
              continue;
            }
            if (!line.added && !line.removed) {
              count_added++;
              count_removed++;
              continue;
            }
            ls = string.lines(line.value);
            if (line.added) {
              for (_k = 0, _len2 = ls.length; _k < _len2; _k++) {
                line = ls[_k];
                count_added++;
                options.stdout.write("" + (pad(padsize, '' + count_added)) + " + " + line + "\n");
              }
            } else {
              for (_l = 0, _len3 = ls.length; _l < _len3; _l++) {
                line = ls[_l];
                count_removed++;
                options.stdout.write("" + (pad(padsize, '' + count_removed)) + " - " + line + "\n");
              }
            }
          }
        }
      }
      return do_backup();
    };
    do_backup = function() {
      var backup;
      if (!options.backup) {
        return do_write();
      }
      if (typeof options.log === "function") {
        options.log("Mecano `write`: create backup");
      }
      backup = options.backup;
      if (backup === true) {
        backup = "." + (Date.now());
      }
      backup = "" + options.destination + backup;
      return fs.rename(options.ssh, options.destination, backup, function(err) {
        if (err) {
          return next(err);
        }
        return do_write();
      });
    };
    do_write = function() {
      if (typeof options.destination === 'function') {
        if (typeof options.log === "function") {
          options.log("Mecano `write`: write destination with user function");
        }
        options.destination(content);
        return do_end();
      } else {
        if (typeof options.log === "function") {
          options.log("Mecano `write`: write destination");
        }
        if (append) {
          if (options.flags == null) {
            options.flags = 'a';
          }
        }
        return fs.writeFile(options.ssh, options.destination, content, options, function(err) {
          if (err) {
            return next(err);
          }
          modified = true;
          return do_end();
        });
      }
    };
    do_ownership = function() {
      if (!((options.uid != null) && (options.gid != null))) {
        return do_permissions();
      }
      if (typeof options.log === "function") {
        options.log("Mecano `write`: change ownership");
      }
      return chown({
        ssh: options.ssh,
        destination: options.destination,
        uid: options.uid,
        gid: options.gid,
        log: options.log
      }, function(err, chowned) {
        if (err) {
          return next(err);
        }
        if (chowned) {
          modified = true;
        }
        return do_permissions();
      });
    };
    do_permissions = function() {
      if (options.mode == null) {
        return do_end();
      }
      if (typeof options.log === "function") {
        options.log("Mecano `write`: change permissions");
      }
      return chmod({
        ssh: options.ssh,
        destination: options.destination,
        mode: options.mode,
        log: options.log
      }, function(err, chmoded) {
        if (err) {
          return next(err);
        }
        if (chmoded) {
          modified = true;
        }
        return do_end();
      });
    };
    do_end = function() {
      return next(null, modified);
    };
    return do_read_source();
  });
};

fs = require('ssh2-fs');

path = require('path');

each = require('each');

eco = require('eco');

nunjucks = require('nunjucks');

pad = require('pad');

diff = require('diff');

quote = require('regexp-quote');

misc = require('./misc');

string = require('./misc/string');

wrap = require('./misc/wrap');

mkdir = require('./mkdir');

chown = require('./chown');

chmod = require('./chmod');
