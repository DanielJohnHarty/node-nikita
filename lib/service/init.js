// Generated by CoffeeScript 2.3.1
// # `nikita.service.init`

// Render startup script.
// Reload the service daemon provider depending on the os.

// ## Options

// * `backup` (string|boolean)   
//   Create a backup, append a provided string to the filename extension or a
//   timestamp if value is not a string, only apply if the target file exists and
//   is modified.
// * `context` (object)   
//   The context object used to render the scripts file.
// * `engine`   
//   Template engine to use. Nunjucks by default.
// * `filters` (function)   
//   Filter function to extend the nunjucks engine.
// * `local`   
//   Treat the source as local instead of remote, only apply with "ssh"
//   option.
// * `name` (string)   
//   The name of the destination file. Use the name of the template if missing.
// * `skip_empty_lines`   
//   Remove empty lines.
// * `source` (boolean) REQUIRED   
//   The source of startup script template.
// * `target` (string) OPTIONAL   
//   The destination file. `/etc/init.d/crond` or `/etc/systemd/system/crond.service` for example.
//   If no provided, nikita put it on the default folder based on the service daemon
//   provider,the OS and use the source filename as the name.
// * `uid`   
//   File user name or user id.
// * `gid`   
//   File group name or group id.
// * `mode`   
//   File mode (permission and sticky bits), default to `0666`, in the for of
//   `{mode: 0o744}` or `{mode: "744"}`.

// ## Callback parameters

// * `err`   
//   Error object if any.
// * `status`   
//   Indicates if the init script was reloaded.

// ## Source Code
var path;

module.exports = function(options) {
  this.log({
    message: "Entering service.init",
    level: 'DEBUG',
    module: 'nikita/lib/service/init'
  });
  if (options.source == null) {
    // mandatory options
    throw Error('Missing source');
  }
  if (options.engine == null) {
    options.engine = 'nunjunks';
  }
  if (options.mode == null) {
    options.mode = 0o755;
  }
  // check if file is target is directory
  // detect daemon loader provider to construct target
  if (options.name == null) {
    options.name = path.basename(options.source).split('.')[0];
  }
  if (options.target != null) {
    options.name = path.basename(options.target).split('.service')[0];
  }
  if (options.target == null) {
    options.target = `/etc/init.d/${options.name}`;
  }
  if (options.context == null) {
    options.context = {};
  }
  return this.service.discover(function(err, system) {
    if (options.loader == null) {
      options.loader = system.loader;
    }
    // discover loader to put in cache
    this.file.render({
      target: options.target,
      source: options.source,
      mode: options.mode,
      uid: options.uid,
      gid: options.gid,
      backup: options.backup,
      context: options.context,
      local: options.local
    });
    this.system.execute({
      if: function() {
        return options.loader === 'systemctl';
      },
      shy: true,
      cmd: `systemctl status ${options.name} 2>\&1 | egrep '(Reason: No such file or directory)|(Unit ${options.name}.service could not be found)|(${options.name}.service changed on disk)'`,
      code_skipped: 1
    });
    return this.system.execute({
      if: function() {
        return this.status(-1);
      },
      cmd: 'systemctl daemon-reload;systemctl reset-failed'
    });
  });
};

// ## Dependencies
path = require('path');

// [sysvinit vs systemd]:(https://www.digitalocean.com/community/tutorials/how-to-configure-a-linux-service-to-start-automatically-after-a-crash-or-reboot-part-2-reference)
