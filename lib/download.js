// Generated by CoffeeScript 1.9.1
var Ftp, curl, execute, fs, misc, move, remove, request, url, wrap;

module.exports = function(options, callback) {
  return wrap(this, arguments, function(options, callback) {
    var checksum, destination, download, md5sum, prepare, source, stageDestination, unstage;
    destination = options.destination, source = options.source, md5sum = options.md5sum;
    if (!source) {
      return callback(new Error("Missing source: " + source));
    }
    if (!destination) {
      return callback(new Error("Missing destination: " + destination));
    }
    if (options.force == null) {
      options.force = false;
    }
    stageDestination = destination + "." + (Date.now()) + (Math.round(Math.random() * 1000));
    prepare = function() {
      if (typeof options.log === "function") {
        options.log("Mecano `download`: Check if destination exists");
      }
      return fs.exists(options.ssh, destination, function(err, exists) {
        if (options.force) {
          return download();
        } else if (exists && md5sum) {
          return misc.file.hash(options.ssh, destination, 'md5', function(err, hash) {
            if (err) {
              return callback(err);
            }
            if (hash === md5sum) {
              return callback();
            }
            return fs.unlink(options.ssh, destination, function(err) {
              if (err) {
                return callback(err);
              }
              return download();
            });
          });
        } else if (exists) {
          return download();
        } else {
          return download();
        }
      });
    };
    download = function() {
      var cmd, u;
      if (typeof options.log === "function") {
        options.log("Mecano `download`: Download the source");
      }
      u = url.parse(source);
      if (options.ssh) {
        if (u.protocol === 'http:') {
          cmd = "curl -s " + source + " -o " + stageDestination;
          if (options.proxy) {
            cmd += " -x " + options.proxy;
          }
          return execute({
            ssh: options.ssh,
            cmd: cmd,
            log: options.log,
            stdout: options.stdout,
            stderr: options.stderr
          }, function(err, executed, stdout, stderr) {
            if (err) {
              return callback(curl.error(err));
            }
            return checksum();
          });
        } else if (u.protocol === 'ftp:') {
          return callback(new Error('FTP download not supported over SSH'));
        } else {
          return fs.createReadStream(options.ssh, u.pathname, function(err, rs) {
            if (err) {
              return callback(err);
            }
            return fs.createWriteStream(null, stageDestination, function(err, ws) {
              if (err) {
                return callback(err);
              }
              return rs.pipe(ws).on('close', function() {
                return checksum();
              }).on('error', callback);
            });
          });
        }
      } else {
        return fs.createWriteStream(null, stageDestination, function(err, ws) {
          var ftp, pass, ref, user;
          if (err) {
            return callback(err);
          }
          if (u.protocol === 'http:') {
            options.url = source;
            request(options).pipe(ws);
          } else if (u.protocol === 'ftp:') {
            if (options.host == null) {
              options.host = u.hostname;
            }
            if (options.port == null) {
              options.port = u.port;
            }
            if (u.auth) {
              ref = u.auth.split(':'), user = ref.user, pass = ref.pass;
            }
            if (options.user == null) {
              options.user = user;
            }
            if (options.pass == null) {
              options.pass = pass;
            }
            ftp = new Ftp(options);
            ftp.getGetSocket(u.pathname, function(err, rs) {
              if (err) {
                return callback(err);
              }
              rs.pipe(ws);
              return rs.resume();
            });
          } else {
            fs.createReadStream(null, u.pathname, function(err, rs) {
              return rs.pipe(ws);
            });
          }
          ws.on('close', function() {
            return checksum();
          });
          return ws.on('error', function(err) {
            return remove({
              destination: stageDestination
            }, callback);
          });
        });
      }
    };
    checksum = function() {
      if (!md5sum) {
        return unstage();
      }
      if (typeof options.log === "function") {
        options.log("Mecano `download`: Compare the downloaded file with the user-provided checksum");
      }
      return misc.file.hash(options.ssh, stageDestination, 'md5', function(err, hash) {
        if (hash === md5sum) {
          return unstage();
        }
        return misc.file.remove(options.ssh, stageDestination, function(err) {
          if (err) {
            return callback(err);
          }
          return callback(new Error("Invalid checksum, found \"" + hash + "\" instead of \"" + md5sum + "\""));
        });
      });
    };
    unstage = function() {
      if (typeof options.log === "function") {
        options.log("Mecano `download`: Move the downloaded file");
      }
      return move({
        ssh: options.ssh,
        source: stageDestination,
        destination: destination,
        source_md5: md5sum,
        log: options.log
      }, function(err, moved) {
        if (err) {
          return callback(err);
        }
        return callback(null, moved);
      });
    };
    return prepare();
  });
};

fs = require('ssh2-fs');

url = require('url');

Ftp = require('jsftp');

request = require('request');

curl = require('./misc/curl');

misc = require('./misc');

wrap = require('./misc/wrap');

execute = require('./execute');

remove = require('./remove');

move = require('./move');
