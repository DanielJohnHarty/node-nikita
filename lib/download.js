// Generated by CoffeeScript 1.9.1
var Ftp, curl, download, execute, fs, misc, mkdir, move, path, remove, request, url, wrap;

module.exports = download = function(options, callback) {
  return wrap(this, arguments, function(options, callback) {
    var algo, destination, do_cache, do_checksum, do_download, do_prepare, hash, source, stageDestination, unstage;
    destination = options.destination, source = options.source;
    if (!source) {
      return callback(new Error("Missing source: " + source));
    }
    if (!destination) {
      return callback(new Error("Missing destination: " + destination));
    }
    stageDestination = destination + "." + (Date.now()) + (Math.round(Math.random() * 1000));
    if (options.md5) {
      algo = 'md5';
      hash = options.md5;
    } else if (options.sha1) {
      algo = 'sha1';
      hash = options.sha1;
    } else {
      hash = false;
    }
    do_cache = function() {
      var cache, cache_dir, cache_file, no_chck;
      if (!options.local_cache) {
        return do_prepare();
      }
      if (typeof options.log === "function") {
        options.log("Mecano `download`: using cache [DEBUG]");
      }
      if (typeof options.local_cache === 'string') {
        cache = options.local_cache;
      } else {
        cache_dir = options.cache_dir != null ? options.cache_dir : './';
        cache_file = options.cache_file != null ? options.cache_file : path.basename(options.source);
        cache = path.join(cache_dir, cache_file);
      }
      if (typeof options.log === "function") {
        options.log("Mecano `download`: cache file is " + cache + " [INFO]");
      }
      no_chck = options.no_check;
      if (no_chck == null) {
        no_chck = true;
      }
      return download({
        ssh: null,
        source: options.source,
        destination: cache,
        md5: options.md5,
        sha1: options.sha1,
        force: options.force_cache,
        no_check: no_chck,
        log: options.log,
        stdout: options.stdout,
        stderr: options.stderr
      }, function(err, cached) {
        if (err) {
          return callback(err);
        }
        if (typeof options.log === "function") {
          options.log(cached ? "Mecano `download`: cache updated [WARN]" : "Mecano `download`: cache not modified [INFO]");
        }
        if (typeof options.log === "function") {
          options.log("Mecano `download`: sending cache to destination [DEBUG]");
        }
        return download({
          ssh: options.ssh,
          source: cache,
          destination: options.destination,
          mode: options.mode,
          binary: true,
          md5: options.md5,
          sha1: options.sha1,
          uid: options.uid,
          gid: options.gid,
          log: options.log,
          stdout: options.stdout,
          stderr: options.stderr
        }, callback);
      });
    };
    do_prepare = function() {
      if (typeof options.log === "function") {
        options.log("Mecano `download`: Check if destination (" + destination + ") exists [DEBUG]");
      }
      return fs.exists(options.ssh, destination, function(err, exists) {
        if (err) {
          return callback(err);
        }
        if (exists) {
          if (typeof options.log === "function") {
            options.log("Mecano `download`: destination exists [INFO]");
          }
          if (options.no_check) {
            if (typeof options.log === "function") {
              options.log("Mecano `download`: destination exists, check disabled, skipping [DEBUG]");
            }
            return callback(null, false);
          }
          if (options.force) {
            if (typeof options.log === "function") {
              options.log("Mecano `download`: Force download [DEBUG]");
            }
            return do_download();
          } else if (hash) {
            if (typeof options.log === "function") {
              options.log("Mecano `download`: comparing " + algo + " hash [DEBUG]");
            }
            return misc.file.hash(options.ssh, destination, algo, function(err, calc_hash) {
              if (err) {
                return callback(err);
              }
              if (hash === calc_hash) {
                if (typeof options.log === "function") {
                  options.log("Mecano `download`: Hashes match, skipping [DEBUG]");
                }
                return callback();
              }
              if (typeof options.log === "function") {
                options.log("Mecano `download`: Hashes don't match, delete then re-download [WARN]");
              }
              return fs.unlink(options.ssh, destination, function(err) {
                if (err) {
                  return callback(err);
                }
                return do_download();
              });
            });
          } else {
            if (typeof options.log === "function") {
              options.log("Mecano `download`: Check enabled but no hash found, force download [DEBUG]");
            }
            return do_download();
          }
        } else {
          if (typeof options.log === "function") {
            options.log("Mecano `download`: destination doesn't exists, cheking parent directories (" + (path.join(destination, '..')) + ") [DEBUG]");
          }
          return mkdir({
            ssh: options.ssh,
            destination: path.join(destination, '..')
          }, function(err, created) {
            if (err) {
              return callback(err);
            }
            if (created) {
              if (typeof options.log === "function") {
                options.log("Mecano `download`: Parent directory created [WARN]");
              }
            }
            return do_download();
          });
        }
      });
    };
    do_download = function() {
      var cmd, k, ref, u;
      if (typeof options.log === "function") {
        options.log("Mecano `download`: Download the source [DEBUG]");
      }
      u = url.parse(source);
      if (options.ssh) {
        if ((ref = u.protocol) === 'http:' || ref === 'https:') {
          k = u.protocol === 'https:' ? '-k' : '';
          cmd = "curl " + k + " -s " + source + " -o " + stageDestination;
          if (options.proxy) {
            cmd += " -x " + options.proxy;
          }
          return execute({
            ssh: options.ssh,
            cmd: cmd,
            log: options.log,
            stdout: options.stdout,
            stderr: options.stderr
          }, function(err, executed, stdout, stderr) {
            if (err) {
              return callback(curl.error(err));
            }
            return do_checksum();
          });
        } else if (u.protocol === 'ftp:') {
          return callback(new Error('FTP download not supported over SSH'));
        } else {
          return fs.createReadStream(null, u.pathname, function(err, rs) {
            if (err) {
              return callback(err);
            }
            return fs.createWriteStream(options.ssh, stageDestination, function(err, ws) {
              if (err) {
                return callback(err);
              }
              rs.on('error', callback);
              return rs.pipe(ws).on('close', function() {
                return do_checksum();
              }).on('error', callback);
            });
          });
        }
      } else {
        return fs.createWriteStream(null, stageDestination, function(err, ws) {
          var ftp, pass, ref1, ref2, user;
          if (err) {
            return callback(err);
          }
          if ((ref1 = u.protocol) === 'http:' || ref1 === 'https:') {
            options.url = source;
            request(options).pipe(ws);
          } else if (u.protocol === 'ftp:') {
            if (options.host == null) {
              options.host = u.hostname;
            }
            if (options.port == null) {
              options.port = u.port;
            }
            if (u.auth) {
              ref2 = u.auth.split(':'), user = ref2.user, pass = ref2.pass;
            }
            if (options.user == null) {
              options.user = user;
            }
            if (options.pass == null) {
              options.pass = pass;
            }
            ftp = new Ftp(options);
            ftp.getGetSocket(u.pathname, function(err, rs) {
              if (err) {
                return callback(err);
              }
              rs.pipe(ws);
              return rs.resume();
            });
          } else {
            fs.createReadStream(null, u.pathname, function(err, rs) {
              return rs.pipe(ws);
            });
          }
          ws.on('close', function() {
            return do_checksum();
          });
          return ws.on('error', function(err) {
            return remove({
              destination: stageDestination
            }, callback);
          });
        });
      }
    };
    do_checksum = function() {
      if (!hash) {
        return unstage();
      }
      if (typeof options.log === "function") {
        options.log("Mecano `download`: Compare the downloaded file with the user-provided checksum [DEBUG]");
      }
      return misc.file.hash(options.ssh, stageDestination, algo, function(err, calc_hash) {
        if (hash === calc_hash) {
          "Mecano `download`: download is valid [INFO]";
          return unstage();
        }
        return misc.file.remove(options.ssh, stageDestination, function(err) {
          if (err) {
            return callback(err);
          }
          return callback(new Error("Invalid checksum, found \"" + calc_hash + "\" instead of \"" + hash + "\""));
        });
      });
    };
    unstage = function() {
      if (typeof options.log === "function") {
        options.log("Mecano `download`: Move the downloaded file [DEBUG]");
      }
      return move({
        ssh: options.ssh,
        source: stageDestination,
        destination: destination,
        source_md5: options.md5,
        log: options.log
      }, callback);
    };
    return do_cache();
  });
};

curl = require('./misc/curl');

execute = require('./execute');

fs = require('ssh2-fs');

Ftp = require('jsftp');

misc = require('./misc');

mkdir = require('./mkdir');

move = require('./move');

path = require('path');

remove = require('./remove');

request = require('request');

url = require('url');

wrap = require('./misc/wrap');
