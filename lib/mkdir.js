// Generated by CoffeeScript 1.9.1
var each, fs, misc, path, uid_gid, wrap;

module.exports = function(options, callback) {
  var cwd, modified, ref;
  modified = false;
  if (options.argument != null) {
    options.destination = options.argument;
  }
  if (options.directory == null) {
    options.directory = options.destination;
  }
  if (options.directory == null) {
    options.directory = options.source;
  }
  if (options.directory == null) {
    return callback(new Error('Missing directory option'));
  }
  cwd = (ref = options.cwd) != null ? ref : process.cwd();
  if (!Array.isArray(options.directory)) {
    options.directory = [options.directory];
  }
  if (options.parent === true) {
    options.parent = {};
  }
  return each(options.directory).on('item', (function(_this) {
    return function(directory, callback) {
      var do_create, do_create_parent, do_stats, do_update;
      if (typeof options.log === "function") {
        options.log("Mecano `mkdir`: " + directory);
      }
      do_stats = function() {
        var directories, dirs, end, i;
        end = false;
        dirs = [];
        directory = path.resolve(cwd, directory);
        directories = directory.split('/');
        directories.shift();
        directories = (function() {
          var j, ref1, results;
          results = [];
          for (i = j = 0, ref1 = directories.length; 0 <= ref1 ? j < ref1 : j > ref1; i = 0 <= ref1 ? ++j : --j) {
            results.push('/' + directories.slice(0, directories.length - i).join('/'));
          }
          return results;
        })();
        return each(directories).on('item', function(directory, i, next) {
          if (end) {
            return next();
          }
          return fs.stat(options.ssh, directory, function(err, stat) {
            if ((err != null ? err.code : void 0) === 'ENOENT') {
              directory.stat = stat;
              dirs.push(directory);
              if (i === directories.length - 1) {
                return do_create_parent(dirs);
              } else {
                return next();
              }
            }
            if (stat != null ? stat.isDirectory() : void 0) {
              end = true;
              if (i === 0) {
                return do_update(stat);
              } else {
                return do_create_parent(dirs);
              }
            }
            if (err) {
              return next(err);
            } else {
              return next(new Error("Not a directory: " + (JSON.stringify(directory))));
            }
          });
        }).on('both', function(err) {
          if (err) {
            return callback(err);
          }
        });
      };
      do_create_parent = function(directories) {
        if (!(options.uid || options.guid)) {
          return do_create(directories);
        }
        return uid_gid(options, function(err) {
          if (err) {
            return next(err);
          }
          return do_create(directories);
        });
      };
      do_create = function(directories) {
        return each(directories.reverse()).on('item', function(directory, i, callback) {
          var attr, attrs, j, len, opts, ref1, val;
          if ((options.exclude != null) && options.exclude instanceof RegExp) {
            if (options.exclude.test(path.basename(directory))) {
              return callback();
            }
          }
          if (directory !== options.directory) {
            if (typeof options.log === "function") {
              options.log("Mecano `mkdir`: " + (JSON.stringify(directory)) + " created");
            }
          }
          attrs = ['mode', 'uid', 'gid', 'size', 'atime', 'mtime'];
          opts = {};
          for (j = 0, len = attrs.length; j < len; j++) {
            attr = attrs[j];
            val = i === directories.length - 1 ? options[attr] : (ref1 = options.parent) != null ? ref1[attr] : void 0;
            if (val != null) {
              opts[attr] = val;
            }
          }
          return fs.mkdir(options.ssh, directory, opts, function(err) {
            if (err) {
              return callback(err);
            }
            modified = true;
            return callback();
          }, 1000);
        }).on('both', function(err) {
          if (err) {
            return callback(err);
          }
          return callback();
        });
      };
      do_update = function(stat) {
        if (typeof options.log === "function") {
          options.log("Mecano `mkdir`: " + (JSON.stringify(directory)) + " exists");
        }
        return _this.chown({
          ssh: options.ssh,
          destination: directory,
          stat: stat,
          uid: options.uid,
          gid: options.gid,
          log: options.log,
          "if": (options.uid != null) || (options.gid != null)
        }).chmod({
          ssh: options.ssh,
          destination: directory,
          stat: stat,
          mode: options.mode,
          log: options.log,
          "if": options.mode != null
        }).then(function(err, moded) {
          if (err) {
            return callback(err);
          }
          if (moded) {
            modified = true;
          }
          return callback();
        });
      };
      return do_stats();
    };
  })(this)).on('both', function(err) {
    return callback(err, modified);
  });
};

fs = require('ssh2-fs');

path = require('path');

each = require('each');

misc = require('./misc');

wrap = require('./misc/wrap');

uid_gid = require('./misc/uid_gid');
