// Generated by CoffeeScript 1.8.0
var chmod, chown, each, fs, misc, path, wrap;

module.exports = function(options, callback) {
  return wrap(arguments, function(options, callback) {
    var cwd, modified, _ref;
    modified = false;
    if (typeof options === 'string') {
      options = {
        directory: options
      };
    }
    if (options.directory == null) {
      options.directory = options.source;
    }
    if (options.directory == null) {
      options.directory = options.destination;
    }
    if (options.directory == null) {
      return callback(new Error('Missing directory option'));
    }
    cwd = (_ref = options.cwd) != null ? _ref : process.cwd();
    if (!Array.isArray(options.directory)) {
      options.directory = [options.directory];
    }
    if (options.parent === true) {
      options.parent = {};
    }
    return each(options.directory).on('item', function(directory, callback) {
      var do_create, do_create_parent, do_stats, do_update;
      if (typeof options.log === "function") {
        options.log("Mecano `mkdir`: " + directory);
      }
      do_stats = function() {
        var directories, dirs, end, i;
        end = false;
        dirs = [];
        directory = path.resolve(cwd, directory);
        directories = directory.split('/');
        directories.shift();
        directories = (function() {
          var _i, _ref1, _results;
          _results = [];
          for (i = _i = 0, _ref1 = directories.length; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
            _results.push('/' + directories.slice(0, directories.length - i).join('/'));
          }
          return _results;
        })();
        return each(directories).on('item', function(directory, i, callback) {
          if (end) {
            return callback();
          }
          return fs.stat(options.ssh, directory, function(err, stat) {
            if ((err != null ? err.code : void 0) === 'ENOENT') {
              directory.stat = stat;
              dirs.push(directory);
              if (i === directories.length - 1) {
                return do_create_parent(dirs);
              } else {
                return callback();
              }
            }
            if (stat != null ? stat.isDirectory() : void 0) {
              end = true;
              if (i === 0) {
                return do_update(stat);
              } else {
                return do_create_parent(dirs);
              }
            }
            if (err) {
              return callback(err);
            } else {
              return callback(new Error("Not a directory: " + (JSON.stringify(directory))));
            }
          });
        }).on('both', function(err) {
          if (err) {
            return callback(err);
          }
        });
      };
      do_create_parent = function(directories) {
        if (!(options.uid || options.guid)) {
          return do_create(directories);
        }
        return wrap.uid_gid(options, function(err) {
          if (err) {
            return next(err);
          }
          return do_create(directories);
        });
      };
      do_create = function(directories) {
        return each(directories.reverse()).on('item', function(directory, i, callback) {
          var attr, attrs, opts, val, _i, _len, _ref1;
          if ((options.exclude != null) && options.exclude instanceof RegExp) {
            if (options.exclude.test(path.basename(directory))) {
              return callback();
            }
          }
          if (directory !== options.directory) {
            if (typeof options.log === "function") {
              options.log("Mecano `mkdir`: " + (JSON.stringify(directory)) + " created");
            }
          }
          attrs = ['mode', 'uid', 'gid', 'size', 'atime', 'mtime'];
          opts = {};
          for (_i = 0, _len = attrs.length; _i < _len; _i++) {
            attr = attrs[_i];
            val = i === directories.length - 1 ? options[attr] : (_ref1 = options.parent) != null ? _ref1[attr] : void 0;
            if (val != null) {
              opts[attr] = val;
            }
          }
          return fs.mkdir(options.ssh, directory, opts, function(err) {
            if (err) {
              return callback(err);
            }
            modified = true;
            return callback();
          }, 1000);
        }).on('both', function(err) {
          if (err) {
            return callback(err);
          }
          return callback();
        });
      };
      do_update = function(stat) {
        var do_chmod, do_chown;
        if (typeof options.log === "function") {
          options.log("Mecano `mkdir`: " + (JSON.stringify(directory)) + " exists");
        }
        do_chown = function() {
          return chown({
            ssh: options.ssh,
            destination: directory,
            stat: stat,
            uid: options.uid,
            gid: options.gid,
            log: options.log
          }, function(err, owned) {
            if (owned) {
              modified = true;
            }
            return do_chmod();
          });
        };
        do_chmod = function() {
          if (!options.mode) {
            return callback();
          }
          return chmod({
            ssh: options.ssh,
            destination: directory,
            stat: stat,
            mode: options.mode,
            log: options.log
          }, function(err, moded) {
            if (moded) {
              modified = true;
            }
            return callback();
          });
        };
        return do_chown();
      };
      return do_stats();
    }).on('both', function(err) {
      return callback(err, modified);
    });
  });
};

fs = require('ssh2-fs');

path = require('path');

each = require('each');

chown = require('./chown');

chmod = require('./chmod');

misc = require('./misc');

wrap = require('./misc/wrap');
