// Generated by CoffeeScript 1.7.1
var child, chmod, chown, conditions, each, execute, misc;

module.exports = function(goptions, options, callback) {
  var _ref;
  _ref = misc.args(arguments), goptions = _ref[0], options = _ref[1], callback = _ref[2];
  return misc.options(options, function(err, options) {
    var executed;
    if (err) {
      return callback(err);
    }
    executed = 0;
    return each(options).parallel(goptions.parallel).on('item', function(options, next) {
      var do_chmod, do_chown, do_end, do_get, do_ktadd, modified;
      if (!options.principal) {
        return next(new Error('Property principal is required'));
      }
      if (!options.keytab) {
        return next(new Error('Property keytab is required'));
      }
      if (/.*@.*/.test(options.kadmin_principal)) {
        if (options.realm == null) {
          options.realm = options.kadmin_principal.split('@')[1];
        }
      }
      modified = false;
      do_get = function() {
        if (!options.keytab) {
          return do_end();
        }
        return execute({
          cmd: "klist -k " + options.keytab,
          ssh: options.ssh,
          log: options.log,
          stdout: options.stdout,
          stderr: options.stderr,
          code_skipped: 1
        }, function(err, exists, stdout, stderr) {
          var keytab, kvno, line, match, principal, _, _i, _len, _ref1;
          if (err) {
            return next(err);
          }
          if (!exists) {
            return do_ktadd();
          }
          keytab = {};
          _ref1 = stdout.split('\n');
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            line = _ref1[_i];
            if (match = /^\s*(\d+)\s*(.*)\s*$/.exec(line)) {
              _ = match[0], kvno = match[1], principal = match[2];
              keytab[principal] = kvno;
            }
          }
          if (keytab[options.principal] == null) {
            return do_ktadd();
          }
          return execute({
            cmd: misc.kadmin(options, "getprinc " + options.principal),
            ssh: options.ssh,
            log: options.log,
            stdout: options.stdout,
            stderr: options.stderr
          }, function(err, exists, stdout, stderr) {
            var vno, _j, _len1, _ref2;
            if (err) {
              return err;
            }
            if (-1 !== stdout.indexOf('does not exist')) {
              return do_ktadd();
            }
            vno = null;
            _ref2 = stdout.split('\n');
            for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
              line = _ref2[_j];
              if (match = /Key: vno (\d+)/.exec(line)) {
                _ = match[0], vno = match[1];
                break;
              }
            }
            if (keytab[principal] === vno) {
              return do_chown();
            }
            return do_ktadd();
          });
        });
      };
      do_ktadd = function() {
        return execute({
          cmd: misc.kadmin(options, "ktadd -k " + options.keytab + " " + options.principal),
          ssh: options.ssh,
          log: options.log,
          stdout: options.stdout,
          stderr: options.stderr
        }, function(err, ktadded) {
          if (err) {
            return next(err);
          }
          modified = true;
          return do_chown();
        });
      };
      do_chown = function() {
        if (!options.keytab || (!options.uid && !options.gid)) {
          return do_chmod();
        }
        return chown({
          ssh: options.ssh,
          log: options.log,
          destination: options.keytab,
          uid: options.uid,
          gid: options.gid
        }, function(err, chowned) {
          if (err) {
            return next(err);
          }
          if (chowned) {
            modified = chowned;
          }
          return do_chmod();
        });
      };
      do_chmod = function() {
        if (!options.keytab || !options.mode) {
          return do_end();
        }
        return chmod({
          ssh: options.ssh,
          log: options.log,
          destination: options.keytab,
          mode: options.mode
        }, function(err, chmoded) {
          if (err) {
            return next(err);
          }
          if (chmoded) {
            modified = chmoded;
          }
          return do_end();
        });
      };
      do_end = function() {
        if (modified) {
          executed++;
        }
        return next();
      };
      return conditions.all(options, next, do_get);
    }).on('both', function(err) {
      return callback(err, executed);
    });
  });
};

each = require('each');

misc = require('./misc');

conditions = require('./misc/conditions');

child = require('./misc/child');

execute = require('./execute');

chmod = require('./chmod');

chown = require('./chown');
