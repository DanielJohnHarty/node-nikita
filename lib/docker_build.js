// Generated by CoffeeScript 1.9.1
var docker, path;

module.exports = function(options, callback) {
  var cmd, do_construct_command, do_download_docker_file, do_download_resources, do_provider;
  if (options.name == null) {
    return callback(Error('Missing build name'));
  }
  if (!((options.write != null) || (options.source != null))) {
    return callback(Error('source and write not specified'));
  }
  if ((options.write != null) && (options.source != null)) {
    return callback(Error('can not build from source and write'));
  }
  if ((options.write != null) && (options.resources != null)) {
    return callback(Error('docker does not support adding resource from STDIN docker build '));
  }
  if (options.rm_intermediate == null) {
    options.rm_intermediate = false;
  }
  options.rm_final = false;
  if (options.pull == null) {
    options.pull = true;
  }
  if (options.quiet == null) {
    options.quiet = false;
  }
  options.cache = !(options.cache != null ? options.cache : options.cache = false);
  options.destination = options.cwd != null ? options.cwd : options.cwd = "/tmp/ryba/build_" + (Date.now());
  options.shy = true;
  do_download_resources = (function(_this) {
    return function() {
      var dl, i, len, path, ref;
      if (options.resources != null) {
        dl = [];
        ref = options.resources;
        for (i = 0, len = ref.length; i < len; i++) {
          path = ref[i];
          dl.push({
            source: path,
            destination: options.destination + "/resources/}",
            cache: true,
            ssh: options.ssh,
            force: true
          });
        }
        return _this.child().download(dl).then(function(err, executed) {
          if (err) {
            return callback(err);
          }
        });
      } else {
        return do_download_docker_file();
      }
    };
  })(this);
  do_download_docker_file = (function(_this) {
    return function() {
      return _this.child().download({
        ssh: options.ssh,
        source: options.source,
        cache: true,
        force: true,
        destination: options.destination + "/Dockerfile"
      }, function(err, executed) {
        if (err) {
          return callback(err);
        }
        return do_provider();
      });
    };
  })(this);
  do_provider = (function(_this) {
    return function() {
      return docker.check_docker_daemon_provider(options, do_construct_command);
    };
  })(this);
  do_construct_command = (function(_this) {
    return function(err, provider) {
      var exec_opts, flag, i, k, len, opt, ref, ref1;
      if (err) {
        return callback(err);
      }
      options.provider = provider;
      switch (provider) {
        case 'docker-machine':
        case 'boot2docker':
          cmd += docker.get_env_expr(provider, options.machine);
      }
      if (options.write != null) {
        cmd += " echo " + options.write + "  | ";
      }
      cmd += 'docker build';
      cmd += " --tag=\"" + options.name + "\"";
      ref = {
        rm_intermediate: '--force-rm',
        rm_final: '--rm',
        quiet: '--quiet',
        cache: '--no-cache'
      };
      for (opt in ref) {
        flag = ref[opt];
        if (options[opt] != null) {
          cmd += " " + flag + "=" + options[opt];
        }
      }
      if (options.source != null) {
        cmd += " " + options.destination;
      }
      if (options.write != null) {
        cmd += " - ";
      }
      exec_opts = {
        cmd: cmd
      };
      ref1 = ['ssh', 'log', 'stdout', 'stderr', 'cwd', 'code', 'code_skipped'];
      for (i = 0, len = ref1.length; i < len; i++) {
        k = ref1[i];
        if (options[k] != null) {
          exec_opts[k] = options[k];
        }
      }
      return _this.execute(exec_opts, function(err, executed, stdout, stderr) {
        return callback(err, executed, stdout, stderr);
      });
    };
  })(this);
  cmd = '';
  if (options.source != null) {
    return do_download_resources();
  } else {
    return do_provider();
  }
};

path = require('path');

docker = require('./misc/docker');
