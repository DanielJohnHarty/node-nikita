// Generated by CoffeeScript 1.9.1
var docker;

module.exports = function(options, callback) {
  var do_download_dockerfile, do_download_resources, do_provider;
  if (options.image == null) {
    return callback(Error('Missing image parameter'));
  }
  if (!((options.write != null) || (options.source != null))) {
    return callback(Error('Source and write not specified'));
  }
  if ((options.write != null) && (options.source != null)) {
    return callback(Error('Can not build from source and write'));
  }
  if ((options.write != null) && (options.resources != null)) {
    return callback(Error('Docker does not support adding resource from STDIN docker build '));
  }
  if (options.cwd == null) {
    options.cwd = "/tmp/ryba/build_" + (Date.now());
  }
  if (options.destination == null) {
    options.destination = options.cwd;
  }
  do_download_resources = (function(_this) {
    return function() {
      var dl, path;
      if (options.resources != null) {
        dl = (function() {
          var i, len, ref, results;
          ref = options.resources;
          results = [];
          for (i = 0, len = ref.length; i < len; i++) {
            path = ref[i];
            results.push({
              source: path,
              log: options.log,
              destination: options.destination,
              ssh: options.ssh,
              force: true
            });
          }
          return results;
        })();
        return _this.download(dl).then(function(err, executed) {
          if (err) {
            return callback(err);
          }
          return do_download_dockerfile();
        });
      } else {
        return do_download_dockerfile();
      }
    };
  })(this);
  do_download_dockerfile = (function(_this) {
    return function() {
      return _this.download({
        ssh: options.ssh,
        source: options.source,
        log: options.log,
        cache: true,
        force: true,
        destination: options.destination + "/Dockerfile"
      }, function(err, executed) {
        if (err) {
          return callback(err);
        }
        return do_provider();
      });
    };
  })(this);
  do_provider = (function(_this) {
    return function() {
      return docker.get_provider(options, function(err, provider) {
        var cmd, exec_opts, i, j, k, len, len1, opt, ref, ref1;
        if (err) {
          return callback(err);
        }
        options.provider = provider;
        cmd += docker.prepare_cmd(provider, options.machine);
        cmd = "docker build -t \"" + options.image + "\"";
        ref = ['force_rm', 'rm', 'quiet', 'no_cache'];
        for (i = 0, len = ref.length; i < len; i++) {
          opt = ref[i];
          if (options[opt] != null) {
            cmd += " --" + (opt.replace('_', '-')) + "=" + options[opt];
          }
        }
        if (options.source != null) {
          cmd += " " + options.destination;
        }
        if (options.write != null) {
          cmd += " - <<DOCKERFILE\n" + options.write + "\nDOCKERFILE";
        }
        exec_opts = {
          cmd: cmd
        };
        ref1 = ['ssh', 'log', 'stdout', 'stderr', 'cwd', 'code', 'code_skipped'];
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          k = ref1[j];
          if (options[k] != null) {
            exec_opts[k] = options[k];
          }
        }
        return _this.execute(exec_opts, function(err, executed, stdout, stderr) {
          return callback(err, executed, stdout, stderr);
        });
      });
    };
  })(this);
  if (options.source != null) {
    return do_download_resources();
  } else {
    return do_provider();
  }
};

docker = require('./misc/docker');
