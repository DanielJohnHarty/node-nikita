// Generated by CoffeeScript 1.7.1
var child, conditions, each, execute, iptables, misc;

each = require('each');

misc = require('./misc');

iptables = require('./misc/iptables');

conditions = require('./misc/conditions');

child = require('./misc/child');

execute = require('./execute');

module.exports = function(goptions, options, callback) {
  var finish, result, _ref;
  _ref = misc.args(arguments), goptions = _ref[0], options = _ref[1], callback = _ref[2];
  result = child();
  finish = function(err, written) {
    if (callback) {
      callback(err, written);
    }
    return result.end(err, written);
  };
  misc.options(options, function(err, options) {
    var modified;
    if (err) {
      return callback(err);
    }
    modified = 0;
    return each(options).parallel(goptions.parallel).on('item', function(options, next) {
      if (typeof options.log === "function") {
        options.log("Mecano `iptables`");
      }
      return conditions.all(options, next, function() {
        if (typeof options.log === "function") {
          options.log("Mecano `iptables`: list existing rules");
        }
        return execute({
          cmd: "service iptables status &>/dev/null && iptables -S",
          ssh: options.ssh,
          log: options.log,
          stdout: options.stdout,
          stderr: options.stderr,
          code_skipped: 3
        }, function(err, executed, stdout) {
          var cmd, newrules, oldrules;
          if (err) {
            return next(err);
          }
          if (!executed) {
            return next(Error("Service iptables not started"));
          }
          oldrules = iptables.parse(stdout);
          newrules = iptables.normalize(options.rules);
          cmd = iptables.cmd(oldrules, newrules);
          if (!cmd.length) {
            return next();
          }
          if (typeof options.log === "function") {
            options.log("Mecano `iptables`: modify rules");
          }
          return execute({
            cmd: "" + (cmd.join('; ')) + "; service iptables save",
            ssh: options.ssh,
            log: options.log,
            trap_on_error: true,
            stdout: options.stdout,
            stderr: options.stderr
          }, function(err, executed) {
            modified++;
            return next(err);
          });
        });
      });
    }).on('both', function(err) {
      return finish(err, modified);
    });
  });
  return result;
};
