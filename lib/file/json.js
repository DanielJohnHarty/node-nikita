// Generated by CoffeeScript 2.0.2
// # `nikita.file.json(options, callback)`

// ## Options

// * `content` (javascript)  
//   The javascript code to stringify.   
// * `pretty` (boolean | int)  
//   Prettify the JSON output, accept the number of spaces as an integer, default
//   to none if false or to 2 spaces indentation if true.   
// * `source` (string)   
//   Path to a JSON file providing default values.
// * `target` (string)   
//   Path to the destination file.
// * `merge` (boolean)  
//   Merge the user content with the content of the destination file if it
//   exists.   
// * `transform` (function)  
//   User provided function to modify the javascript before it is stringified
//   into JSON.   

// The properties "backup", "diff", "eof", "gid", "uid", "mode" will
// be passed to the `file` function.

// ## Exemple

// Merge the destination file with user provided content.

// ```javascript
// require('nikita')
// .file.json({
//   target: "/path/to/target.json",
//   content: { preferences: { colors: 'blue' } },
//   transform: function(data){
//     if(data.indexOf('red') < 0){ data.push('red'); }
//     return data;
//   },
//   merge: true,
//   pretty: true
// })
// ```

// ## Source Code
var fs, merge;

module.exports = function(options) {
  options.log({
    message: "Entering file.json",
    level: 'DEBUG',
    module: 'nikita/lib/file/json'
  });
  if (options.content == null) {
    options.content = {};
  }
  if (options.pretty == null) {
    options.pretty = false;
  }
  if (options.pretty === true) {
    options.pretty = 2;
  }
  if (options.transform == null) {
    options.transform = null;
  }
  if (options.transform && typeof options.transform !== 'function') {
    throw Error("Invalid options: \"transform\"");
  }
  this.call({
    if: options.merge
  }, function(_, callback) {
    return fs.readFile(options.ssh, options.target, 'utf8', function(err, json) {
      if ((err != null ? err.code : void 0) === 'ENOENT') {
        return callback();
      }
      if (!err) {
        options.content = merge(JSON.parse(json), options.content);
      }
      return callback(err);
    });
  });
  this.call({
    if: options.source
  }, function(_, callback) {
    var ssh;
    ssh = options.local ? null : options.ssh;
    return fs.readFile(ssh, options.source, 'utf8', function(err, json) {
      if (!err) {
        options.content = merge(JSON.parse(json), options.content);
      }
      return callback(err);
    });
  });
  this.call({
    if: options.transform
  }, function() {
    return options.content = options.transform(options.content);
  });
  return this.file({
    target: options.target,
    content: function() {
      return JSON.stringify(options.content, null, options.pretty);
    },
    backup: options.backup,
    diff: options.diff,
    eof: options.eof,
    gid: options.gid,
    uid: options.uid,
    mode: options.mode
  });
};

// ## Dependencies
fs = require('ssh2-fs');

({merge} = require('../misc'));
