// Generated by CoffeeScript 1.12.5
var file, fs, misc, pad,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

module.exports = function(options) {
  var algo, filetype, hash;
  options.log({
    message: "Entering file.assert",
    level: 'DEBUG',
    module: 'nikita/lib/file/assert'
  });
  if (options.encoding == null) {
    options.encoding = 'utf8';
  }
  if (options.target == null) {
    options.target = options.argument;
  }
  if (options.target == null) {
    options.target = options.source;
  }
  if (options.filetype == null) {
    options.filetype = [];
  }
  if (!Array.isArray(options.filetype)) {
    options.filetype = [options.filetype];
  }
  options.filetype = (function() {
    var i, len, ref, results;
    ref = options.filetype;
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      filetype = ref[i];
      if (!filetype) {
        continue;
      }
      if (typeof filetype === 'string') {
        switch (filetype.toLowerCase()) {
          case 'ifreg':
          case 'file':
            results.push(fs.constants.S_IFREG);
            break;
          case 'ifdir':
          case 'directory':
            results.push(fs.constants.S_IFDIR);
            break;
          case 'ifchr':
          case 'chardevice':
            results.push(fs.constants.S_IFCHR);
            break;
          case 'iffblk':
          case 'blockdevice':
            results.push(fs.constants.S_IFBLK);
            break;
          case 'ififo':
          case 'fifo':
            results.push(fs.constants.S_IFIFO);
            break;
          case 'iflink':
          case 'symlink':
            results.push(fs.constants.S_IFLNK);
            break;
          case 'ifsock':
          case 'socket':
            results.push(fs.constants.S_IFSOCK);
            break;
          default:
            results.push(filetype);
        }
      } else {
        results.push(filetype);
      }
    }
    return results;
  })();
  if (options.mode == null) {
    options.mode = [];
  }
  if (!Array.isArray(options.mode)) {
    options.mode = [options.mode];
  }
  if (!options.target) {
    throw Error('Missing option: "target"');
  }
  if (typeof options.content === 'string') {
    options.content = Buffer.from(options.content, options.encoding);
  } else if ((options.content != null) && !Buffer.isBuffer(options.content) && !options.content instanceof RegExp) {
    throw Error("Invalid option 'content': expect string, buffer or regexp");
  }
  this.call({
    unless: (options.content != null) || options.md5 || options.sha1 || options.sha256 || options.mode.length
  }, function(_, callback) {
    return fs.exists(options.ssh, options.target.toString(), function(err, exists) {
      if (!options.not) {
        if (!exists) {
          if (options.error == null) {
            options.error = "File does not exists: " + (JSON.stringify(options.target));
          }
          err = Error(options.error);
        }
      } else {
        if (exists) {
          if (options.error == null) {
            options.error = "File exists: " + (JSON.stringify(options.target));
          }
          err = Error(options.error);
        }
      }
      return callback(err);
    });
  });
  this.call({
    "if": options.filetype.length
  }, function(_, callback) {
    return fs.lstat(options.ssh, options.target, function(err, stat) {
      var ref, ref1, ref2, ref3, ref4, ref5, ref6;
      if (err) {
        return callback(err);
      }
      if (ref = fs.constants.S_IFREG, indexOf.call(options.filetype, ref) >= 0) {
        if (!stat.isFile()) {
          return callback(Error("Invalid filetype: expect a regular file"));
        }
      } else if (ref1 = fs.constants.S_IFDIR, indexOf.call(options.filetype, ref1) >= 0) {
        if (!stat.isDirectory()) {
          return callback(Error("Invalid filetype: expect a directory"));
        }
      } else if (ref2 = fs.constants.S_IFCHR, indexOf.call(options.filetype, ref2) >= 0) {
        if (!stat.isCharacterDevice()) {
          return callback(Error("Invalid filetype: expect a character-oriented device file"));
        }
      } else if (ref3 = fs.constants.S_IFBLK, indexOf.call(options.filetype, ref3) >= 0) {
        if (!stat.isBlockDevice()) {
          return callback(Error("Invalid filetype: expect a block-oriented device file"));
        }
      } else if (ref4 = fs.constants.S_IFIFO, indexOf.call(options.filetype, ref4) >= 0) {
        if (!stat.isFIFO()) {
          return callback(Error("Invalid filetype: expect a FIFO/pipe"));
        }
      } else if (ref5 = fs.constants.S_IFLNK, indexOf.call(options.filetype, ref5) >= 0) {
        if (!stat.isSymbolicLink()) {
          return callback(Error("Invalid filetype: expect a symbolic link"));
        }
      } else if (ref6 = fs.constants.S_IFSOCK, indexOf.call(options.filetype, ref6) >= 0) {
        if (!stat.isSocket()) {
          return callback(Error("Invalid filetype: expect a socket"));
        }
      } else {
        return callback(Error("Invalid filetype: " + (options.filetype.join(' '))));
      }
      return callback();
    });
  });
  this.call({
    "if": (options.content != null) && (typeof options.content === 'string' || Buffer.isBuffer(options.content))
  }, function(_, callback) {
    return fs.readFile(options.ssh, options.target, function(err, buffer) {
      if (err) {
        return callback(err);
      }
      if (!options.not) {
        if (!buffer.equals(options.content)) {
          if (options.error == null) {
            options.error = "Invalid content: expect " + (JSON.stringify(options.content.toString())) + " and got " + (JSON.stringify(buffer.toString()));
          }
          err = Error(options.error);
        }
      } else {
        if (buffer.equals(options.content)) {
          if (options.error == null) {
            options.error = "Unexpected content: " + (JSON.stringify(options.content.toString()));
          }
          err = Error(options.error);
        }
      }
      return callback(err);
    });
  });
  this.call({
    "if": (options.content != null) && options.content instanceof RegExp
  }, function(_, callback) {
    return fs.readFile(options.ssh, options.target, function(err, buffer) {
      if (err) {
        return callback(err);
      }
      if (!options.not) {
        if (!options.content.test(buffer)) {
          if (options.error == null) {
            options.error = "Invalid content match: expect " + (JSON.stringify(options.content.toString())) + " and got " + (JSON.stringify(buffer.toString()));
          }
          err = Error(options.error);
        }
      } else {
        if (options.content.test(buffer)) {
          if (options.error == null) {
            options.error = "Unexpected content match: " + (JSON.stringify(options.content.toString()));
          }
          err = Error(options.error);
        }
      }
      return callback(err);
    });
  });
  if (options.md5) {
    algo = 'md5';
    hash = options.md5;
  }
  if (options.sha1) {
    algo = 'sha1';
    hash = options.sha1;
  }
  if (options.sha256) {
    algo = 'sha256';
    hash = options.sha256;
  }
  this.call({
    "if": algo
  }, function(_, callback) {
    return file.hash(options.ssh, options.target, algo, (function(_this) {
      return function(err, h) {
        if ((err != null ? err.code : void 0) === 'ENOENT') {
          return callback(Error("Target does not exists: " + options.target));
        }
        if (err) {
          return callback(err);
        }
        if (!options.not) {
          if (hash !== h) {
            if (options.error == null) {
              options.error = "Invalid " + algo + " signature: expect " + (JSON.stringify(hash)) + " and got " + (JSON.stringify(h));
            }
            err = Error(options.error);
          }
        } else {
          if (hash === h) {
            if (options.error == null) {
              options.error = "Matching " + algo + " signature: " + (JSON.stringify(hash));
            }
            err = Error(options.error);
          }
        }
        return callback(err);
      };
    })(this));
  });
  this.call({
    "if": options.uid
  }, function(_, callback) {
    return fs.stat(options.ssh, options.target, function(err, stat) {
      if ((err != null ? err.code : void 0) === 'ENOENT') {
        return callback(Error("Target does not exists: " + options.target));
      }
      if (!options.not) {
        if (("" + stat.uid) !== ("" + options.uid)) {
          if (options.error == null) {
            options.error = "Unexpected uid: expected \"" + options.uid + "\" and got \"" + stat.uid + "\"";
          }
          err = Error(options.error);
        }
      } else {
        if (("" + stat.uid) === ("" + options.uid)) {
          if (options.error == null) {
            options.error = "Unexpected matching uid: expected \"" + options.uid + "\"";
          }
          err = Error(options.error);
        }
      }
      return callback(err);
    });
  });
  this.call({
    "if": options.gid
  }, function(_, callback) {
    return fs.stat(options.ssh, options.target, function(err, stat) {
      if ((err != null ? err.code : void 0) === 'ENOENT') {
        return callback(Error("Target does not exists: " + options.target));
      }
      if (!options.not) {
        if (("" + stat.gid) !== ("" + options.gid)) {
          if (options.error == null) {
            options.error = "Unexpected gid: expected \"" + options.gid + "\" and got \"" + stat.gid + "\"";
          }
          err = Error(options.error);
        }
      } else {
        if (("" + stat.gid) === ("" + options.gid)) {
          if (options.error == null) {
            options.error = "Unexpected matching gid: expected \"" + options.gid + "\"";
          }
          err = Error(options.error);
        }
      }
      return callback(err);
    });
  });
  return this.call({
    "if": options.mode.length
  }, function(_, callback) {
    return fs.stat(options.ssh, options.target, function(err, stat) {
      var expect;
      if ((err != null ? err.code : void 0) === 'ENOENT') {
        return callback(Error("Target does not exists: " + options.target));
      }
      if (!options.not) {
        if (!misc.mode.compare(options.mode, stat.mode)) {
          expect = options.mode.map(function(mode) {
            return "" + (pad(4, misc.mode.stringify(mode), '0'));
          });
          if (options.error == null) {
            options.error = "Invalid mode: expect " + expect + " and got " + (misc.mode.stringify(stat.mode).substr(-4));
          }
          err = Error(options.error);
        }
      } else {
        if (misc.mode.compare(options.mode, stat.mode)) {
          expect = options.mode.map(function(mode) {
            return "" + (pad(4, misc.mode.stringify(mode), '0'));
          });
          if (options.error == null) {
            options.error = "Unexpected valid mode: " + expect;
          }
          err = Error(options.error);
        }
      }
      return callback(err);
    });
  });
};

pad = require('pad');

fs = require('ssh2-fs');

file = require('../misc/file');

misc = require('../misc');
