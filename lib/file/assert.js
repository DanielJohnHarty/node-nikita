// Generated by CoffeeScript 1.12.4
var file, fs, misc, pad;

module.exports = function(options) {
  var algo, hash;
  options.log({
    message: "Entering file.assert",
    level: 'DEBUG',
    module: 'nikita/lib/file/assert'
  });
  if (options.encoding == null) {
    options.encoding = 'utf8';
  }
  if (options.target == null) {
    options.target = options.argument;
  }
  if (options.target == null) {
    options.target = options.source;
  }
  if (!options.target) {
    throw Error('Missing option: "target"');
  }
  if (typeof options.content === 'string') {
    options.content = Buffer.from(options.content, options.encoding);
  } else if ((options.content != null) && !Buffer.isBuffer(options.content) && !options.content instanceof RegExp) {
    throw Error("Invalid option 'content': expect string, buffer or regexp");
  }
  this.call({
    unless: (options.content != null) || options.md5 || options.sha1 || options.sha256 || options.mode
  }, function(_, callback) {
    return fs.exists(options.ssh, options.target.toString(), function(err, exists) {
      if (!options.not) {
        if (!exists) {
          if (options.error == null) {
            options.error = "File does not exists: " + (JSON.stringify(options.target));
          }
          err = Error(options.error);
        }
      } else {
        if (exists) {
          if (options.error == null) {
            options.error = "File exists: " + (JSON.stringify(options.target));
          }
          err = Error(options.error);
        }
      }
      return callback(err);
    });
  });
  this.call({
    "if": options.content && (typeof options.content === 'string' || Buffer.isBuffer(options.content))
  }, function(_, callback) {
    return fs.readFile(options.ssh, options.target, function(err, buffer) {
      if (err) {
        return callback(err);
      }
      if (!options.not) {
        if (!buffer.equals(options.content)) {
          if (options.error == null) {
            options.error = "Invalid content: expect " + (JSON.stringify(options.content.toString())) + " and got " + (JSON.stringify(buffer.toString()));
          }
          err = Error(options.error);
        }
      } else {
        if (buffer.equals(options.content)) {
          if (options.error == null) {
            options.error = "Unexpected content: " + (JSON.stringify(options.content.toString()));
          }
          err = Error(options.error);
        }
      }
      return callback(err);
    });
  });
  this.call({
    "if": options.content && options.content instanceof RegExp
  }, function(_, callback) {
    return fs.readFile(options.ssh, options.target, function(err, buffer) {
      if (err) {
        return callback(err);
      }
      if (!options.not) {
        if (!options.content.test(buffer)) {
          if (options.error == null) {
            options.error = "Invalid content match: expect " + (JSON.stringify(options.content.toString())) + " and got " + (JSON.stringify(buffer.toString()));
          }
          err = Error(options.error);
        }
      } else {
        if (options.content.test(buffer)) {
          if (options.error == null) {
            options.error = "Unexpected content match: " + (JSON.stringify(options.content.toString()));
          }
          err = Error(options.error);
        }
      }
      return callback(err);
    });
  });
  if (options.md5) {
    algo = 'md5';
    hash = options.md5;
  }
  if (options.sha1) {
    algo = 'sha1';
    hash = options.sha1;
  }
  if (options.sha256) {
    algo = 'sha256';
    hash = options.sha256;
  }
  this.call({
    "if": algo
  }, function(_, callback) {
    return file.hash(options.ssh, options.target, algo, (function(_this) {
      return function(err, h) {
        if ((err != null ? err.code : void 0) === 'ENOENT') {
          return callback(Error("Target does not exists: " + options.target));
        }
        if (err) {
          return callback(err);
        }
        if (!options.not) {
          if (hash !== h) {
            if (options.error == null) {
              options.error = "Invalid " + algo + " signature: expect " + (JSON.stringify(hash)) + " and got " + (JSON.stringify(h));
            }
            err = Error(options.error);
          }
        } else {
          if (hash === h) {
            if (options.error == null) {
              options.error = "Matching " + algo + " signature: " + (JSON.stringify(hash));
            }
            err = Error(options.error);
          }
        }
        return callback(err);
      };
    })(this));
  });
  return this.call({
    "if": options.mode
  }, function(_, callback) {
    return fs.stat(options.ssh, options.target, function(err, stat) {
      if ((err != null ? err.code : void 0) === 'ENOENT') {
        return callback(Error("Target does not exists: " + options.target));
      }
      if (!options.not) {
        if (!misc.mode.compare(options.mode, stat.mode)) {
          if (options.error == null) {
            options.error = "Invalid mode: expect " + (pad(4, misc.mode.stringify(options.mode), '0')) + " and got " + (misc.mode.stringify(stat.mode).substr(-4));
          }
          err = Error(options.error);
        }
      } else {
        if (misc.mode.compare(options.mode, stat.mode)) {
          if (options.error == null) {
            options.error = "Unexpected valid mode: " + (pad(4, misc.mode.stringify(options.mode), '0'));
          }
          err = Error(options.error);
        }
      }
      return callback(err);
    });
  });
};

pad = require('pad');

fs = require('ssh2-fs');

file = require('../misc/file');

misc = require('../misc');
