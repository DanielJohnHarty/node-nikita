// Generated by CoffeeScript 2.1.1
// # `nikita.file.properties(options, callback)`

// Write a file in the Java properties format.

// ## Options

// * `backup` (string|boolean)   
//   Create a backup, append a provided string to the filename extension or a
//   timestamp if value is not a string, only apply if the target file exists and
//   is modified.
// * `content` (object)   
//   List of properties to write.
// * `target` (string)   
//   File path where to write content to.
// * `local` (boolean)   
//   Treat the source as local instead of remote, only apply with "ssh"
//   option.
// * `sort` (boolean)   
//   Sort the properties before writting them. False by default
// * `merge` (boolean)   
//   Merges content properties with target file. False by default
// * `separator` (string)   
//   The caracter to use for separating property and value. '=' by default.

// ## Exemple

// Use a custom delimiter with spaces around the equal sign.

// ```javascript
// require('nikita')
// .file.properties({
//   target: "/path/to/target.json",
//   content: { key: "value" },
//   separator: ' = '
//   merge: true
// })
// ```

// ## Source Code
var fs, quote, string;

module.exports = function(options) {
  var fnl_props, org_props, ssh;
  options.log({
    message: "Entering file.properties",
    level: 'DEBUG',
    module: 'nikita/lib/file/properties'
  });
  // SSH connection
  ssh = this.ssh(options.ssh);
  if (!options.target) {
    // Options
    throw Error("Missing argument options.target");
  }
  if (options.separator == null) {
    options.separator = '=';
  }
  if (options.content == null) {
    options.content = {};
  }
  if (options.sort == null) {
    options.sort = false;
  }
  // org_props = if options.merge then {} else options.content
  fnl_props = options.content;
  org_props = {};
  options.log({
    message: `Merging "${(options.merge ? 'true' : 'false')}"`,
    level: 'DEBUG',
    module: 'nikita/lib/file/properties'
  });
  // Read Original
  this.call(function(_, callback) {
    options.log({
      message: `Reading target "${options.target}"`,
      level: 'DEBUG',
      module: 'nikita/lib/file/properties'
    });
    return module.exports.properties(ssh, options.target, options, function(err, props) {
      if (err) {
        return callback(err);
      }
      org_props = props;
      return callback();
    });
  });
  // Diff
  this.call(function(_, callback) {
    var i, j, k, key, keys, l, len, len1, len2, ref, ref1, ref2, status;
    status = false;
    keys = {};
    ref = Object.keys(org_props);
    for (i = 0, len = ref.length; i < len; i++) {
      k = ref[i];
      keys[k] = true;
    }
    ref1 = Object.keys(fnl_props);
    for (j = 0, len1 = ref1.length; j < len1; j++) {
      k = ref1[j];
      keys[k] = true; // unless keys[k]?
    }
    ref2 = Object.keys(keys);
    for (l = 0, len2 = ref2.length; l < len2; l++) {
      key = ref2[l];
      if (`${org_props[key]}` !== `${fnl_props[key]}`) {
        if (typeof options.log === "function") {
          options.log({
            message: `Property '${key}' was '${org_props[k]}' and is now '${fnl_props[k]}'`,
            level: 'WARN',
            module: 'ryba/lib/file/properties'
          });
        }
        if (fnl_props[key] != null) {
          status = true;
        }
      }
    }
    return callback(null, status);
  });
  // Merge
  this.call({
    if: options.merge
  }, function() {
    var k, v;
    for (k in fnl_props) {
      v = fnl_props[k];
      org_props[k] = fnl_props[k];
    }
    return fnl_props = org_props;
  });
  return this.call(function() {
    var data, key, keys;
    // Write data
    keys = options.sort ? Object.keys(fnl_props).sort() : Object.keys(fnl_props);
    data = (function() {
      var i, len, results;
      results = [];
      for (i = 0, len = keys.length; i < len; i++) {
        key = keys[i];
        if (fnl_props[key] != null) {
          results.push(`${key}${options.separator}${fnl_props[key]}`);
        } else {
          results.push(`${key // This is a comment
}`);
        }
      }
      return results;
    })();
    this.file({
      target: `${options.target}`,
      content: data.join('\n'),
      backup: options.backup,
      eof: true,
      shy: true
    });
    this.system.chown({
      target: options.target,
      uid: options.uid,
      gid: options.gid,
      if: (options.uid != null) || (options.gid != null)
    });
    return this.system.chmod({
      target: options.target,
      mode: options.mode,
      if: options.mode != null
    });
  });
};

module.exports.properties = function(ssh, source, options, callback) {
  return fs.readFile(ssh, source, 'utf8', function(err, data) {
    var _, i, k, len, line, lines, props, v;
    if ((err != null ? err.code : void 0) === 'ENOENT') {
      return callback(null, {});
    }
    if (err) {
      return callback(err);
    }
    if (options.separator == null) {
      options.separator = '=';
    }
    props = {};
    // Parse
    lines = string.lines(data);
    for (i = 0, len = lines.length; i < len; i++) {
      line = lines[i];
      if (/^\s*$/.test(line)) { // Empty line
        continue;
      }
      if (/^#/.test(line)) { // Comment
        if (options.comment) {
          props[line] = null;
        }
        continue;
      }
      [_, k, v] = RegExp(`^(.*?)${quote(options.separator)}(.*)$`).exec(line);
      props[k] = v;
    }
    return callback(null, props);
  });
};

// ## Dependencies
fs = require('ssh2-fs');

quote = require('regexp-quote');

string = require('../misc/string');
