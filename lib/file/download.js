// Generated by CoffeeScript 2.0.3
  // # `nikita.file.download(options, [callback])`

  // Download files using various protocols.

  // In local mode (with an SSH connection), the `http` protocol is handled with the
  // "request" module when executed locally, the `ftp` protocol is handled with the
  // "jsftp" and the `file` protocol is handle with the native `fs` module.

  // The behavior of download may be confusing wether you are running over SSH or
  // not. It's philosophy mostly rely on the target point of view. When download
  // run, the target is local, compared to the upload function where target
  // is remote.

  // A checksum may provided with the option "sha256", "sha1" or "md5" to validate the uploaded
  // file signature.

  // Caching is active if "cache_dir" or "cache_file" are defined to anything but false.
  // If cache_dir is not a string, default value is './'
  // If cache_file is not a string, default is source basename.

  // Nikita resolve the path from "cache_dir" to "cache_file", so if cache_file is an
  // absolute path, "cache_dir" will be ignored

  // If no cache is used, signature validation is only active if a checksum is
  // provided.

  // If cache is used, signature validation is always active, and md5sum is automatically
  // calculated if neither sha256, sh1 nor md5 is provided.

  // ## Options

  // * `cache` (boolean)   
  //   Activate the cache, default to true if either "cache_dir" or "cache_file" is
  //   activated.   
  // * `cache_dir` (path)   
  //   If local_cache is not a string, the cache file path is resolved from cache
  //   dir and cache file.   
  //   By default: './'   
  // * `cache_file` (string | boolean)   
  //   Cache the file on the executing machine, equivalent to cache unless an ssh
  //   connection is provided. If a string is provided, it will be the cache path.   
  //   By default: basename of source   
  // * `force` (boolean)   
  //   Overwrite target file if it exists.   
  // * `force_cache` (boolean)   
  //   Force cache overwrite if it exists   
  // * `gid`   
  //   Group name or id who owns the target file.   
  // * `headers` (array)   
  //   Extra  header  to include in the request when sending HTTP to a server.   
  // * `location` (boolean)   
  //   If the server reports that the requested page has moved to a different
  //   location (indicated with a Location: header and a 3XX response code), this
  //   option will make curl redo the request on the new place.   
  // * `md5` (MD5 Hash)   
  //   Hash of the file using MD5. Used to check integrity
  // * `mode` (octal mode)   
  //   Permissions of the target. If specified, nikita will chmod after download   
  // * `proxy` (string)   
  //   Use the specified HTTP proxy. If the port number is not specified, it is
  //   assumed at port 1080. See curl(1) man page.   
  // * `sha1` (SHA-1 Hash)   
  //   Hash of the file using SHA-1. Used to check integrity.   
  // * `sha256` (SHA-256 Hash)   
  //   Hash of the file using SHA-256. Used to check integrity.   
  // * `source` (path)   
  //   File, HTTP URL, FTP, GIT repository. File is the default protocol if source
  //   is provided without any.   
  // * `target` (path)   
  //   Path where the file is downloaded.   
  // * `uid`   
  //   User name or id who owns the target file.   

  // ## Callback parameters

  // * `err`   
  //   Error object if any.   
  // * `downloaded`   
  //   Value is "true" if file was downloaded.   

  // ## File example

  // ```js
  // require('nikita').download({
  //   source: 'file://path/to/something',
  //   target: 'node-sigar.tgz'
  // }, function(err, downloaded){
  //   console.log(err ? err.message : 'File was downloaded: ' + downloaded);
  // });
  // ```

  // ## HTTP example

  // ```coffee
  // nikita.download
  //   source: 'https://github.com/wdavidw/node-nikita/tarball/v0.0.1'
  //   target: 'node-sigar.tgz'
  // , (err, downloaded) -> ...
  // ```

  // ## FTP example

  // ```coffee
  // nikita.download
  //   source: 'ftp://myhost.com:3334/wdavidw/node-nikita/tarball/v0.0.1'
  //   target: 'node-sigar.tgz'
  //   user: 'johndoe',
  //   pass: '12345'
  // , (err, downloaded) -> ...
  // ```

  // ## Source Code
var curl, file, fs, path, ssh2fs, url,
  indexOf = [].indexOf;

module.exports = function(options) {
  var algo, protocols_ftp, protocols_http, ref, ref1, ref2, source_hash, source_url, stageDestination;
  options.log({
    message: 'Entering file.download',
    level: 'DEBUG',
    module: 'nikita/lib/file/download'
  });
  if (!options.source) {
    throw Error(`Missing source: ${options.source}`);
  }
  if (!options.target) {
    throw Error(`Missing target: ${options.target}`);
  }
  if (/^file:\/\//.test(options.source)) {
    options.source = options.source.substr(7);
  }
  stageDestination = null;
  if (options.md5 != null) {
    if ((ref = typeof options.md5) !== 'string' && ref !== 'boolean') {
      throw Error(`Invalid MD5 Hash:${options.md5}`);
    }
    algo = 'md5';
    source_hash = options.md5;
  } else if (options.sha1 != null) {
    if ((ref1 = typeof options.sha1) !== 'string' && ref1 !== 'boolean') {
      throw Error(`Invalid SHA-1 Hash:${options.sha1}`);
    }
    algo = 'sha1';
    source_hash = options.sha1;
  } else if (options.sha256 != null) {
    if ((ref2 = typeof options.sha256) !== 'string' && ref2 !== 'boolean') {
      throw Error(`Invalid SHA-256 Hash:${options.sha256}`);
    }
    algo = 'sha256';
    source_hash = options.sha256;
  } else {
    algo = 'md5';
  }
  protocols_http = ['http:', 'https:'];
  protocols_ftp = ['ftp:', 'ftps:'];
  // hash_info = null
  options.log({
    message: `Using force: ${JSON.stringify(options.force)}`,
    level: 'DEBUG',
    module: 'nikita/lib/file/download'
  });
  source_url = url.parse(options.source);
  if ((options.cache == null) && source_url.protocol === null) {
    // Disable caching if source is a local file and cache isnt exlicitly set by user
    options.cache = false;
  }
  if (options.cache == null) {
    options.cache = !!(options.cache_dir || options.cache_file);
  }
  this.call({ // Accelarator in case we know the target signature
    if: typeof source_hash === 'string',
    shy: true,
    handler: function(_, callback) {
      options.log({
        message: "Shortcircuit check if provided hash match target",
        level: 'WARN',
        module: 'nikita/lib/file/download'
      });
      return file.hash(options.ssh, options.target, algo, (err, hash) => {
        if ((err != null ? err.code : void 0) === 'ENOENT') {
          err = null;
        }
        return callback(err, source_hash === hash);
      });
    }
  }, function(err, end) {
    if (!end) {
      return;
    }
    options.log({
      message: "Destination with valid signature, download aborted",
      level: 'INFO',
      module: 'nikita/lib/file/download'
    });
    return this.end();
  });
  this.file.cache({ // Download the file and place it inside local cache
    if: options.cache,
    ssh: null,
    source: options.source,
    cache_dir: options.cache_dir,
    cache_file: options.cache_file,
    headers: options.headers,
    md5: options.md5,
    proxy: options.proxy,
    location: options.location
  }, function(err, cached, file) {
    if (err) {
      throw err;
    }
    if (options.cache) {
      options.source = file;
    }
    return source_url = url.parse(options.source);
  });
  this.call(function(_, callback) {
    return ssh2fs.stat(this.options.ssh, options.target, function(err, stat) {
      if (err && err.code !== 'ENOENT') {
        return callback(err);
      }
      if (stat != null ? stat.isDirectory() : void 0) {
        options.log({
          message: "Destination is a directory",
          level: 'DEBUG',
          module: 'nikita/lib/file/download'
        });
        options.target = path.join(options.target, path.basename(options.source));
      }
      stageDestination = `${options.target}.${Date.now()}${Math.round(Math.random() * 1000)}`;
      return callback();
    });
  });
  this.call({
    if: function() {
      var ref3;
      return ref3 = source_url.protocol, indexOf.call(protocols_http, ref3) >= 0;
    },
    handler: function() {
      var cmd, fail, k;
      options.log({
        message: "HTTP Download",
        level: 'DEBUG',
        module: 'nikita/lib/file/download'
      });
      fail = options.fail ? "--fail" : '';
      k = source_url.protocol === 'https:' ? '-k' : '';
      cmd = `curl ${fail} ${k} -s ${options.source} -o ${stageDestination}`;
      if (options.proxy) {
        cmd += ` -x ${options.proxy}`;
      }
      options.log({
        message: "Download file from url using curl",
        level: 'INFO',
        module: 'nikita/lib/file/download'
      });
      this.system.mkdir({
        shy: true,
        target: path.dirname(stageDestination)
      });
      this.system.execute({
        cmd: cmd,
        shy: true
      });
      this.call({
        if: typeof source_hash === 'string',
        handler: function(_, callback) {
          return file.hash(options.ssh, stageDestination, algo, (err, hash) => {
            if (source_hash !== hash) {
              return callback(Error(`Invalid downloaded checksum, found '${hash}' instead of '${source_hash}'`));
            }
            return callback();
          });
        }
      });
      this.call(function(_, callback) {
        return file.compare_hash((options.cache ? null : options.ssh), stageDestination, options.ssh, options.target, algo, function(err, match, hash1, hash2) {
          if (!match) {
            options.log({
              message: `Hash dont match, source is '${hash1}' and target is '${hash2}'`,
              level: 'WARN',
              module: 'nikita/lib/file/download'
            });
          }
          if (match) {
            options.log({
              message: `Hash matches as '${hash1}'`,
              level: 'INFO',
              module: 'nikita/lib/file/download'
            });
          }
          return callback(err, !match);
        });
      });
      return this.system.remove({
        unless: function() {
          return this.status(-1);
        },
        shy: true,
        target: stageDestination
      });
    }
  });
  this.call({
    if: function() {
      var ref3;
      return (ref3 = source_url.protocol, indexOf.call(protocols_http, ref3) < 0) && !options.ssh;
    },
    handler: function() {
      options.log({
        message: "File Download without ssh (with or without cache)",
        level: 'DEBUG',
        module: 'nikita/lib/file/download'
      });
      this.call(function(_, callback) {
        return file.compare_hash(null, options.source, null, options.target, algo, function(err, match, hash1, hash2) {
          if (!match) {
            options.log({
              message: `Hash dont match, source is '${hash1}' and target is '${hash2}'`,
              level: 'WARN',
              module: 'nikita/lib/file/download'
            });
          }
          if (match) {
            options.log({
              message: `Hash matches as '${hash1}'`,
              level: 'INFO',
              module: 'nikita/lib/file/download'
            });
          }
          return callback(err, !match);
        });
      });
      this.system.mkdir({
        if: function() {
          return this.status(-1);
        },
        shy: true,
        target: path.dirname(stageDestination)
      });
      return this.call({
        if: function() {
          return this.status(-2);
        },
        handler: function(_, callback) {
          var rs, ws;
          rs = fs.createReadStream(options.source);
          rs.on('error', function(err) {
            options.log({
              message: `No such source file: ${options.source} (ssh is ${JSON.stringify(!!options.ssh)})`,
              level: 'ERROR',
              module: 'nikita/lib/file/download'
            });
            err.message = 'No such source file';
            return callback(err);
          });
          ws = fs.createWriteStream(stageDestination);
          return rs.pipe(ws).on('close', callback).on('error', callback);
        }
      });
    }
  });
  this.call({
    if: function() {
      var ref3;
      return (ref3 = source_url.protocol, indexOf.call(protocols_http, ref3) < 0) && options.ssh;
    },
    handler: function() {
      options.log({
        message: "File Download with ssh (with or without cache)",
        level: 'DEBUG',
        module: 'nikita/lib/file/download'
      });
      this.call(function(_, callback) {
        return file.compare_hash(null, options.source, options.ssh, options.target, algo, function(err, match, hash1, hash2) {
          if (!match) {
            options.log({
              message: `Hash dont match, source is '${hash1}' and target is '${hash2}'`,
              level: 'WARN',
              module: 'nikita/lib/file/download'
            });
          }
          if (match) {
            options.log({
              message: `Hash matches as '${hash1}'`,
              level: 'INFO',
              module: 'nikita/lib/file/download'
            });
          }
          return callback(err, !match);
        });
      });
      this.system.mkdir({
        if: function() {
          return this.status(-1);
        },
        shy: true,
        target: path.dirname(stageDestination)
      });
      return this.call({
        if: function() {
          return this.status(-2);
        },
        handler: function(_, callback) {
          var rs;
          options.log({
            message: `Local source: '${options.source}'`,
            level: 'INFO',
            module: 'nikita/lib/file/download'
          });
          options.log({
            message: `Remote target: '${stageDestination}'`,
            level: 'INFO',
            module: 'nikita/lib/file/download'
          });
          rs = fs.createReadStream(options.source);
          rs.on('error', function(err) {
            return console.log('rs on error', err);
          });
          return ssh2fs.writeFile(options.ssh, stageDestination, rs, function(err) {
            if (err) {
              options.log("Upload failed from local to remote");
            }
            return callback(err);
          });
        }
      });
    }
  });
  return this.call(function() {
    options.log({
      message: "Unstage downloaded file",
      level: 'DEBUG',
      module: 'nikita/lib/file/download'
    });
    this.system.move({
      if: this.status(),
      source: stageDestination,
      target: options.target
    });
    this.system.chmod({
      target: options.target,
      mode: options.mode,
      if: options.mode != null
    });
    return this.system.chown({
      target: options.target,
      uid: options.uid,
      gid: options.gid,
      if: (options.uid != null) || (options.gid != null)
    });
  });
};

// ## Module Dependencies
fs = require('fs');

ssh2fs = require('ssh2-fs');

path = require('path').posix; // need to detect ssh connection

url = require('url');

curl = require('../misc/curl');

file = require('../misc/file');
