// Generated by CoffeeScript 1.8.0
var child, conditions, each, execute, misc;

module.exports = function(goptions, options, callback) {
  var finish, result, _ref;
  _ref = misc.args(arguments, {
    parallel: 1
  }), goptions = _ref[0], options = _ref[1], callback = _ref[2];
  result = child();
  finish = function(err, gmodified, installed, updates) {
    if (callback) {
      callback(err, gmodified, installed, updates);
    }
    return result.end(err, gmodified, installed, updates);
  };
  misc.options(options, function(err, options) {
    var installed, serviced, updates;
    if (err) {
      return callback(err);
    }
    serviced = 0;
    installed = updates = null;
    return each(options).parallel(goptions.parallel).on('item', function(options, next) {
      var action, chkname, do_chkinstalled, do_chkupdates, do_finish, do_install, do_started, do_startuped, modified, pkgname, srvname, startup_add, startup_del;
      if (typeof options.log === "function") {
        options.log("Mecano `service`");
      }
      if (!options.ssh) {
        return next(new Error('Restricted to Yum over SSH'));
      }
      pkgname = options.yum_name || options.name;
      chkname = options.chk_name || options.srv_name || options.name;
      srvname = options.srv_name || options.name;
      modified = false;
      if (installed == null) {
        installed = options.installed;
      }
      if (updates == null) {
        updates = options.updates;
      }
      do_chkinstalled = function() {
        var cache, decide;
        if (!pkgname) {
          return do_startuped();
        }
        cache = function() {
          var c;
          if (typeof options.log === "function") {
            options.log("Mecano `service: list installed");
          }
          c = options.cache ? '-C' : '';
          return execute({
            ssh: options.ssh,
            cmd: "yum -C list installed",
            code_skipped: 1,
            log: options.log
          }, function(err, executed, stdout) {
            var pkg, start, _i, _len;
            if (err) {
              return next(err);
            }
            stdout = stdout.split('\n');
            start = false;
            installed = [];
            for (_i = 0, _len = stdout.length; _i < _len; _i++) {
              pkg = stdout[_i];
              if (pkg.trim() === 'Installed Packages') {
                start = true;
              }
              if (!start) {
                continue;
              }
              if (pkg = /^([^\. ]+?)\./.exec(pkg)) {
                installed.push(pkg[1]);
              }
            }
            return decide();
          });
        };
        decide = function() {
          if (installed.indexOf(pkgname) !== -1) {
            return do_chkupdates();
          } else {
            return do_install();
          }
        };
        if (installed) {
          return decide();
        } else {
          return cache();
        }
      };
      do_chkupdates = function() {
        var cache, decide;
        cache = function() {
          var c;
          if (typeof options.log === "function") {
            options.log("Mecano `service`: list available updates");
          }
          c = options.cache ? '-C' : '';
          return execute({
            ssh: options.ssh,
            cmd: "yum " + c + " list updates",
            code_skipped: 1,
            log: options.log,
            stdout: options.stdout,
            stderr: options.stderr
          }, function(err, executed, stdout) {
            var pkg, start, _i, _len;
            if (err) {
              return next(err);
            }
            stdout = stdout.split('\n');
            start = false;
            updates = [];
            for (_i = 0, _len = stdout.length; _i < _len; _i++) {
              pkg = stdout[_i];
              if (pkg.trim() === 'Updated Packages') {
                start = true;
              }
              if (!start) {
                continue;
              }
              if (pkg = /^([^\. ]+?)\./.exec(pkg)) {
                updates.push(pkg[1]);
              }
            }
            return decide();
          });
        };
        decide = function() {
          if (updates.indexOf(pkgname) !== -1) {
            return do_install();
          } else {
            if (typeof options.log === "function") {
              options.log("Mecano `service`: No available update");
            }
            return do_startuped();
          }
        };
        if (updates) {
          return decide();
        } else {
          return cache();
        }
      };
      do_install = function() {
        if (typeof options.log === "function") {
          options.log("Mecano `service`: install \"" + pkgname + "\"");
        }
        return execute({
          ssh: options.ssh,
          cmd: "yum install -y " + pkgname,
          log: options.log,
          stdout: options.stdout,
          stderr: options.stderr
        }, function(err, succeed) {
          var installedIndex, updatesIndex;
          if (err) {
            return next(err);
          }
          installedIndex = installed.indexOf(pkgname);
          if (installedIndex === -1) {
            installed.push(pkgname);
          }
          if (updates) {
            updatesIndex = updates.indexOf(pkgname);
            if (updatesIndex !== -1) {
              updates.splice(updatesIndex, 1);
            }
          }
          if (!succeed) {
            return next(new Error("No package " + pkgname + " available."));
          }
          if (installedIndex !== -1) {
            modified = true;
          }
          return do_startuped();
        });
      };
      do_startuped = function() {
        if (options.startup == null) {
          return do_started();
        }
        if (typeof options.log === "function") {
          options.log("Mecano `service`: list startup services");
        }
        return execute({
          ssh: options.ssh,
          cmd: "chkconfig --list " + chkname,
          code_skipped: 1,
          log: options.log,
          stdout: options.stdout,
          stderr: options.stderr
        }, function(err, registered, stdout, stderr) {
          var c, current_startup, level, status, _i, _len, _ref1, _ref2;
          if (err) {
            return next(err);
          }
          if (/^error/.test(stderr)) {
            return next(new Error("Invalid chkconfig name " + chkname));
          }
          current_startup = '';
          if (registered) {
            _ref1 = stdout.split(' ').pop().trim().split('\t');
            for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
              c = _ref1[_i];
              _ref2 = c.split(':'), level = _ref2[0], status = _ref2[1];
              if (['on', 'marche'].indexOf(status) > -1) {
                current_startup += level;
              }
            }
          }
          if ((options.startup === true && current_startup.length) || (options.startup === current_startup)) {
            return do_started();
          }
          modified = true;
          if (options.startup) {
            return startup_add();
          } else {
            return startup_del();
          }
        });
      };
      startup_add = function() {
        var cmd, i, startup_off, startup_on, _i;
        if (typeof options.log === "function") {
          options.log("Mecano `service`: startup on");
        }
        cmd = "chkconfig --add " + chkname + ";";
        if (typeof options.startup === 'string') {
          startup_on = startup_off = '';
          for (i = _i = 0; _i < 6; i = ++_i) {
            if (options.startup.indexOf(i) !== -1) {
              startup_on += i;
            } else {
              startup_off += i;
            }
          }
          if (startup_on) {
            cmd += "chkconfig --level " + startup_on + " " + chkname + " on;";
          }
          if (startup_off) {
            cmd += "chkconfig --level " + startup_off + " " + chkname + " off;";
          }
        } else {
          cmd += "chkconfig " + chkname + " on;";
        }
        return execute({
          ssh: options.ssh,
          cmd: cmd,
          log: options.log,
          stdout: options.stdout,
          stderr: options.stderr
        }, function(err) {
          if (err) {
            return next(err);
          }
          return do_started();
        });
      };
      startup_del = function() {
        if (typeof options.log === "function") {
          options.log("Mecano `service`: startup off");
        }
        return execute({
          ssh: options.ssh,
          cmd: "chkconfig " + chkname + " off",
          log: options.log,
          stdout: options.stdout,
          stderr: options.stderr
        }, function(err) {
          if (err) {
            return next(err);
          }
          return do_started();
        });
      };
      do_started = function() {
        if (['start', 'stop'].indexOf(options.action) === -1) {
          return action();
        }
        if (['restart'].indexOf(options.action) !== -1) {
          return action();
        }
        if (typeof options.log === "function") {
          options.log("Mecano `service`: check if started");
        }
        return execute({
          ssh: options.ssh,
          cmd: "service " + srvname + " status",
          code_skipped: [3, 1],
          log: options.log,
          stdout: options.stdout,
          stderr: options.stderr
        }, function(err, started) {
          if (err) {
            return next(err);
          }
          if (started) {
            if (options.action !== 'start') {
              return action();
            }
          } else {
            if (options.action !== 'stop') {
              return action();
            }
          }
          return do_finish();
        });
      };
      action = function() {
        if (!options.action) {
          return do_finish();
        }
        if (typeof options.log === "function") {
          options.log("Mecano `service`: " + options.action + " service");
        }
        return execute({
          ssh: options.ssh,
          cmd: "service " + srvname + " " + options.action,
          log: options.log,
          stdout: options.stdout,
          stderr: options.stderr
        }, function(err, executed) {
          if (err) {
            return next(err);
          }
          modified = true;
          return do_finish();
        });
      };
      do_finish = function() {
        if (modified) {
          serviced++;
        }
        return next();
      };
      return conditions.all(options, next, do_chkinstalled);
    }).on('both', function(err) {
      return finish(err, serviced, installed, updates);
    });
  });
  return result;
};

each = require('each');

misc = require('./misc');

conditions = require('./misc/conditions');

child = require('./misc/child');

execute = require('./execute');
