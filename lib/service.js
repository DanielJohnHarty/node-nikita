// Generated by CoffeeScript 1.8.0
var each, execute, misc, string, wrap,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

module.exports = function(options, callback) {
  return wrap(arguments, function(options, callback) {
    var chkname, do_action, do_chkinstalled, do_chkupdates, do_finish, do_install, do_started, do_startuped, installed, modified, pkgname, srvname, startup_add, startup_del, updates;
    installed = updates = null;
    if (!options.ssh) {
      return callback(new Error('Restricted to Yum over SSH'));
    }
    pkgname = options.yum_name || options.name;
    chkname = options.chk_name || options.srv_name || options.name;
    srvname = options.srv_name || options.chk_name || options.name;
    modified = false;
    if (installed == null) {
      installed = options.installed;
    }
    if (updates == null) {
      updates = options.updates;
    }
    if (typeof options.action === 'string') {
      options.action = options.action.split(',');
    }
    do_chkinstalled = function() {
      var cache, decide;
      if (!pkgname) {
        return do_startuped();
      }
      cache = function() {
        var c;
        if (typeof options.log === "function") {
          options.log("Mecano `service: list installed");
        }
        c = options.cache ? '-C' : '';
        return execute({
          ssh: options.ssh,
          cmd: "yum -C list installed",
          code_skipped: 1,
          log: options.log
        }, function(err, executed, stdout) {
          var pkg, start, _i, _len;
          if (err) {
            return callback(err);
          }
          stdout = string.lines(stdout);
          start = false;
          installed = [];
          for (_i = 0, _len = stdout.length; _i < _len; _i++) {
            pkg = stdout[_i];
            if (pkg.trim() === 'Installed Packages') {
              start = true;
            }
            if (!start) {
              continue;
            }
            if (pkg = /^([^\. ]+?)\./.exec(pkg)) {
              installed.push(pkg[1]);
            }
          }
          return decide();
        });
      };
      decide = function() {
        if (installed.indexOf(pkgname) !== -1) {
          return do_chkupdates();
        } else {
          return do_install();
        }
      };
      if (installed) {
        return decide();
      } else {
        return cache();
      }
    };
    do_chkupdates = function() {
      var cache, decide;
      cache = function() {
        var c;
        if (typeof options.log === "function") {
          options.log("Mecano `service`: list available updates");
        }
        c = options.cache ? '-C' : '';
        return execute({
          ssh: options.ssh,
          cmd: "yum " + c + " list updates",
          code_skipped: 1,
          log: options.log,
          stdout: options.stdout,
          stderr: options.stderr
        }, function(err, executed, stdout) {
          var pkg, start, _i, _len;
          if (err) {
            return callback(err);
          }
          stdout = string.lines(stdout);
          start = false;
          updates = [];
          for (_i = 0, _len = stdout.length; _i < _len; _i++) {
            pkg = stdout[_i];
            if (pkg.trim() === 'Updated Packages') {
              start = true;
            }
            if (!start) {
              continue;
            }
            if (pkg = /^([^\. ]+?)\./.exec(pkg)) {
              updates.push(pkg[1]);
            }
          }
          return decide();
        });
      };
      decide = function() {
        if (updates.indexOf(pkgname) !== -1) {
          return do_install();
        } else {
          if (typeof options.log === "function") {
            options.log("Mecano `service`: No available update");
          }
          return do_startuped();
        }
      };
      if (updates) {
        return decide();
      } else {
        return cache();
      }
    };
    do_install = function() {
      if (typeof options.log === "function") {
        options.log("Mecano `service`: install \"" + pkgname + "\"");
      }
      return execute({
        ssh: options.ssh,
        cmd: "yum install -y " + pkgname,
        log: options.log,
        stdout: options.stdout,
        stderr: options.stderr
      }, function(err, succeed) {
        var installedIndex, updatesIndex;
        if (err) {
          return callback(err);
        }
        installedIndex = installed.indexOf(pkgname);
        if (installedIndex === -1) {
          installed.push(pkgname);
        }
        if (updates) {
          updatesIndex = updates.indexOf(pkgname);
          if (updatesIndex !== -1) {
            updates.splice(updatesIndex, 1);
          }
        }
        if (!succeed) {
          return callback(new Error("No package " + pkgname + " available."));
        }
        if (installedIndex !== -1) {
          modified = true;
        }
        return do_startuped();
      });
    };
    do_startuped = function() {
      if (options.startup == null) {
        return do_started();
      }
      if (typeof options.log === "function") {
        options.log("Mecano `service`: list startup services");
      }
      return execute({
        ssh: options.ssh,
        cmd: "chkconfig --list " + chkname,
        code_skipped: 1,
        log: options.log,
        stdout: options.stdout,
        stderr: options.stderr
      }, function(err, registered, stdout, stderr) {
        var c, current_startup, level, status, _i, _len, _ref, _ref1;
        if (err) {
          return callback(err);
        }
        if (/^error/.test(stderr)) {
          return callback(new Error("Invalid chkconfig name " + chkname));
        }
        current_startup = '';
        if (registered) {
          _ref = stdout.split(' ').pop().trim().split('\t');
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            c = _ref[_i];
            _ref1 = c.split(':'), level = _ref1[0], status = _ref1[1];
            if (['on', 'marche'].indexOf(status) > -1) {
              current_startup += level;
            }
          }
        }
        if ((options.startup === true && current_startup.length) || (options.startup === current_startup)) {
          return do_started();
        }
        modified = true;
        if (options.startup) {
          return startup_add();
        } else {
          return startup_del();
        }
      });
    };
    startup_add = function() {
      var cmd, i, startup_off, startup_on, _i;
      if (typeof options.log === "function") {
        options.log("Mecano `service`: startup on");
      }
      cmd = "chkconfig --add " + chkname + ";";
      if (typeof options.startup === 'string') {
        startup_on = startup_off = '';
        for (i = _i = 0; _i < 6; i = ++_i) {
          if (options.startup.indexOf(i) !== -1) {
            startup_on += i;
          } else {
            startup_off += i;
          }
        }
        if (startup_on) {
          cmd += "chkconfig --level " + startup_on + " " + chkname + " on;";
        }
        if (startup_off) {
          cmd += "chkconfig --level " + startup_off + " " + chkname + " off;";
        }
      } else {
        cmd += "chkconfig " + chkname + " on;";
      }
      return execute({
        ssh: options.ssh,
        cmd: cmd,
        log: options.log,
        stdout: options.stdout,
        stderr: options.stderr
      }, function(err) {
        if (err) {
          return callback(err);
        }
        return do_started();
      });
    };
    startup_del = function() {
      if (typeof options.log === "function") {
        options.log("Mecano `service`: startup off");
      }
      return execute({
        ssh: options.ssh,
        cmd: "chkconfig " + chkname + " off",
        log: options.log,
        stdout: options.stdout,
        stderr: options.stderr
      }, function(err) {
        if (err) {
          return callback(err);
        }
        return do_started();
      });
    };
    do_started = function() {
      if (!options.action) {
        return do_finish();
      }
      if (typeof options.log === "function") {
        options.log("Mecano `service`: check if started");
      }
      return execute({
        ssh: options.ssh,
        cmd: "service " + srvname + " status",
        code_skipped: [3, 1],
        log: options.log,
        stdout: options.stdout,
        stderr: options.stderr
      }, function(err, started) {
        if (err) {
          return callback(err);
        }
        if (started) {
          if (__indexOf.call(options.action, 'stop') >= 0) {
            return do_action('stop');
          }
          if (__indexOf.call(options.action, 'restart') >= 0) {
            return do_action('restart');
          }
        } else {
          if (__indexOf.call(options.action, 'start') >= 0) {
            return do_action('start');
          }
        }
        return do_finish();
      });
    };
    do_action = function(action) {
      if (!options.action) {
        return do_finish();
      }
      if (typeof options.log === "function") {
        options.log("Mecano `service`: " + action + " service");
      }
      return execute({
        ssh: options.ssh,
        cmd: "service " + srvname + " " + action,
        log: options.log,
        stdout: options.stdout,
        stderr: options.stderr
      }, function(err, executed) {
        if (err) {
          return callback(err);
        }
        modified = true;
        return do_finish();
      });
    };
    do_finish = function() {
      return callback(null, modified);
    };
    return do_chkinstalled();
  });
};

each = require('each');

execute = require('./execute');

misc = require('./misc');

string = require('./misc/string');

wrap = require('./misc/wrap');
