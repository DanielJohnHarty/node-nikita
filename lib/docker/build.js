// Generated by CoffeeScript 1.10.0
var docker, fs, merge, path, string, util,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
  slice = [].slice;

module.exports = function(options, callback) {
  var cmd, dockerfile_cmds, k, number_of_step, ref, source, userargs, v;
  if (options.docker == null) {
    options.docker = {};
  }
  ref = options.docker;
  for (k in ref) {
    v = ref[k];
    if (options[k] == null) {
      options[k] = v;
    }
  }
  if (options.image == null) {
    return callback(Error('Required option "image"'));
  }
  if ((options.content != null) && (options.file != null)) {
    return callback(Error('Can not build from Dockerfile and content'));
  }
  if (options.rm == null) {
    options.rm = true;
  }
  cmd = 'build';
  number_of_step = 0;
  userargs = [];
  dockerfile_cmds = ['CMD', 'LABEL', 'EXPOSE', 'ENV', 'ADD', 'COPY', 'ENTRYPOINT', 'VOLUME', 'USER', 'WORKDIR', 'ARG', 'ONBUILD', 'RUN', 'STOPSIGNAL', 'MAINTAINER'];
  source = null;
  if (options.file) {
    source = options.file;
  } else if (options.cwd) {
    source = options.cwd + "/Dockerfile";
  }
  if (options.file) {
    if (options.cwd == null) {
      options.cwd = path.dirname(options.file);
    }
  }
  this.write({
    "if": options.content,
    content: options.content,
    source: source,
    destination: function(content) {
      return options.content = content;
    },
    from: options.from,
    to: options.to,
    match: options.match,
    replace: options.replace,
    append: options.append,
    before: options.before,
    write: options.write
  });
  this.call(function() {
    var i, j, l, len, len1, len2, opt, ref1, ref2, ref3;
    ref1 = ['force_rm', 'quiet', 'no_cache'];
    for (i = 0, len = ref1.length; i < len; i++) {
      opt = ref1[i];
      if (options[opt]) {
        cmd += " --" + (opt.replace('_', '-'));
      }
    }
    ref2 = ['build_arg'];
    for (j = 0, len1 = ref2.length; j < len1; j++) {
      opt = ref2[j];
      if (options[opt] != null) {
        if (Array.isArray(options[opt])) {
          ref3 = options[opt];
          for (l = 0, len2 = ref3.length; l < len2; l++) {
            k = ref3[l];
            cmd += " --" + (opt.replace('_', '-')) + " " + k;
          }
        } else {
          cmd += " --" + (opt.replace('_', '-')) + " " + options[opt];
        }
      }
    }
    cmd += " --rm=" + (options.rm ? 'true' : 'false');
    cmd += " -t \"" + options.image + (options.tag ? ":" + options.tag : '') + "\"";
    if (options.cwd) {
      if (options.file == null) {
        options.file = path.resolve(options.cwd, 'Dockerfile');
      }
    }
    if (options.content != null) {
      options.log({
        message: "Building from text: Docker won't have a context. ADD/COPY not working",
        level: 'WARN',
        module: 'mecano/docker/build'
      });
      if (options.content != null) {
        return cmd += " - <<DOCKERFILE\n" + options.content + "\nDOCKERFILE";
      }
    } else if (options.file != null) {
      options.log({
        message: "Building from Dockerfile: \"" + options.file + "\"",
        level: 'INFO',
        module: 'mecano/docker/build'
      });
      return cmd += " -f " + options.file + " " + options.cwd;
    } else {
      options.log({
        message: "Building from CWD",
        level: 'INFO',
        module: 'mecano/docker/build'
      });
      return cmd += ' .';
    }
  });
  this.call({
    unless: options.content,
    handler: function(_, callback) {
      options.log({
        message: "Reading Dockerfile from : " + options.file,
        level: 'INFO',
        module: 'mecano/lib/build'
      });
      return fs.readFile(options.ssh, options.file, 'utf8', function(err, content) {
        if (err) {
          return callback(err);
        }
        options.content = content;
        return callback();
      });
    }
  });
  this.call(function() {
    var i, len, line, ref1, ref2, ref3, results;
    ref1 = string.lines(options.content);
    results = [];
    for (i = 0, len = ref1.length; i < len; i++) {
      line = ref1[i];
      if (ref2 = (ref3 = /^(.*?)\s/.exec(line)) != null ? ref3[1] : void 0, indexOf.call(dockerfile_cmds, ref2) >= 0) {
        results.push(number_of_step++);
      } else {
        results.push(void 0);
      }
    }
    return results;
  });
  return this.call(function() {
    return this.execute({
      cmd: docker.wrap(options, cmd),
      cwd: options.cwd
    }, function(err, executed, stdout, stderr) {
      var container_id_hash, line, lines, number_of_cache;
      if (err) {
        throw err;
      }
      container_id_hash = null;
      lines = string.lines(stderr);
      lines = string.lines(stdout);
      number_of_cache = 0;
      for (k in lines) {
        line = lines[k];
        if (line.indexOf('Using cache') !== -1) {
          number_of_cache = number_of_cache + 1;
        }
        if (line.indexOf('Successfully built') !== -1) {
          container_id_hash = line.split(' ').pop().toString();
        }
      }
      return userargs = [number_of_step !== number_of_cache, container_id_hash, stdout, stderr];
    });
  }).then(function(err, status) {
    if (err) {
      return callback(err);
    }
    options.log(userargs[0] ? {
      message: "New image id " + userargs[1],
      level: 'INFO',
      module: 'mecano/lib/docker/build'
    } : {
      message: "Identical image id " + userargs[1],
      level: 'INFO',
      module: 'mecano/lib/docker/build'
    });
    return callback.apply(null, [null].concat(slice.call(userargs)));
  });
};

docker = require('../misc/docker');

string = require('../misc/string');

path = require('path');

util = require('util');

fs = require('ssh2-fs');

merge = require('../misc').merge;
