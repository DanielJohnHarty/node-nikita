// Generated by CoffeeScript 1.10.0
var docker, fs, path, string, util,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
  slice = [].slice;

module.exports = function(options, callback) {
  var cmd, dockerfile_cmds, i, len, number_of_step, opt, ref, temp_dir, userargs;
  if (options.tag == null) {
    return callback(Error('Required option "tag"'));
  }
  if ((options.content != null) && (options.path != null)) {
    return callback(Error('Can not build from Dockerfile and content'));
  }
  cmd = ' build ';
  if (options.context != null) {
    string.render(options);
  }
  string.replace_partial(options);
  ref = ['force_rm', 'quiet', 'no_cache'];
  for (i = 0, len = ref.length; i < len; i++) {
    opt = ref[i];
    if (options[opt]) {
      cmd += " --" + (opt.replace('_', '-'));
    }
  }
  cmd += " --rm=" + (options.rm ? 'true' : 'false');
  cmd += " -t \"" + options.tag + "\"";
  if (options.cwd) {
    if (options.path == null) {
      options.path = path.resolve(options.cwd, 'Dockerfile');
    }
  }
  if (options.path != null) {
    options.log({
      message: "Building from Dockerfile: \"" + options.path + "\"",
      level: 'INFO',
      module: 'mecano/docker/build'
    });
    cmd += " -f " + options.path + " " + (path.dirname(options.path));
  } else if (options.content != null) {
    options.log({
      message: "Building from text: Docker won't have a context. ADD/COPY not working",
      level: 'WARN',
      module: 'mecano/docker/build'
    });
    if (options.content != null) {
      cmd += " - <<DOCKERFILE\n" + options.content + "\nDOCKERFILE";
    }
  } else {
    options.log({
      message: "Building from CWD",
      level: 'INFO',
      module: 'mecano/docker/build'
    });
    cmd += ' .';
  }
  dockerfile_cmds = ['CMD', 'LABEL', 'EXPOSE', 'ENV', 'ADD', 'COPY', 'ENTRYPOINT', 'VOLUME', 'USER', 'WORKDIR', 'ARG', 'ONBUILD', 'RUN', 'STOPSIGNAL', 'MAINTAINER'];
  number_of_step = 0;
  userargs = [];
  temp_dir = "/tmp/ryba-" + (Date.now()) + "-" + (Math.floor(Math.random() * 1000));
  this.call({
    unless: options.content,
    handler: function(_, callback) {
      options.log({
        message: "Reading Dockerfile from : " + options.path,
        level: 'INFO',
        module: 'mecano/lib/build'
      });
      return fs.readFile(options.ssh, options.path, 'utf8', function(err, content) {
        if (err) {
          return callback(err);
        }
        options.content = content;
        return callback();
      });
    }
  });
  this.call(function() {
    var j, len1, line, ref1, ref2, ref3, results;
    ref1 = string.lines(options.content);
    results = [];
    for (j = 0, len1 = ref1.length; j < len1; j++) {
      line = ref1[j];
      if (ref2 = (ref3 = /^(.*?)\s/.exec(line)) != null ? ref3[1] : void 0, indexOf.call(dockerfile_cmds, ref2) >= 0) {
        results.push(number_of_step++);
      } else {
        results.push(void 0);
      }
    }
    return results;
  });
  return this.execute({
    cmd: docker.wrap(options, cmd),
    cwd: path.dirname(options.path)
  }, (function(_this) {
    return function(err, executed, stdout, stderr) {
      var container_id_hash, k, line, lines, number_of_cache;
      if (err) {
        return callback(err, executed, stdout, stderr, container_id_hash);
      }
      container_id_hash = null;
      lines = string.lines(stderr);
      lines = string.lines(stdout);
      number_of_cache = 0;
      for (k in lines) {
        line = lines[k];
        if (line.indexOf('Using cache') !== -1) {
          number_of_cache = number_of_cache + 1;
        }
        if (line.indexOf('Successfully built') !== -1) {
          container_id_hash = line.split(' ').pop().toString();
        }
      }
      return userargs = [number_of_step !== number_of_cache, container_id_hash, stdout, stderr];
    };
  })(this)).then(function(err, status) {
    options.log(!err && userargs[0] ? {
      message: "New image id " + userargs[1],
      level: 'INFO',
      module: 'mecano/lib/docker/build'
    } : {
      message: "Identical image id " + userargs[1],
      level: 'INFO',
      module: 'mecano/lib/docker/build'
    });
    return callback.apply(null, [err].concat(slice.call(userargs)));
  });
};

docker = require('../misc/docker');

string = require('../misc/string');

path = require('path');

util = require('util');

fs = require('ssh2-fs');
