// Generated by CoffeeScript 1.10.0
var docker, fs, path, string, util;

module.exports = function(options, callback) {
  var cmd, dockerfile_cmds, i, len, number_of_step, opt, ref;
  if (options.tag == null) {
    return callback(Error('Missing tag parameter'));
  }
  if ((options.content != null) && (options.path != null)) {
    return callback(Error('Can not build from Dockerfile and content'));
  }
  cmd = ' build ';
  ref = ['force_rm', 'quiet', 'no_cache'];
  for (i = 0, len = ref.length; i < len; i++) {
    opt = ref[i];
    if (options[opt]) {
      cmd += " --" + (opt.replace('_', '-'));
    }
  }
  if ((options.rm != null) && !options.rm) {
    cmd += ' --rm=false';
  }
  cmd += " -t \"" + options.tag + "\"";
  if (options.path != null) {
    options.log({
      message: "Building from Dockerfile: \"" + options.path + "\"",
      level: 'INFO',
      module: 'mecano/docker/build'
    });
    cmd += " -f " + options.path + " " + (path.dirname(options.path));
  } else if (options.content != null) {
    options.log({
      message: "Building from text: Docker won't have a context. ADD/COPY not working",
      level: 'WARN',
      module: 'mecano/docker/build'
    });
    if (options.content != null) {
      cmd += " - <<DOCKERFILE\n" + options.content + "\nDOCKERFILE";
    }
  } else {
    options.log({
      message: "Building from CWD",
      level: 'INFO',
      module: 'mecano/docker/build'
    });
    cmd += ' .';
  }
  dockerfile_cmds = ['CMD', 'LABEL', 'EXPOSE', 'ENV', 'ADD', 'COPY', 'ENTRYPOINT', 'VOLUME', 'USER', 'WORKDIR', 'ARG', 'ONBUILD', 'RUN', 'STOPSIGNAL', 'MAINTAINER'];
  number_of_step = 0;
  return this.write({
    destination: '/tmp/ryba/build/Dockerfile',
    content: options.content,
    "if": options.content
  }, function(err) {
    var dockerfile_path;
    if (err) {
      return callback(err);
    }
    if (options.content != null) {
      dockerfile_path = '/tmp/ryba/build/Dockerfile';
    }
    if (options.path != null) {
      dockerfile_path = options.path;
    }
    if ((options.content == null) && (options.path == null)) {
      dockerfile_path = "" + (path.resolve(options.cwd, 'Dockerfile'));
    }
    if (options.content != null) {
      options.log({
        message: "Writing Dockerfile to :" + dockerfile_path,
        level: 'INFO',
        module: 'mecano/src/build'
      });
    }
    if ((options.cwd != null) || (options.path != null)) {
      options.log({
        message: "Reading Dockerfile from :" + dockerfile_path,
        level: 'INFO',
        module: 'mecano/src/build'
      });
    }
    return fs.readFile(options.ssh, dockerfile_path, (function(_this) {
      return function(err, result) {
        var dockerfile_cmd, j, l, len1, len2, line, lines, m;
        if (err) {
          if (err.code === 'ENOENT') {
            options.log({
              message: "Dockerfile :" + dockerfile_path + " does not exist",
              level: 'ERROR',
              module: 'mecano/src/docker/build'
            });
          }
          return callback(err, false);
        } else {
          lines = string.lines(result.toString());
          for (j = 0, len1 = lines.length; j < len1; j++) {
            l = lines[j];
            line = l.replace(/ /g, '');
            for (m = 0, len2 = dockerfile_cmds.length; m < len2; m++) {
              dockerfile_cmd = dockerfile_cmds[m];
              if (line.indexOf(dockerfile_cmd) === 0) {
                number_of_step = number_of_step + 1;
              }
            }
          }
          return _this.remove({
            destination: '/tmp/ryba/build/Dockerfile',
            "if": options.content
          }, function(err) {
            if (err) {
              return callback(err);
            }
            options.log({
              message: "Building docker repository:" + options.tag,
              level: 'INFO',
              module: 'mecano/src/docker/build'
            });
            return docker.exec(cmd, options, null, (function(_this) {
              return function(err, executed, stdout, stderr) {
                var container_id_hash, k, number_of_cache;
                if (err) {
                  return callback(err, executed, stdout, stderr, container_id_hash);
                }
                container_id_hash = null;
                if (executed) {
                  lines = string.lines(stdout);
                  number_of_cache = 0;
                  for (k in lines) {
                    line = lines[k];
                    if (line.indexOf('Using cache') !== -1) {
                      number_of_cache = number_of_cache + 1;
                    }
                    if (line.indexOf('Successfully built') !== -1) {
                      container_id_hash = line.split(' ').pop().toString();
                    }
                  }
                }
                if (number_of_step === number_of_cache) {
                  executed = null;
                }
                if (executed === null) {
                  options.log({
                    message: "new repository is identical to previous " + options.tag,
                    level: 'INFO',
                    module: 'mecano/src/docker/build'
                  });
                }
                if (executed) {
                  options.log({
                    message: "new repository hash  " + container_id_hash,
                    level: 'INFO',
                    module: 'mecano/src/docker/build'
                  });
                }
                return callback(err, executed, stdout, stderr, container_id_hash);
              };
            })(this));
          });
        }
      };
    })(this));
  });
};

docker = require('../misc/docker');

string = require('../misc/string');

path = require('path');

util = require('util');

fs = require('ssh2-fs');
