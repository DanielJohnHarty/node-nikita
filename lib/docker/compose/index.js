// Generated by CoffeeScript 2.0.0
// # `nikita.docker.compose(options, [callback])`

// Create and start containers according to a docker-compose file
// `nikita.docker.compose` is an alias to `nikita.docker.compose.up`

// ## Options

// *   `boot2docker` (boolean)   
//     Whether to use boot2docker or not, default to false.   
// *   `machine` (string)   
//     Name of the docker-machine, required if using docker-machine   
// *   `content` (string)   
//     The content of the docker-compose.yml to write if not exist.   
// *   `eof` (string)   
//     Inherited from nikita.file use when writing docker-compose.yml file.   
// *   `backup` (string)   
//     Inherited from nikita.file use when writing docker-compose.yml file.   
// *   `detached` (boolean)   
//     Run Containers in detached mode. Default to true   
// *   `force` (boolean)   
//      Force to re-create the containers if the config and image have not changed   
//     Default to false   
// *   `services` (string|array)
//     Specify specific services to create.
// *   `target` (string)   
//     The docker-compose.yml absolute's file's path, required if no content is 
//     specified.   
// *   `code` (int|array)   
//     Expected code(s) returned by the command, int or array of int, default to 0.   
// *   `code_skipped`   
//     Expected code(s) returned by the command if it has no effect, executed will   
//     not be incremented, int or array of int.   

// ## Callback parameters

// *   `err`   
//     Error object if any.   
// *   `executed`   
//     if command was executed   
// *   `stdout`   
//     Stdout value(s) unless `stdout` option is provided.   
// *   `stderr`   
//     Stderr value(s) unless `stderr` option is provided.   

// ## Source Code
var docker, path;

module.exports = function(options) {
  var cmd, cmd_ps, cmd_up, k, ref, services, source_dir, v;
  options.log({
    message: "Entering Docker Compose",
    level: 'DEBUG',
    module: 'nikita/lib/docker/compose/up'
  });
  // Validate parameters
  if (options.docker == null) {
    options.docker = {};
  }
  ref = options.docker;
  for (k in ref) {
    v = ref[k];
    if (options[k] == null) {
      options[k] = v;
    }
  }
  if ((options.target == null) && (options.content == null)) {
    throw Error('Missing docker-compose content or target');
  }
  if (options.content && (options.target == null)) {
    if (options.target == null) {
      options.target = `/tmp/docker_compose_${Date.now()}/docker-compose.yml`;
    }
  }
  if (options.detached == null) {
    options.detached = true;
  }
  if (options.force == null) {
    options.force = false;
  }
  if (options.recreate == null) {
    options.recreate = false;
  }
  if (options.services == null) {
    options.services = [];
  }
  if (!Array.isArray(options.services)) {
    options.services = [options.services];
  }
  services = options.services.join(' ');
  // Construct exec command
  cmd = ` --file ${options.target}`;
  cmd_ps = `${cmd} ps -q | xargs docker inspect`;
  cmd_up = `${cmd} up`;
  if (options.detached) {
    cmd_up += ' -d ';
  }
  if (options.force) {
    cmd_up += ' --force-recreate ';
  }
  cmd_up += ` ${services}`;
  source_dir = `${path.dirname(options.target)}`;
  if (options.eof == null) {
    options.eof = true;
  }
  if (options.backup == null) {
    options.backup = false;
  }
  options.compose = true;
  this.file.yaml({
    if: options.content != null,
    eof: options.eof,
    backup: options.backup,
    target: options.target,
    content: options.content
  });
  this.call(function(_, callback) {
    var start;
    start = true;
    this.system.execute({
      cmd: docker.wrap(options, cmd_ps),
      cwd: options.cwd,
      uid: options.uid,
      code_skipped: 123, // Container not created
      stdout_log: false
    }, function(err, status, stdout, stderr) {
      var containers;
      if (err) {
        throw err;
      }
      if (!status) {
        return start = true;
      }
      containers = JSON.parse(stdout);
      start = containers.some(function(container) {
        return !container.State.Running;
      });
      if (start) {
        return options.log("Docker created, need start");
      }
    });
    return this.then(function() {
      return callback(null, start);
    });
  });
  return this.system.execute({
    if: function() {
      return options.force || this.status();
    },
    cwd: source_dir,
    cmd: docker.wrap(options, cmd_up)
  }, docker.callback);
};

// ## Modules Dependencies
docker = require('../../misc/docker');

path = require('path');
