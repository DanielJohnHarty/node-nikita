// Generated by CoffeeScript 2.0.2
// # `nikita.java.keystore_add(options, [callback])`

// Add certificates, private keys and certificate authorities to java keystores
// and truststores.

// ## Options

// * `name` (string)   
//   Name of the certificate, required if a certificate is provided.
// * `caname` (string)   
//   Name of the certificate authority (CA), required.
// * `cacert` (string)   
//   Path to the certificate authority (CA), required.
// * `local` (boolean)    
//   treat the source file (key, cert or cacert) as a local file present on the 
//   host, only apply with remote actions over SSH, default is "false".
// * `openssl` (string)   
//   Path to OpenSSl command line tool, default to "openssl".
// * `parent` (boolean|object)   
//   Create parent directory with provided options if an object or default 
//   system options if "true".
// * `storepass` (string)   
//   Password to manage the keystore.

// ## Callback parameters

// * `err` (object|null)   
//   Error object if any.
// * `status` (boolean)   
//   Indicates if the certificated was inserted.

// ## CA Cert Chains

// In case the CA file reference a chain of certificates, each certificate will be
// referenced by a unique incremented alias, starting at 0. For example if the 
// alias value is "my-alias", the aliases will be "my-alias-0" then "my-alias-1"... 

// ## Relevant Java properties

// * `javax.net.ssl.trustStore`
// * `javax.net.ssl.trustStorePassword`
// * `javax.net.ssl.keyStore`
// * `javax.net.ssl.keyStoreType`
// * `javax.net.ssl.keyStorePassword`

// ## Relevant commands

// * View the content of a Java KeyStore (JKS) and Java TrustStore:   
//   `keytool -list -v -keystore $keystore -storepass $storepass`   
//   `keytool -list -v -keystore $keystore -storepass $storepass -alias $caname`   
//   Note, alias is optional and may reference a CA or a certificate
// * View the content of a ".pem" certificate:   
//   `openssl x509 -in cert.pem -text`   
//   `keytool -printcert -file certs.pem`   
// * Change the password of a keystore:   
//   `keytool -storepasswd -keystore my.keystore`
// * Change the key's password:   
//   `keytool -keypasswd -alias <key_name> -keystore my.keystore`

// ## Uploading public and private keys into a keystore

// ```js
// require('nikita').java.keystore_add([{
//   keystore: java_home + '/lib/security/cacerts',
//   storepass: 'changeit',
//   caname: 'my_ca_certificate',
//   cacert: '/tmp/cacert.pem',
//   key: "/tmp/private_key.pem",
//   cert: "/tmp/public_cert.pem",
//   keypass: 'mypassword',
//   name: 'node_1'
// }, function(err, status){ /* do sth */ });
// ```

// ## Uploading a certificate authority

// ```js
// require('nikita').java.keystore_add([{
//   keystore: java_home + '/lib/security/cacerts',
//   storepass: 'changeit',
//   caname: 'my_ca_certificate',
//   cacert: '/tmp/cacert.pem'
// }, function(err, status){ /* do sth */ });
// ```

// ## Source Code
var path;

module.exports = function(options) {
  var files, tmp_location;
  if (!options.keystore) {
    throw Error("Required Option: 'keystore'");
  }
  if (!options.storepass) {
    throw Error("Required Option: 'storepass'");
  }
  if (!(options.cacert || options.cert)) {
    throw Error("Required Options: 'cacert' or 'cert'");
  }
  if (options.cert && !options.key) {
    throw Error("Required Option: 'key' for certificate");
  }
  if (options.cert && !options.keypass) {
    throw Error("Required Option: 'keypass' for certificate");
  }
  if (options.cert && !options.name) {
    throw Error("Required Option: 'name' for certificate");
  }
  // throw Error "Required option 'caname'" unless options.caname
  // throw Error "Required option 'cacert'" unless options.cacert
  if (options.parent == null) {
    options.parent = {};
  }
  if (options.openssl == null) {
    options.openssl = 'openssl';
  }
  tmp_location = `/tmp/nikita/java_keystore_${Date.now()}`;
  files = {
    cert: (options.cert != null) && options.local ? `${tmp_location}/${path.basename(options.cert)}` : options.cert,
    cacert: (options.cacert != null) && options.local ? `${tmp_location}/${path.basename(options.cacert)}` : options.cacert,
    key: (options.key != null) && options.local ? `${tmp_location}/${path.basename(options.key)}` : options.key
  };
  this.system.mkdir({
    target: `${tmp_location}`,
    mode: 0o0700,
    shy: true
  });
  this.file.download({
    if: options.local && options.cacert,
    source: options.cacert,
    target: files.cacert,
    mode: 0o0600,
    shy: true
  });
  this.file.download({
    if: options.local && options.cert,
    source: options.cert,
    target: files.cert,
    mode: 0o0600,
    shy: true
  });
  this.file.download({
    if: options.local && options.key,
    source: options.key,
    target: files.key,
    mode: 0o0600,
    shy: true
  });
  this.system.mkdir(options, options.parent, {
    header: null,
    unless_exists: true,
    target: path.dirname(options.keystore)
  });
  this.system.execute({ // Deal with key and certificate
    bash: true,
    cmd: `cleanup () {\n  [ -n "${(options.cacert ? '1' : '')}" ] || rm -rf ${tmp_location};\n}\nif ! which ${options.openssl}; then echo 'OpenSSL command line tool not detected'; cleanup; exit 4; fi\n[ -f ${files.cert} ] || (cleanup; exit 6)\n# mkdir -p -m 700 ${tmp_location}\nuser=\`${options.openssl} x509  -noout -in "${files.cert}" -sha1 -fingerprint | sed 's/\\(.*\\)=\\(.*\\)/\\2/' | cat\`\n# We are only retrieving the first certificate found in the chain with \`head -n 1\`\nkeystore=\`keytool -list -v -keystore ${options.keystore} -storepass ${options.storepass} -alias ${options.name} | grep SHA1: | head -n 1 | sed -E 's/.+SHA1: +(.*)/\\1/'\`\necho "User Certificate: $user"\necho "Keystore Certificate: $keystore"\nif [[ "$user" == "$keystore" ]]; then cleanup; exit 5; fi\n# Create a PKCS12 file that contains key and certificate\n${options.openssl} pkcs12 -export -in "${files.cert}" -inkey "${files.key}" -out "${tmp_location}/pkcs12" -name ${options.name} -password pass:${options.keypass}\n# Import PKCS12 into keystore\nkeytool -noprompt -importkeystore -destkeystore ${options.keystore} -deststorepass ${options.storepass} -destkeypass ${options.keypass} -srckeystore "${tmp_location}/pkcs12" -srcstoretype PKCS12 -srcstorepass ${options.keypass} -alias ${options.name}`,
    trap: true,
    if: !!options.cert,
    code_skipped: 5 // OpenSSL exit 3 if file does not exists
  }, function(err, status) {
    if ((err != null ? err.code : void 0) === 4) {
      throw Error("OpenSSL command line tool not detected");
    }
    if ((err != null ? err.code : void 0) === 6) {
      throw Error("Keystore file does not exists");
    }
  });
  this.system.execute({ // Deal with CACert
    if: options.cacert,
    bash: true,
    cmd: `# cleanup () { rm -rf ${tmp_location}; }\ncleanup () { echo 'clean'; }\n# Check password\nif [ -f ${options.keystore} ] && ! keytool -list -keystore ${options.keystore} -storepass ${options.storepass} >/dev/null; then\n  # Keystore password is invalid, change it manually with:\n  # keytool -storepasswd -keystore ${options.keystore} -storepass \${old_pasword} -new ${options.storepass}\n  cleanup; exit 2\nfi\n[ -f ${files.cacert} ] || (echo 'CA file doesnt not exists: ${files.cacert} 1>&2'; cleanup; exit 3)\n# Import CACert\nPEM_FILE=${files.cacert}\nCERTS=$(grep 'END CERTIFICATE' $PEM_FILE| wc -l)\ncode=5\nfor N in $(seq 0 $(($CERTS - 1))); do\n  if [[ $CERTS == '1' ]]; then\n    ALIAS="${options.caname}"\n  else\n    ALIAS="${options.caname}-$N"\n  fi\n  # Isolate cert into a file\n  CACERT_FILE=${tmp_location}/$ALIAS\n  cat $PEM_FILE | awk "n==$N { print }; /END CERTIFICATE/ { n++ }" > $CACERT_FILE\n  # Read user CACert signature\n  user=\`${options.openssl} x509  -noout -in "$CACERT_FILE" -sha1 -fingerprint | sed 's/\\(.*\\)=\\(.*\\)/\\2/'\`\n  # Read registered CACert signature\n  keystore=\`keytool -list -v -keystore ${options.keystore} -storepass ${options.storepass} -alias $ALIAS | grep SHA1: | sed -E 's/.+SHA1: +(.*)/\\1/'\`\n  echo "User CA Cert: $user"\n  echo "Keystore CA Cert: $keystore"\n  if [[ "$user" == "$keystore" ]]; then echo 'Identical Signature'; code=5; continue; fi\n  # Remove CACert if signature doesnt match\n  if [[ "$keystore" != "" ]]; then\n    keytool -delete -keystore ${options.keystore} -storepass ${options.storepass} -alias $ALIAS\n  fi\n  keytool -noprompt -import -trustcacerts -keystore ${options.keystore} -storepass ${options.storepass} -alias $ALIAS -file ${tmp_location}/$ALIAS\n  code=0\ndone\ncleanup\nexit $code`,
    trap: true,
    code_skipped: 5
  }, function(err, status) {
    if ((err != null ? err.code : void 0) === 3) {
      throw Error(`CA file does not exist: ${files.cacert}`);
    }
  });
  this.system.chown({
    target: options.keystore,
    uid: options.uid,
    gid: options.gid,
    if: (options.uid != null) || (options.gid != null)
  });
  return this.system.chmod({
    target: options.keystore,
    mode: options.mode,
    if: options.mode != null
  });
};

// ## Dependencies
path = require('path').posix;
