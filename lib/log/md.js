// Generated by CoffeeScript 1.10.0
var fs, mustache, path;

module.exports = {
  ssh: null,
  handler: function(options) {
    var dateformat, ref;
    if (options.archive == null) {
      options.archive = false;
    }
    if (options.basedir == null) {
      options.basedir = 'log';
    }
    options.basedir = path.resolve(options.basedir);
    if (options.filename == null) {
      options.filename = "{{shortname}}.log";
    }
    if (options.shortname == null) {
      options.shortname = ((ref = options.ssh) != null ? ref.config.host : void 0) || 'localhost';
    }
    options.basedir = mustache.render(options.basedir, options);
    options.filename = mustache.render(options.filename, options);
    if (!options.archive) {
      if (options._logdir == null) {
        options._logdir = path.join(options.basedir);
      }
    } else {
      if (options._latestdir == null) {
        options._latestdir = path.join(options.basedir, 'latest');
      }
      dateformat = (new Date).toJSON();
      if (options._logdir == null) {
        options._logdir = path.join(options.basedir, dateformat);
      }
    }
    this.mkdir(options.basedir);
    this.mkdir({
      shy: true
    }, options._logdir);
    if (options.archive) {
      this.link({
        shy: true,
        source: options._logdir,
        target: options._latestdir
      });
    }
    return this.call(function() {
      var close, out, stdouting;
      out = fs.createWriteStream(path.resolve(options._logdir, options.filename));
      stdouting = 0;
      this.on('text', function(log) {
        out.write("" + log.message);
        if (log.module) {
          out.write(" (" + log.level + ", written by " + log.module + ")");
        }
        return out.write("\n");
      });
      this.on('header', function(log) {
        return out.write("\n" + ('#'.repeat(log.header_depth)) + " " + log.message + "\n\n");
      });
      this.on('stdin', function(log) {
        var stdining;
        if (log.message.indexOf('\n') === -1) {
          out.write("\nRunning Command: `" + log.message + "`\n\n");
        } else {
          out.write("\n```stdin\n" + log.message + "\n```\n\n");
        }
        return stdining = log.message !== null;
      });
      this.on('diff', function(log) {
        if (!log.message) {
          return out.write('\n```diff\n#{log.message}```\n\n');
        }
      });
      this.on('stdout_stream', function(log) {
        if (log.message === null) {
          stdouting = 0;
        } else {
          stdouting++;
        }
        if (stdouting === 1) {
          out.write('\n```stdout\n');
        }
        if (stdouting > 0) {
          out.write(log.message);
        }
        if (stdouting === 0) {
          return out.write('```\n\n');
        }
      });
      this.on('stderr', function(log) {
        return out.write("\n```stderr\n" + log.message + "```\n\n");
      });
      close = function() {
        return setTimeout((function() {
          return out.close();
        }), 100);
      };
      this.on('end', function() {
        out.write('\nFINISHED WITH SUCCESS\n');
        return close();
      });
      return this.on('error', function(err) {
        var error, i, len, print, ref1;
        out.write('\nFINISHED WITH ERROR\n');
        print = function(err) {
          return out.write(err.stack || err.message + '\n');
        };
        if (!err.errors) {
          print(err);
        } else if (err.errors) {
          out.write(err.message + '\n');
          ref1 = err.errors;
          for (i = 0, len = ref1.length; i < len; i++) {
            error = ref1[i];
            print(error);
          }
        }
        return close();
      });
    });
  }
};

fs = require('fs');

path = require('path');

mustache = require('mustache');
