// Generated by CoffeeScript 1.7.1
var iptables, jsesc, misc;

misc = require('./index');

jsesc = require('jsesc');

module.exports = iptables = {
  add_properties: ['-p', '-s', '-d', '-j', '-g', '-i', '-o', '-f'],
  modify_properties: ['-c', 'state|--state', 'comment|--comment', 'tcp|--source-port', 'tcp|--sport', 'tcp|--destination-port', 'tcp|--dport', 'tcp|--tcp-flags', 'tcp|--syn', 'tcp|--tcp-option', 'udp|--source-port', 'udp|--sport', 'udp|--destination-port', 'udp|--dport'],
  commands: {
    '-A': ['chain'],
    '-D': ['chain'],
    '-I': ['chain'],
    '-R': ['chain'],
    '-P': ['chain', 'target'],
    '-L': true,
    '-S': true,
    '-F': true,
    '-Z': true,
    '-N': true,
    '-X': true,
    '-E': true
  },
  parameters: ['-p', '-s', '-d', '-j', '-g', '-i', '-o', '-f', '-c'],
  parameters_inverted: {
    '--protocol': '-p',
    '--source': '-s',
    '--destination': '-d',
    '--jump': '-j',
    '--goto': '-g',
    '--in-interface': '-i',
    '--out-interface': '-o',
    '--fragment': '-f',
    '--set-counters': '-c'
  },
  protocols: {
    tcp: ['--source-port', '--sport', '--destination-port', '--dport', '--tcp-flags', '--syn', '--tcp-option'],
    udp: ['--source-port', '--sport', '--destination-port', '--dport'],
    udplite: [],
    icmp: [],
    esp: [],
    ah: [],
    sctp: [],
    all: []
  },
  modules: {
    state: ['--state'],
    comment: ['--comment']
  },
  cmd_args: function(cmd, rule) {
    var arg, k, match, module, v;
    for (k in rule) {
      v = rule[k];
      if (['chain', 'rulenum'].indexOf(k) !== -1) {
        continue;
      }
      if (match = /^([\w]+)\|([-\w]+)$/.exec(k)) {
        module = match[1];
        arg = match[2];
        cmd += " -m " + module;
        cmd += " " + arg + " " + v;
      } else {
        cmd += " " + k + " " + v;
      }
    }
    return cmd;
  },
  cmd_modify: function(rule) {
    if (rule.rulenum == null) {
      rule.rulenum = 1;
    }
    return iptables.cmd_args("iptables -R " + rule.chain + " " + rule.rulenum, rule);
  },
  cmd_add: function(rule) {
    if (rule.rulenum == null) {
      rule.rulenum = 1;
    }
    return iptables.cmd_args("iptables -I " + rule.chain + " " + rule.rulenum, rule);
  },
  cmd: function(oldrules, newrules) {
    var add_properties, cmds, create, newrule, oldrule, _i, _j, _len, _len1;
    cmds = [];
    for (_i = 0, _len = newrules.length; _i < _len; _i++) {
      newrule = newrules[_i];
      create = true;
      add_properties = misc.array.intersect(iptables.add_properties, Object.keys(newrule));
      for (_j = 0, _len1 = oldrules.length; _j < _len1; _j++) {
        oldrule = oldrules[_j];
        if (misc.object.equals(newrule, oldrule, add_properties)) {
          create = false;
          if (!misc.object.equals(newrule, oldrule, iptables.modify_properties)) {
            cmds.push(iptables.cmd_modify(newrule));
          }
        }
      }
      if (create) {
        cmds.push(iptables.cmd_add(newrule));
      }
    }
    return cmds;
  },
  normalize: function(rules) {
    var k, mk, mv, mvs, nk, nrule, nrules, protocol, rule, v, _i, _j, _k, _len, _len1, _len2, _ref, _ref1;
    nrules = [];
    for (_i = 0, _len = rules.length; _i < _len; _i++) {
      rule = rules[_i];
      nrule = {};
      for (k in rule) {
        v = rule[k];
        if (typeof v === 'number') {
          v = rule[k] = "" + v;
        }
        if (k === 'chain' || k === 'rulenum') {
          if (nk === 'rulenum' && typeof v === 'object') {
            v = iptables.normalize(v);
          }
          nk = k;
        } else if (k.slice(0, 2) === '--') {
          nk = iptables.parameters_inverted[nk];
        } else if (k[0] !== '-') {
          nk = iptables.parameters_inverted["--" + k];
        } else if (iptables.parameters.indexOf(k) !== -1) {
          nk = k;
        }
        if (nk) {
          nrule[nk] = v;
          rule[k] = null;
        }
      }
      if (protocol = nrule['-p']) {
        _ref = iptables.protocols[protocol];
        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
          k = _ref[_j];
          if (rule[k]) {
            nrule["" + protocol + "|k"] = rule[k];
            rule[k] = null;
          } else if (rule[k.slice(2)]) {
            nrule["" + protocol + "|" + k] = rule[k.slice(2)];
            rule[k.slice(2)] = null;
          }
        }
      }
      for (k in rule) {
        v = rule[k];
        if (!v) {
          continue;
        }
        if (k.slice(0, 3) !== '--') {
          k = "--" + k;
        }
        _ref1 = iptables.modules;
        for (mk in _ref1) {
          mvs = _ref1[mk];
          for (_k = 0, _len2 = mvs.length; _k < _len2; _k++) {
            mv = mvs[_k];
            if (k === mv) {
              nrule["" + mk + "|" + k] = v;
              rule[k] = null;
            }
          }
        }
      }
      for (k in nrule) {
        v = nrule[k];
        if (!/^[A-Za-z0-9_\/-]+$/.test(v)) {
          nrule[k] = jsesc(v, {
            quotes: 'double',
            wrap: true
          });
        }
      }
      nrules.push(nrule);
    }
    return nrules;
  },

  /*
  Parse the result of `iptables -S`
   */
  parse: function(stdout) {
    var char, command, command_index, forceflush, i, j, key, line, module, newarg, rule, rules, v, value, _i, _j, _len, _len1, _ref, _ref1;
    rules = [];
    command = null;
    command_index = 1;
    _ref = stdout.split(/\r\n|[\n\r\u0085\u2028\u2029]/g);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      line = _ref[_i];
      command_index++;
      rule = {};
      i = 0;
      key = '';
      value = '';
      module = null;
      while (i <= line.length) {
        char = line[i];
        forceflush = i === line.length;
        newarg = (i === 0 && char === '-') || line.slice(i - 1, +i + 1 || 9e9) === ' -';
        if (newarg || forceflush) {
          if (value) {
            value = value.trim();
            if (key === '-m') {
              module = value;
            } else {
              if (module) {
                key = "" + module + "|" + key;
              }
              rule[key] = value;
            }
            if (iptables.commands[key]) {
              if (key !== command) {
                command = key;
                command_index = 1;
              }
              rule.rulenum = command_index;
              if (Array.isArray(iptables.commands[key])) {
                _ref1 = value.split(' ');
                for (j = _j = 0, _len1 = _ref1.length; _j < _len1; j = ++_j) {
                  v = _ref1[j];
                  rule[iptables.commands[key][j]] = v;
                }
              }
            }
            key = '';
            value = '';
            if (forceflush) {
              break;
            }
          }
          key += char;
          while ((char = line[++i]) !== ' ') {
            key += char;
          }
          if (iptables.parameters.indexOf(key) !== -1) {
            module = null;
          }
          continue;
        }
        if (char === '"') {
          while ((char = line[++i]) !== '"') {
            value += char;
          }
          i++;
          continue;
        }
        while ((char = line[++i]) !== '-' && i < line.length) {
          if (!char) {
            process.exit();
          }
          value += char;
        }
      }
      rules.push(rule);
    }
    return rules;
  }
};
