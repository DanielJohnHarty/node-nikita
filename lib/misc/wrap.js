// Generated by CoffeeScript 1.8.0
var child, conditions, connect, each, misc, tilde,
  __slice = [].slice;

each = require('each');

tilde = require('tilde-expansion');

connect = require('ssh2-connect');

misc = require('./index');

conditions = require('./conditions');

child = require('./child');


/*
Responsibilities:

*   Retrieve arguments
*   Normalize options
*   Handle conditions
*   Run multiple actions sequentially or concurrently
*   Handling modification count
*   Return a Mecano Child instance
*   Pass user arguments
 */

module.exports = function(args, handler) {
  var callback, finish, goptions, isArray, modified, options, result, user_args, _ref;
  _ref = module.exports.args(args), options = _ref[0], goptions = _ref[1], callback = _ref[2];
  isArray = Array.isArray(options);
  user_args = [];
  result = child();
  modified = 0;
  finish = function(err) {
    var arg, i;
    if (!isArray) {
      user_args = (function() {
        var _i, _len, _results;
        _results = [];
        for (i = _i = 0, _len = user_args.length; _i < _len; i = ++_i) {
          arg = user_args[i];
          _results.push(user_args[i] = arg[0]);
        }
        return _results;
      })();
    }
    if (callback) {
      callback.apply(null, [err, modified].concat(__slice.call(user_args)));
    }
    return result.end.apply(result, [err, modified].concat(__slice.call(user_args)));
  };
  module.exports.options(options, function(err, options) {
    if (err) {
      return finish(err);
    }
    return each(options).parallel(goptions.parallel).on('item', function(options, next) {
      return conditions.all(options, next, function() {
        return handler(options, function() {
          var arg, args, err, i, modif, _i, _len;
          err = arguments[0], modif = arguments[1], args = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
          if (!err && modif) {
            modified++;
          }
          for (i = _i = 0, _len = args.length; _i < _len; i = ++_i) {
            arg = args[i];
            if (user_args[i] == null) {
              user_args[i] = [];
            }
            user_args[i].push(arg);
          }
          return next(err);
        });
      });
    }).on('both', function(err) {
      return finish(err);
    });
  });
  return result;
};

module.exports.args = function(args, overwrite_goptions) {
  if (overwrite_goptions == null) {
    overwrite_goptions = {};
  }
  if (args.length === 2 && typeof args[1] === 'function') {
    args[2] = args[1];
    args[1] = {};
  } else if (args.length === 1) {
    args[1] = {};
    args[2] = null;
  }
  args[1] = misc.merge(args[1], {
    parallel: 1
  }, overwrite_goptions);
  return args;
};


/*

`options(options, callback)`
----------------------------
Normalize options. An ssh connection is needed if the key "ssh" 
hold a configuration object. The 'uid' and 'gid' fields will 
be converted to integer if they match a username or a group.   

`callback`          Received parameters are:   

*   `err`           Error object if any.   
*   `options`       Sanitized options.
 */

module.exports.options = function(options, callback) {
  if (!Array.isArray(options)) {
    options = [options];
  }
  return each(options).on('item', function(options, next) {
    var connection, destination, el, gid, i, mode, source, uid, v, _i, _j, _len, _len1, _ref, _ref1;
    if ((options["if"] != null) && !Array.isArray(options["if"])) {
      options["if"] = [options["if"]];
    }
    if (typeof options.if_exists === 'string') {
      options.if_exists = [options.if_exists];
    }
    if (typeof options.not_if_exists === 'string') {
      options.not_if_exists = [options.not_if_exists];
    }
    if (options.if_exists) {
      _ref = options.if_exists;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        el = _ref[i];
        if (el === true && options.destination) {
          options.if_exists[i] = options.destination;
        }
      }
    }
    if (options.not_if_exists) {
      _ref1 = options.not_if_exists;
      for (i = _j = 0, _len1 = _ref1.length; _j < _len1; i = ++_j) {
        v = _ref1[i];
        if (v === true && options.destination) {
          options.not_if_exists[i] = options.destination;
        }
      }
    }
    if (options.chmod) {
      if (options.mode == null) {
        options.mode = options.chmod;
      }
    }
    connection = function() {
      if (!options.ssh) {
        return source();
      }
      if (options.ssh._host) {
        return source();
      }
      return connect(options.ssh, function(err, ssh) {
        if (err) {
          return next(err);
        }
        options.ssh = ssh;
        return source();
      });
    };
    source = function() {
      if (options.source == null) {
        return destination();
      }
      if (/^\w+:/.test(options.source)) {
        return destination();
      }
      return tilde(options.source, function(source) {
        options.source = source;
        return destination();
      });
    };
    destination = function() {
      if (options.destination == null) {
        return mode();
      }
      if (typeof options.destination !== 'string') {
        return mode();
      }
      if (/^\w+:/.test(options.source)) {
        return mode();
      }
      return tilde(options.destination, function(destination) {
        options.destination = destination;
        return mode();
      });
    };
    mode = function() {
      if (typeof options.mode === 'string') {
        options.mode = parseInt(options.mode, 8);
      }
      return uid();
    };
    uid = function() {
      if (!options.uid) {
        return gid();
      }
      if (typeof options.uid === 'string' && /\d+/.test(options.uid)) {
        options.uid = parseInt(options.uid, 10);
      }
      if (typeof options.uid === 'number') {
        return gid();
      }
      return misc.ssh.passwd(options.ssh, options.uid, function(err, user) {
        if (err) {
          return next(err);
        }
        if (user) {
          options.uid = user.uid;
          if (options.gid == null) {
            options.gid = user.gid;
          }
        }
        return gid();
      });
    };
    gid = function() {
      if (!options.gid) {
        return next();
      }
      if (typeof options.gid === 'string' && /\d+/.test(options.gid)) {
        options.gid = parseInt(options.gid, 10);
      }
      if (typeof options.gid === 'number') {
        return next();
      }
      return misc.ssh.group(options.ssh, options.gid, function(err, group) {
        if (err) {
          return next(err);
        }
        if (group) {
          options.gid = group.gid;
        }
        return next();
      });
    };
    return connection();
  }).on('both', function(err) {
    return callback(err, options);
  });
};
