// Generated by CoffeeScript 1.9.1
var conditions, connect, each, exports, misc, tilde,
  slice = [].slice;

each = require('each');

tilde = require('tilde-expansion');

connect = require('ssh2-connect');

misc = require('./index');

conditions = require('./conditions');


/*
Responsibilities:

*   Retrieve arguments
*   Normalize options
*   Handle conditions
*   Run multiple actions sequentially or concurrently
*   Handling modification count
*   Return a Mecano Child instance
*   Pass user arguments
 */

exports = module.exports = function(context, args, handler) {
  var callback, finish, goptions, isArray, modified, options, ref, user_args;
  ref = exports.args(args), options = ref[0], goptions = ref[1], callback = ref[2];
  isArray = Array.isArray(options);
  user_args = [];
  modified = 0;
  finish = function(err) {
    var arg, i;
    if (!isArray) {
      user_args = (function() {
        var j, len, results;
        results = [];
        for (i = j = 0, len = user_args.length; j < len; i = ++j) {
          arg = user_args[i];
          results.push(user_args[i] = arg[0]);
        }
        return results;
      })();
    }
    modified = !!modified;
    if (callback) {
      return callback.apply(null, [err, modified].concat(slice.call(user_args)));
    }
  };
  exports.options(options, function(err, options) {
    if (err) {
      return finish(err);
    }
    return each(options).parallel(goptions.parallel).on('item', function(options, next) {
      return conditions.all(options, next, function() {
        return handler(options, function() {
          var arg, args, err, i, j, len, modif;
          err = arguments[0], modif = arguments[1], args = 3 <= arguments.length ? slice.call(arguments, 2) : [];
          if (!err && modif) {
            modified++;
          }
          for (i = j = 0, len = args.length; j < len; i = ++j) {
            arg = args[i];
            if (user_args[i] == null) {
              user_args[i] = [];
            }
            user_args[i].push(arg);
          }
          return next(err);
        });
      });
    }).on('both', function(err) {
      return finish(err);
    });
  });
  return context;
};

exports.args = function(args, overwrite_goptions) {
  var base;
  if (overwrite_goptions == null) {
    overwrite_goptions = {};
  }
  if (args.length === 2 && typeof args[1] === 'function') {
    args[2] = args[1];
    args[1] = {};
  } else if (args.length === 1) {
    args[1] = {};
    args[2] = null;
  }
  if ((base = args[1]).parallel == null) {
    base.parallel = 1;
  }
  return args;
};


/*

`options(options, callback)`
----------------------------
Normalize options. An ssh connection is needed if the key "ssh" 
hold a configuration object. The 'uid' and 'gid' fields will 
be converted to integer if they match a username or a group.   

`callback`          Received parameters are:   

*   `err`           Error object if any.   
*   `options`       Sanitized options.
 */

exports.options = function(options, callback) {
  if (!Array.isArray(options)) {
    options = [options];
  }
  return each(options).on('item', function(options, next) {
    var connection, destination, el, i, j, k, len, len1, mode, ref, ref1, source, uid_gid, v;
    if (typeof options.if_exists === 'string') {
      options.if_exists = [options.if_exists];
    }
    if (typeof options.not_if_exists === 'string') {
      options.not_if_exists = [options.not_if_exists];
    }
    if (options.if_exists) {
      ref = options.if_exists;
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        el = ref[i];
        if (el === true && options.destination) {
          options.if_exists[i] = options.destination;
        }
      }
    }
    if (options.not_if_exists) {
      ref1 = options.not_if_exists;
      for (i = k = 0, len1 = ref1.length; k < len1; i = ++k) {
        v = ref1[i];
        if (v === true && options.destination) {
          options.not_if_exists[i] = options.destination;
        }
      }
    }
    if (options.chmod) {
      if (options.mode == null) {
        options.mode = options.chmod;
      }
    }
    connection = function() {
      var ref2;
      if (!options.ssh) {
        return source();
      }
      if ((ref2 = options.ssh.config) != null ? ref2.host : void 0) {
        return source();
      }
      return connect(options.ssh, function(err, ssh) {
        if (err) {
          return next(err);
        }
        options.ssh = ssh;
        return source();
      });
    };
    source = function() {
      if (options.source == null) {
        return destination();
      }
      if (/^\w+:/.test(options.source)) {
        return destination();
      }
      return tilde(options.source, function(source) {
        options.source = source;
        return destination();
      });
    };
    destination = function() {
      if (options.destination == null) {
        return mode();
      }
      if (typeof options.destination !== 'string') {
        return mode();
      }
      if (/^\w+:/.test(options.source)) {
        return mode();
      }
      return tilde(options.destination, function(destination) {
        options.destination = destination;
        return mode();
      });
    };
    mode = function() {
      if (typeof options.mode === 'string') {
        options.mode = parseInt(options.mode, 8);
      }
      return uid_gid();
    };
    uid_gid = function() {
      return exports.uid_gid(options, next);
    };
    return connection();
  }).on('both', function(err) {
    return callback(err, options);
  });
};

exports.uid_gid = function(options, callback) {
  var do_gid, do_uid;
  do_uid = function() {
    if (!options.uid) {
      return do_gid();
    }
    if (typeof options.uid === 'string' && /\d+/.test(options.uid)) {
      options.uid = parseInt(options.uid, 10);
    }
    if (typeof options.uid === 'number') {
      return do_gid();
    }
    return misc.ssh.passwd(options.ssh, options.uid, function(err, user) {
      if (err) {
        return do_gid(err);
      }
      if (user) {
        options.uid = user.uid;
        if (options.gid == null) {
          options.gid = user.gid;
        }
      }
      return do_gid();
    });
  };
  do_gid = function() {
    if (!options.gid) {
      return callback();
    }
    if (typeof options.gid === 'string' && /\d+/.test(options.gid)) {
      options.gid = parseInt(options.gid, 10);
    }
    if (typeof options.gid === 'number') {
      return callback();
    }
    return misc.ssh.group(options.ssh, options.gid, function(err, group) {
      if (err) {
        return callback(err);
      }
      if (group) {
        options.gid = group.gid;
      }
      return callback();
    });
  };
  return do_uid();
};
