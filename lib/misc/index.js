// Generated by CoffeeScript 1.10.0
var Stream, each, exec, file, fs, ini, misc, path, rimraf, string, tilde, util,
  slice = [].slice;

fs = require('fs');

path = require('path');

each = require('each');

util = require('util');

Stream = require('stream');

exec = require('ssh2-exec');

rimraf = require('rimraf');

ini = require('ini');

tilde = require('tilde-expansion');

file = require('./file');

string = require('./string');

misc = module.exports = {
  array: {
    flatten: function(arr, ret) {
      var i, m, ref1;
      if (ret == null) {
        ret = [];
      }
      for (i = m = 0, ref1 = arr.length; 0 <= ref1 ? m < ref1 : m > ref1; i = 0 <= ref1 ? ++m : --m) {
        if (Array.isArray(arr[i])) {
          misc.array.flatten(arr[i], ret);
        } else {
          ret.push(arr[i]);
        }
      }
      return ret;
    },
    intersect: function(array) {
      var argument, i, item, j, len, len1, m, n, result;
      if (array === null) {
        return [];
      }
      result = [];
      for (i = m = 0, len = array.length; m < len; i = ++m) {
        item = array[i];
        if (result.indexOf(item) !== -1) {
          continue;
        }
        for (j = n = 0, len1 = arguments.length; n < len1; j = ++n) {
          argument = arguments[j];
          if (argument.indexOf(item) === -1) {
            break;
          }
        }
        if (j === arguments.length) {
          result.push(item);
        }
      }
      return result;
    },
    unique: function(array) {
      var el, len, m, o;
      o = {};
      for (m = 0, len = array.length; m < len; m++) {
        el = array[m];
        o[el] = true;
      }
      return Object.keys(o);
    },
    merge: function() {
      var array, arrays, el, len, len1, m, n, r;
      arrays = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      r = [];
      for (m = 0, len = arrays.length; m < len; m++) {
        array = arrays[m];
        for (n = 0, len1 = array.length; n < len1; n++) {
          el = array[n];
          r.push(el);
        }
      }
      return r;
    }
  },
  regexp: {
    escape: function(str) {
      return str.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    }
  },
  object: {
    equals: function(obj1, obj2, keys) {
      var k, keys1, keys2, len, m;
      keys1 = Object.keys(obj1);
      keys2 = Object.keys(obj2);
      if (keys) {
        keys1 = keys1.filter(function(k) {
          return keys.indexOf(k) !== -1;
        });
        keys2 = keys2.filter(function(k) {
          return keys.indexOf(k) !== -1;
        });
      } else {
        keys = keys1;
      }
      if (keys1.length !== keys2.length) {
        return false;
      }
      for (m = 0, len = keys.length; m < len; m++) {
        k = keys[m];
        if (obj1[k] !== obj2[k]) {
          return false;
        }
      }
      return true;
    },
    diff: function(obj1, obj2, keys) {
      var diff, k, keys1, keys2, v;
      if (!keys) {
        keys1 = Object.keys(obj1);
        keys2 = Object.keys(obj2);
        keys = misc.array.merge(keys1, keys2, misc.array.unique(keys1));
      }
      diff = {};
      for (k in obj1) {
        v = obj1[k];
        if (!(keys.indexOf(k) >= 0)) {
          continue;
        }
        if (obj2[k] === v) {
          continue;
        }
        diff[k] = [];
        diff[k][0] = v;
      }
      for (k in obj2) {
        v = obj2[k];
        if (!(keys.indexOf(k) >= 0)) {
          continue;
        }
        if (obj1[k] === v) {
          continue;
        }
        if (diff[k] == null) {
          diff[k] = [];
        }
        diff[k][1] = v;
      }
      return diff;
    },
    clone: function(obj) {
      return misc.merge({}, obj);
    }
  },
  path: {
    normalize: function(location, callback) {
      return tilde(location, function(location) {
        return callback(path.normalize(location));
      });
    },
    resolve: function() {
      var callback, locations, m, normalized;
      locations = 2 <= arguments.length ? slice.call(arguments, 0, m = arguments.length - 1) : (m = 0, []), callback = arguments[m++];
      normalized = [];
      return each(locations).call(function(location, next) {
        return misc.path.normalize(location, function(location) {
          normalized.push(location);
          return next();
        });
      }).then(function() {
        return callback(path.resolve.apply(path, normalized));
      });
    }
  },
  mode: {
    stringify: function(mode) {
      if (typeof mode === 'number') {
        return mode.toString(8);
      } else {
        return mode;
      }
    },
    compare: function() {
      var i, l, m, mode, modes, ref, ref1;
      modes = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      ref = misc.mode.stringify(modes[0]);
      for (i = m = 1, ref1 = modes.length; 1 <= ref1 ? m < ref1 : m > ref1; i = 1 <= ref1 ? ++m : --m) {
        mode = misc.mode.stringify(modes[i]);
        l = Math.min(ref.length, mode.length);
        if (mode.substr(-l) !== ref.substr(-l)) {
          return false;
        }
      }
      return true;
    }
  },
  file: {
    copyFile: function(ssh, source, destination, callback) {
      var s;
      s = function(ssh, callback) {
        if (!ssh) {
          return callback(null, fs);
        } else {
          return ssh.sftp(callback);
        }
      };
      return s(ssh, function(err, fs) {
        var rs, ws;
        if (err) {
          return callback(err);
        }
        rs = fs.createReadStream(source);
        ws = rs.pipe(fs.createWriteStream(destination));
        ws.on('close', function() {
          var modified;
          if (fs.end) {
            fs.end();
          }
          modified = true;
          return callback();
        });
        return ws.on('error', callback);
      });
    },

    /*
    Compare modes
    -------------
     */
    cmpmod: function() {
      var modes, ref1;
      modes = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      console.log('Deprecated, use `misc.mode.compare`');
      return (ref1 = misc.mode.compare).call.apply(ref1, [this].concat(slice.call(modes)));
    },
    copy: function(ssh, source, destination, callback) {
      if (!ssh) {
        source = fs.createReadStream(u.pathname);
        source.pipe(destination);
        destination.on('close', callback);
        return destination.on('error', callback);
      } else {
        return callback(new Error('Copy over SSH not yet implemented'));
      }
    },

    /*
    `files.compare(files, callback)`
    --------------------------------
    Compare the hash of multiple file. Return the file md5 
    if the file are the same or false otherwise.
     */
    compare: function(ssh, files, callback) {
      var result;
      if (files.length < 2) {
        return callback(new Error('Minimum of 2 files'));
      }
      result = null;
      return each(files).call(function(f, next) {
        return file.hash(ssh, f, function(err, md5) {
          if (err) {
            return next(err);
          }
          if (result === null) {
            result = md5;
          } else if (result !== md5) {
            result = false;
          }
          return next();
        });
      }).then(function(err) {
        if (err) {
          return callback(err);
        }
        return callback(null, result);
      });
    },

    /*
    remove(ssh, path, callback)
    ---------------------------
    Remove a file or directory
     */
    remove: function(ssh, path, callback) {
      var child;
      if (!ssh) {
        return rimraf(path, callback);
      } else {
        child = exec(ssh, "rm -rf " + path);
        return child.on('exit', function(code) {
          return callback(null, code);
        });
      }
    }
  },

  /*
  `isPortOpen(port, host, callback)`: Check if a port is already open
   */
  isPortOpen: function(port, host, callback) {
    if (arguments.length === 2) {
      callback = host;
      host = '127.0.0.1';
    }
    return exec("nc " + host + " " + port + " < /dev/null", function(err, stdout, stderr) {
      if (!err) {
        return callback(null, true);
      }
      if (err.code === 1) {
        return callback(null, false);
      }
      return callback(err);
    });
  },

  /*
  `merge([inverse], obj1, obj2, ...]`: Recursively merge objects
  --------------------------------------------------------------
  On matching keys, the last object take precedence over previous ones 
  unless the inverse arguments is provided as true. Only objects are 
  merge, arrays are overwritten.
  
  Enrich an existing object with a second one:
    obj1 = { a_key: 'a value', b_key: 'b value'}
    obj2 = { b_key: 'new b value'}
    result = misc.merge obj1, obj2
    assert.eql result, obj1
    assert.eql obj1.b_key, 'new b value'
  
  Create a new object from two objects:
    obj1 = { a_key: 'a value', b_key: 'b value'}
    obj2 = { b_key: 'new b value'}
    result = misc.merge {}, obj1, obj2
    assert.eql result.b_key, 'new b value'
  
  Using inverse:
    obj1 = { b_key: 'b value'}
    obj2 = { a_key: 'a value', b_key: 'new b value'}
    misc.merge true, obj1, obj2
    assert.eql obj1.a_key, 'a value'
    assert.eql obj1.b_key, 'b value'
   */
  merge: function() {
    var clone, copy, from, i, inverse, m, name, options, ref1, ref2, src, target, to;
    target = arguments[0];
    from = 1;
    to = arguments.length;
    if (typeof target === 'boolean') {
      inverse = !!target;
      target = arguments[1];
      from = 2;
    }
    if (typeof target !== "object" && typeof target !== 'function') {
      target = {};
    }
    for (i = m = ref1 = from, ref2 = to; ref1 <= ref2 ? m < ref2 : m > ref2; i = ref1 <= ref2 ? ++m : --m) {
      if ((options = arguments[i]) !== null) {
        for (name in options) {
          src = target[name];
          copy = options[name];
          if (target === copy) {
            continue;
          }
          if ((copy != null) && typeof copy === 'object' && !Array.isArray(copy) && !(copy instanceof RegExp)) {
            clone = src && (src && typeof src === 'object' ? src : {});
            target[name] = misc.merge(false, clone, copy);
          } else if (copy !== void 0) {
            if (!(inverse && typeof target[name] !== 'undefined')) {
              target[name] = copy;
            }
          }
        }
      }
    }
    return target;
  },
  kadmin: function(options, cmd) {
    var realm;
    realm = options.realm ? "-r " + options.realm : '';
    if (options.kadmin_principal) {
      return "kadmin " + realm + " -p " + options.kadmin_principal + " -s " + options.kadmin_server + " -w " + options.kadmin_password + " -q '" + cmd + "'";
    } else {
      return "kadmin.local " + realm + " -q '" + cmd + "'";
    }
  },
  yaml: {
    merge: function(original, new_obj, undefinedOnly) {
      var k, v;
      for (k in original) {
        v = original[k];
        if (v && typeof v === 'object' && typeof new_obj[k] !== 'undefined') {
          new_obj[k] = misc.yaml.merge(v, new_obj[k], undefinedOnly);
          continue;
        }
        if (typeof new_obj[k] === 'undefined') {
          new_obj[k] = v;
        }
      }
      return new_obj;
    },
    clean: function(original, new_obj, undefinedOnly) {
      var k, v;
      for (k in original) {
        v = original[k];
        if (v && typeof v === 'object' && new_obj[k]) {
          original[k] = misc.yaml.clean(v, new_obj[k], undefinedOnly);
          continue;
        }
        if (new_obj[k] === null) {
          delete original[k];
        }
      }
      return original;
    }
  },
  ini: {
    clean: function(content, undefinedOnly) {
      var k, v;
      for (k in content) {
        v = content[k];
        if (v && typeof v === 'object') {
          content[k] = misc.ini.clean(v, undefinedOnly);
          continue;
        }
        if (typeof v === 'undefined') {
          delete content[k];
        }
        if (!undefinedOnly && v === null) {
          delete content[k];
        }
      }
      return content;
    },
    safe: function(val) {
      if (typeof val !== "string" || val.match(/[\r\n]/) || val.match(/^\[/) || (val.length > 1 && val.charAt(0) === "\"" && val.slice(-1) === "\"") || val !== val.trim()) {
        return JSON.stringify(val);
      } else {
        return val.replace(/;/g, '\\;');
      }
    },
    dotSplit: function (str) {
      return str.replace(/\1/g, '\2LITERAL\\1LITERAL\2')
             .replace(/\\\./g, '\1')
             .split(/\./).map(function (part) {
               return part.replace(/\1/g, '\\.')
                      .replace(/\2LITERAL\\1LITERAL\2/g, '\1')
             })
    },
    parse: function(content, options) {
      return ini.parse(content);
    },

    /*
    
    Each category is surrounded by one or several square brackets. The number of brackets indicates
    the depth of the category.
    Options are   
    
    *   `comment`   Default to ";"
     */
    parse_multi_brackets: function(str, options) {
      var comment, current, data, lines, stack;
      if (options == null) {
        options = {};
      }
      lines = string.lines(str);
      current = data = {};
      stack = [current];
      comment = options.comment || ';';
      lines.forEach(function(line, _, __) {
        var depth, match, parent;
        if (!line || line.match(/^\s*$/)) {
          return;
        }
        if (match = line.match(/^\s*(\[+)(.+?)(\]+)\s*$/)) {
          depth = match[1].length;
          if (depth === stack.length) {
            parent = stack[depth - 1];
            parent[match[2]] = current = {};
            stack.push(current);
          }
          if (depth > stack.length) {
            throw new Error("Invalid child " + match[2]);
          }
          if (depth < stack.length) {
            stack.splice(depth, stack.length - depth);
            parent = stack[depth - 1];
            parent[match[2]] = current = {};
            return stack.push(current);
          }
        } else if (comment && (match = line.match(RegExp("^\\s*(" + comment + ".*)$")))) {
          return current[match[1]] = null;
        } else if (match = line.match(/^\s*(.+?)\s*=\s*(.+)\s*$/)) {
          return current[match[1]] = match[2];
        } else if (match = line.match(/^\s*(.+?)\s*$/)) {
          return current[match[1]] = null;
        }
      });
      return data;
    },

    /*
    
    Same as the parse_multi_brackets instead it takes in count values which are defined on several lines
    As an example the ambari-agent .ini configuration file
    
    *   `comment`   Default to ";"
     */
    parse_multi_brackets_multi_lines: function(str, options) {
      var comment, current, data, lines, previous, stack, writing;
      if (options == null) {
        options = {};
      }
      lines = string.lines(str);
      current = data = {};
      stack = [current];
      comment = options.comment || ';';
      writing = false;
      previous = {};
      lines.forEach(function(line, _, __) {
        var depth, match, parent;
        if (!line || line.match(/^\s*$/)) {
          return;
        }
        if (match = line.match(/^\s*(\[+)(.+?)(\]+)\s*$/)) {
          depth = match[1].length;
          if (depth === stack.length) {
            parent = stack[depth - 1];
            parent[match[2]] = current = {};
            stack.push(current);
          }
          if (depth > stack.length) {
            throw new Error("Invalid child " + match[2]);
          }
          if (depth < stack.length) {
            stack.splice(depth, stack.length - depth);
            parent = stack[depth - 1];
            parent[match[2]] = current = {};
            return stack.push(current);
          }
        } else if (comment && (match = line.match(RegExp("^\\s*(" + comment + ".*)$")))) {
          writing = false;
          return current[match[1]] = null;
        } else if (match = line.match(/^\s*(.+?)\s*=\s*(.+)\s*$/)) {
          writing = false;
          current[match[1]] = match[2];
          previous = match[1];
          return writing = true;
        } else if (match = line.match(/^\s*(.+?)\s*$/)) {
          if (writing) {
            return current[previous] += match[1];
          } else {
            return current[match[1]] = null;
          }
        }
      });
      return data;
    },
    stringify: function(obj, section, options) {
      var children, dotSplit, eol, out, safe;
      if (options == null) {
        options = {};
      }
      if (arguments.length === 2) {
        options = section;
        section = void 0;
      }
      if (options.separator == null) {
        options.separator = ' = ';
      }
      eol = process.platform === "win32" ? "\r\n" : "\n";
      safe = misc.ini.safe;
      dotSplit = misc.ini.dotSplit;
      children = [];
      out = "";
      Object.keys(obj).forEach(function(k, _, __) {
        var val;
        val = obj[k];
        if (val && Array.isArray(val)) {
          return val.forEach(function(item) {
            return out += safe(k + "[]") + options.separator + safe(item) + "\n";
          });
        } else if (val && typeof val === "object") {
          return children.push(k);
        } else {
          return out += safe(k) + options.separator + safe(val) + eol;
        }
      });
      if (section && out.length) {
        out = "[" + safe(section) + "]" + eol + out;
      }
      children.forEach(function(k, _, __) {
        var child, nk;
        nk = dotSplit(k).join('\\.');
        child = misc.ini.stringify(obj[k], (section ? section + "." : "") + nk, options);
        if (out.length && child.length) {
          out += eol;
        }
        return out += child;
      });
      return out;
    },
    stringify_square_then_curly: function(content, depth, options) {
      var element, i, indent, isArray, isBoolean, isNull, isObj, k, len, m, n, out, outa, prefix, ref1, v;
      if (depth == null) {
        depth = 0;
      }
      if (options == null) {
        options = {};
      }
      if (arguments.length === 2) {
        options = depth;
        depth = 0;
      }
      if (options.separator == null) {
        options.separator = ' = ';
      }
      out = '';
      indent = ' ';
      prefix = '';
      for (i = m = 0, ref1 = depth; 0 <= ref1 ? m < ref1 : m > ref1; i = 0 <= ref1 ? ++m : --m) {
        prefix += indent;
      }
      for (k in content) {
        v = content[k];
        isBoolean = typeof v === 'boolean';
        isNull = v === null;
        isArray = Array.isArray(v);
        isObj = typeof v === 'object' && !isNull && !isArray;
        if (isObj) {
          if (depth === 0) {
            out += prefix + "[" + k + "]\n";
            out += misc.ini.stringify_square_then_curly(v, depth + 1, options);
            out += "\n";
          } else {
            out += "" + prefix + k + options.separator + "{\n";
            out += misc.ini.stringify_square_then_curly(v, depth + 1, options);
            out += prefix + "}\n";
          }
        } else {
          if (isArray) {
            outa = [];
            for (n = 0, len = v.length; n < len; n++) {
              element = v[n];
              outa.push("" + prefix + k + options.separator + element);
            }
            out += outa.join('\n');
          } else if (isNull) {
            out += "" + prefix + k + options.separator + "null";
          } else if (isBoolean) {
            out += "" + prefix + k + options.separator + (v ? 'true' : 'false');
          } else {
            out += "" + prefix + k + options.separator + v;
          }
          out += '\n';
        }
      }
      return out;
    },

    /*
    Each category is surrounded by one or several square brackets. The number of brackets indicates
    the depth of the category.
    Taking now indent option into consideration: some file are indent aware ambari-agent .ini file
     */
    stringify_multi_brackets: function(content, depth, options) {
      var i, indent, isBoolean, isNull, isObj, k, m, out, prefix, ref1, v;
      if (depth == null) {
        depth = 0;
      }
      if (options == null) {
        options = {};
      }
      if (arguments.length === 2) {
        options = depth;
        depth = 0;
      }
      if (options.separator == null) {
        options.separator = ' = ';
      }
      out = '';
      indent = options.indent != null ? options.indent : '  ';
      prefix = '';
      for (i = m = 0, ref1 = depth; 0 <= ref1 ? m < ref1 : m > ref1; i = 0 <= ref1 ? ++m : --m) {
        prefix += indent;
      }
      for (k in content) {
        v = content[k];
        isBoolean = typeof v === 'boolean';
        isNull = v === null;
        isObj = typeof v === 'object' && !isNull;
        if (isObj) {
          continue;
        }
        if (isNull) {
          out += "" + prefix + k;
        } else if (isBoolean) {
          out += "" + prefix + k + options.separator + (v ? 'true' : 'false');
        } else {
          out += "" + prefix + k + options.separator + v;
        }
        out += '\n';
      }
      for (k in content) {
        v = content[k];
        isNull = v === null;
        isObj = typeof v === 'object' && !isNull;
        if (!isObj) {
          continue;
        }
        out += "" + prefix + (string.repeat('[', depth + 1)) + k + (string.repeat(']', depth + 1)) + "\n";
        out += misc.ini.stringify_multi_brackets(v, depth + 1, options);
      }
      return out;
    }
  }
};
