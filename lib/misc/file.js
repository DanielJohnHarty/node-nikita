// Generated by CoffeeScript 1.10.0
var crypto, each, exec, file, glob, ssh2fs;

ssh2fs = require('ssh2-fs');

crypto = require('crypto');

exec = require('ssh2-exec');

each = require('each');

glob = require('./glob');

module.exports = file = {
  compare_hash: function(ssh1, file1, ssh2, file2, algo, callback) {
    return file.hash(ssh1, file1, algo, function(err, hash1) {
      if (err) {
        return callback(err);
      }
      return file.hash(ssh2, file2, algo, function(err, hash2) {
        if ((err != null ? err.code : void 0) === 'ENOENT') {
          err = null;
        }
        if (err) {
          return callback(err);
        }
        return callback(null, hash1 === hash2, hash1, hash2);
      });
    });
  },

  /*
  `files.hash(file, [algorithm], callback)`
  -----------------------------------------
  Retrieve the hash of a supplied file in hexadecimal 
  form. If the provided file is a directory, the returned hash 
  is the sum of all the hashs of the files it recursively 
  contains. The default algorithm to compute the hash is md5.
  
  Throw an error if file does not exist unless it is a directory.
  
      file.hash ssh, '/path/to/file', (err, md5) ->
        md5.should.eql '287621a8df3c3f6c99c7b7645bd09ffd'
   */
  hash: function(ssh, file, algorithm, callback) {
    var hasher, hashs;
    if (arguments.length === 3) {
      callback = algorithm;
      algorithm = 'md5';
    }
    hasher = function(ssh, path, callback) {
      var shasum;
      shasum = crypto.createHash(algorithm);
      if (!ssh) {
        return ssh2fs.createReadStream(ssh, path, function(err, stream) {
          if (err) {
            return callback(err);
          }
          return stream.on('data', function(data) {
            return shasum.update(data);
          }).on('error', function(err) {
            if (err.code === 'EISDIR') {
              return callback();
            }
            return callback(err);
          }).on('end', function() {
            return callback(err, shasum.digest('hex'));
          });
        });
      } else {
        return ssh2fs.stat(ssh, path, function(err, stat) {
          if (err) {
            return callback(err);
          }
          if (stat.isDirectory()) {
            return callback();
          }
          return exec({
            cmd: "openssl " + algorithm + " " + path,
            ssh: ssh
          }, function(err, stdout) {
            if (err) {
              callback(err);
            }
            return callback(err, /.*\s([\w\d]+)$/.exec(stdout.trim())[1]);
          });
        });
      }
    };
    hashs = [];
    return ssh2fs.stat(ssh, file, function(err, stat) {
      var compute;
      if ((err != null ? err.code : void 0) === 'ENOENT') {
        err = Error("Does not exist: " + file);
        err.code = 'ENOENT';
        return callback(err);
      }
      if (err) {
        return callback(err);
      }
      if (stat.isFile()) {
        return hasher(ssh, file, callback);
      } else if (stat.isDirectory()) {
        compute = function(files) {
          files.sort();
          return each(files).call(function(item, next) {
            return hasher(ssh, item, function(err, h) {
              if (err) {
                return next(err);
              }
              if (h != null) {
                hashs.push(h);
              }
              return next();
            });
          }).then(function(err) {
            if (err) {
              return callback(err);
            }
            switch (hashs.length) {
              case 0:
                if (stat.isFile()) {
                  return callback(new Error("Does not exist: " + file));
                } else {
                  return callback(null, crypto.createHash(algorithm).update('').digest('hex'));
                }
                break;
              case 1:
                return callback(null, hashs[0]);
              default:
                hashs = crypto.createHash(algorithm).update(hashs.join('')).digest('hex');
                return callback(null, hashs);
            }
          });
        };
        return glob(ssh, file + "/**", function(err, files) {
          if (err) {
            return callback(err);
          }
          return compute(files);
        });
      } else {
        return callback(Error("File type not supported"));
      }
    });
  }
};
